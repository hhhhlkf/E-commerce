/* soapStub.h
   Generated by gSOAP 2.8.117 for taskInfo.h

gSOAP XML Web services tools
Copyright (C) 2000-2021, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include <vector>
#define SOAP_NAMESPACE_OF_lkf2	"http://dao.linexus.com/"

#ifndef soapStub_H
#define soapStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 208117
# error "GSOAP VERSION 208117 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

class lkf2__addProduct;	/* taskInfo.h:162 */
class lkf2__product;	/* taskInfo.h:164 */
class lkf2__addProductResponse;	/* taskInfo.h:166 */
class lkf2__deleteProductTypeByName;	/* taskInfo.h:168 */
class lkf2__deleteProductTypeByNameResponse;	/* taskInfo.h:170 */
class lkf2__getOrderList;	/* taskInfo.h:172 */
class lkf2__getOrderListResponse;	/* taskInfo.h:174 */
class lkf2__order;	/* taskInfo.h:176 */
class lkf2__getProductListByInfo;	/* taskInfo.h:178 */
class lkf2__getProductListByInfoResponse;	/* taskInfo.h:180 */
class lkf2__updateClient;	/* taskInfo.h:182 */
class lkf2__client;	/* taskInfo.h:184 */
class lkf2__updateClientResponse;	/* taskInfo.h:186 */
class lkf2__deleteClientByNameAndPwd;	/* taskInfo.h:188 */
class lkf2__deleteClientByNameAndPwdResponse;	/* taskInfo.h:190 */
class lkf2__deleteProductByInfo;	/* taskInfo.h:192 */
class lkf2__deleteProductByInfoResponse;	/* taskInfo.h:194 */
class lkf2__getOrderLikeList;	/* taskInfo.h:196 */
class lkf2__getOrderLikeListResponse;	/* taskInfo.h:198 */
class lkf2__getClientLikeList;	/* taskInfo.h:200 */
class lkf2__getClientLikeListResponse;	/* taskInfo.h:202 */
class lkf2__getProductTypeByProName;	/* taskInfo.h:204 */
class lkf2__getProductTypeByProNameResponse;	/* taskInfo.h:206 */
class lkf2__productType;	/* taskInfo.h:208 */
class lkf2__getClientList;	/* taskInfo.h:210 */
class lkf2__getClientListResponse;	/* taskInfo.h:212 */
class lkf2__getOrderListByInfo;	/* taskInfo.h:214 */
class lkf2__getOrderListByInfoResponse;	/* taskInfo.h:216 */
class lkf2__addProductType;	/* taskInfo.h:218 */
class lkf2__addProductTypeResponse;	/* taskInfo.h:220 */
class lkf2__updateProductByInfo;	/* taskInfo.h:222 */
class lkf2__updateProductByInfoResponse;	/* taskInfo.h:224 */
class lkf2__getProductLikeList;	/* taskInfo.h:226 */
class lkf2__getProductLikeListResponse;	/* taskInfo.h:228 */
class lkf2__addOrder;	/* taskInfo.h:230 */
class lkf2__addOrderResponse;	/* taskInfo.h:232 */
class lkf2__getClientByNameAndPwd;	/* taskInfo.h:234 */
class lkf2__getClientByNameAndPwdResponse;	/* taskInfo.h:236 */
class lkf2__deleteShoppingCart;	/* taskInfo.h:238 */
class lkf2__deleteShoppingCartResponse;	/* taskInfo.h:240 */
class lkf2__getProductList;	/* taskInfo.h:242 */
class lkf2__getProductListResponse;	/* taskInfo.h:244 */
class lkf2__InsertClient;	/* taskInfo.h:246 */
class lkf2__InsertClientResponse;	/* taskInfo.h:248 */
class lkf2__getOrderListHistory;	/* taskInfo.h:250 */
class lkf2__getOrderListHistoryResponse;	/* taskInfo.h:252 */
class lkf2__updateHistory;	/* taskInfo.h:254 */
class lkf2__updateHistoryResponse;	/* taskInfo.h:256 */
struct __lkf1__addProduct;	/* taskInfo.h:1621 */
struct __lkf1__deleteProductTypeByName;	/* taskInfo.h:1688 */
struct __lkf1__getOrderList;	/* taskInfo.h:1755 */
struct __lkf1__getProductListByInfo;	/* taskInfo.h:1822 */
struct __lkf1__updateClient;	/* taskInfo.h:1889 */
struct __lkf1__deleteClientByNameAndPwd;	/* taskInfo.h:1956 */
struct __lkf1__deleteProductByInfo;	/* taskInfo.h:2023 */
struct __lkf1__getOrderLikeList;	/* taskInfo.h:2090 */
struct __lkf1__getClientLikeList;	/* taskInfo.h:2157 */
struct __lkf1__getProductTypeByProName;	/* taskInfo.h:2224 */
struct __lkf1__getClientList;	/* taskInfo.h:2291 */
struct __lkf1__getOrderListByInfo;	/* taskInfo.h:2358 */
struct __lkf1__addProductType;	/* taskInfo.h:2425 */
struct __lkf1__updateProductByInfo;	/* taskInfo.h:2492 */
struct __lkf1__getProductLikeList;	/* taskInfo.h:2559 */
struct __lkf1__addOrder;	/* taskInfo.h:2626 */
struct __lkf1__getClientByNameAndPwd;	/* taskInfo.h:2693 */
struct __lkf1__deleteShoppingCart;	/* taskInfo.h:2760 */
struct __lkf1__getProductList;	/* taskInfo.h:2827 */
struct __lkf1__InsertClient;	/* taskInfo.h:2894 */
struct __lkf1__getOrderListHistory;	/* taskInfo.h:2961 */
struct __lkf1__updateHistory;	/* taskInfo.h:3028 */

/* taskInfo.h:162 */
#ifndef SOAP_TYPE_lkf2__addProduct
#define SOAP_TYPE_lkf2__addProduct (10)
/* complex XML schema type 'lkf2:addProduct': */
class SOAP_CMAC lkf2__addProduct {
      public:
        /// Optional element 'arg0' of XML schema type 'lkf2:product'
        lkf2__product *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_lkf2__addProduct
        virtual long soap_type(void) const { return SOAP_TYPE_lkf2__addProduct; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type lkf2__addProduct, default initialized and not managed by a soap context
        virtual lkf2__addProduct *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(lkf2__addProduct); }
      public:
        /// Constructor with default initializations
        lkf2__addProduct() : arg0(), soap() { }
        virtual ~lkf2__addProduct() { }
        /// Friend allocator used by soap_new_lkf2__addProduct(struct soap*, int)
        friend SOAP_FMAC1 lkf2__addProduct * SOAP_FMAC2 soap_instantiate_lkf2__addProduct(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:164 */
#ifndef SOAP_TYPE_lkf2__product
#define SOAP_TYPE_lkf2__product (11)
/* complex XML schema type 'lkf2:product': */
class SOAP_CMAC lkf2__product {
      public:
        /// Required element 'productBuyNum' of XML schema type 'xsd:int'
        int productBuyNum;
        /// Required element 'productDiscount' of XML schema type 'xsd:float'
        float productDiscount;
        /// Required element 'productId' of XML schema type 'xsd:int'
        int productId;
        /// Optional element 'productImage' of XML schema type 'xsd:string'
        std::string *productImage;
        /// Optional element 'productName' of XML schema type 'xsd:string'
        std::string *productName;
        /// Required element 'productNum' of XML schema type 'xsd:int'
        int productNum;
        /// Required element 'productPrice' of XML schema type 'xsd:int'
        int productPrice;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_lkf2__product
        virtual long soap_type(void) const { return SOAP_TYPE_lkf2__product; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type lkf2__product, default initialized and not managed by a soap context
        virtual lkf2__product *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(lkf2__product); }
      public:
        /// Constructor with default initializations
        lkf2__product() : productBuyNum(), productDiscount(), productId(), productImage(), productName(), productNum(), productPrice(), soap() { }
        lkf2__product(int buynum,float discount,int pId,std::string *pImage,std::string *pName,int pNum,int pPrice)
        : productBuyNum(buynum), productDiscount(discount), productId(pId), productImage(pImage), productName(pName), productNum(pNum), productPrice(pPrice), soap() { }
        virtual ~lkf2__product() { }
        /// Friend allocator used by soap_new_lkf2__product(struct soap*, int)
        friend SOAP_FMAC1 lkf2__product * SOAP_FMAC2 soap_instantiate_lkf2__product(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:166 */
#ifndef SOAP_TYPE_lkf2__addProductResponse
#define SOAP_TYPE_lkf2__addProductResponse (12)
/* complex XML schema type 'lkf2:addProductResponse': */
class SOAP_CMAC lkf2__addProductResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_lkf2__addProductResponse
        virtual long soap_type(void) const { return SOAP_TYPE_lkf2__addProductResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type lkf2__addProductResponse, default initialized and not managed by a soap context
        virtual lkf2__addProductResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(lkf2__addProductResponse); }
      public:
        /// Constructor with default initializations
        lkf2__addProductResponse() : soap() { }
        virtual ~lkf2__addProductResponse() { }
        /// Friend allocator used by soap_new_lkf2__addProductResponse(struct soap*, int)
        friend SOAP_FMAC1 lkf2__addProductResponse * SOAP_FMAC2 soap_instantiate_lkf2__addProductResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:168 */
#ifndef SOAP_TYPE_lkf2__deleteProductTypeByName
#define SOAP_TYPE_lkf2__deleteProductTypeByName (13)
/* complex XML schema type 'lkf2:deleteProductTypeByName': */
class SOAP_CMAC lkf2__deleteProductTypeByName {
      public:
        /// Optional element 'arg0' of XML schema type 'xsd:string'
        std::string *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_lkf2__deleteProductTypeByName
        virtual long soap_type(void) const { return SOAP_TYPE_lkf2__deleteProductTypeByName; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type lkf2__deleteProductTypeByName, default initialized and not managed by a soap context
        virtual lkf2__deleteProductTypeByName *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(lkf2__deleteProductTypeByName); }
      public:
        /// Constructor with default initializations
        lkf2__deleteProductTypeByName() : arg0(), soap() { }
        virtual ~lkf2__deleteProductTypeByName() { }
        /// Friend allocator used by soap_new_lkf2__deleteProductTypeByName(struct soap*, int)
        friend SOAP_FMAC1 lkf2__deleteProductTypeByName * SOAP_FMAC2 soap_instantiate_lkf2__deleteProductTypeByName(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:170 */
#ifndef SOAP_TYPE_lkf2__deleteProductTypeByNameResponse
#define SOAP_TYPE_lkf2__deleteProductTypeByNameResponse (14)
/* complex XML schema type 'lkf2:deleteProductTypeByNameResponse': */
class SOAP_CMAC lkf2__deleteProductTypeByNameResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_lkf2__deleteProductTypeByNameResponse
        virtual long soap_type(void) const { return SOAP_TYPE_lkf2__deleteProductTypeByNameResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type lkf2__deleteProductTypeByNameResponse, default initialized and not managed by a soap context
        virtual lkf2__deleteProductTypeByNameResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(lkf2__deleteProductTypeByNameResponse); }
      public:
        /// Constructor with default initializations
        lkf2__deleteProductTypeByNameResponse() : soap() { }
        virtual ~lkf2__deleteProductTypeByNameResponse() { }
        /// Friend allocator used by soap_new_lkf2__deleteProductTypeByNameResponse(struct soap*, int)
        friend SOAP_FMAC1 lkf2__deleteProductTypeByNameResponse * SOAP_FMAC2 soap_instantiate_lkf2__deleteProductTypeByNameResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:172 */
#ifndef SOAP_TYPE_lkf2__getOrderList
#define SOAP_TYPE_lkf2__getOrderList (15)
/* complex XML schema type 'lkf2:getOrderList': */
class SOAP_CMAC lkf2__getOrderList {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_lkf2__getOrderList
        virtual long soap_type(void) const { return SOAP_TYPE_lkf2__getOrderList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type lkf2__getOrderList, default initialized and not managed by a soap context
        virtual lkf2__getOrderList *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(lkf2__getOrderList); }
      public:
        /// Constructor with default initializations
        lkf2__getOrderList() : soap() { }
        virtual ~lkf2__getOrderList() { }
        /// Friend allocator used by soap_new_lkf2__getOrderList(struct soap*, int)
        friend SOAP_FMAC1 lkf2__getOrderList * SOAP_FMAC2 soap_instantiate_lkf2__getOrderList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:174 */
#ifndef SOAP_TYPE_lkf2__getOrderListResponse
#define SOAP_TYPE_lkf2__getOrderListResponse (16)
/* complex XML schema type 'lkf2:getOrderListResponse': */
class SOAP_CMAC lkf2__getOrderListResponse {
      public:
        /// Optional element 'return' of XML schema type 'lkf2:order'
        std::vector<lkf2__order *> return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_lkf2__getOrderListResponse
        virtual long soap_type(void) const { return SOAP_TYPE_lkf2__getOrderListResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type lkf2__getOrderListResponse, default initialized and not managed by a soap context
        virtual lkf2__getOrderListResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(lkf2__getOrderListResponse); }
      public:
        /// Constructor with default initializations
        lkf2__getOrderListResponse() : return_(), soap() { }
        virtual ~lkf2__getOrderListResponse() { }
        /// Friend allocator used by soap_new_lkf2__getOrderListResponse(struct soap*, int)
        friend SOAP_FMAC1 lkf2__getOrderListResponse * SOAP_FMAC2 soap_instantiate_lkf2__getOrderListResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:176 */
#ifndef SOAP_TYPE_lkf2__order
#define SOAP_TYPE_lkf2__order (17)
/* complex XML schema type 'lkf2:order': */
class SOAP_CMAC lkf2__order {
      public:
        /// Required element 'orderCheck' of XML schema type 'xsd:int'
        int orderCheck;
        /// Optional element 'orderClient' of XML schema type 'xsd:string'
        std::string *orderClient;
        /// Required element 'orderClientId' of XML schema type 'xsd:int'
        int orderClientId;
        /// Optional element 'orderCost' of XML schema type 'xsd:decimal'
        std::string *orderCost;
        /// Required element 'orderHide' of XML schema type 'xsd:int'
        int orderHide;
        /// Required element 'orderId' of XML schema type 'xsd:int'
        int orderId;
        /// Required element 'orderProductId' of XML schema type 'xsd:int'
        int orderProductId;
        /// Optional element 'orderProductName' of XML schema type 'xsd:string'
        std::string *orderProductName;
        /// Required element 'orderProductNum' of XML schema type 'xsd:int'
        int orderProductNum;
        /// Optional element 'orderProductStyle' of XML schema type 'xsd:string'
        std::string *orderProductStyle;
        /// Optional element 'orderTime' of XML schema type 'xsd:dateTime'
        time_t *orderTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_lkf2__order
        virtual long soap_type(void) const { return SOAP_TYPE_lkf2__order; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type lkf2__order, default initialized and not managed by a soap context
        virtual lkf2__order *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(lkf2__order); }
      public:
        /// Constructor with default initializations
        ///
        lkf2__order() : orderCheck(), orderClient(), orderClientId(), orderCost(), orderHide(), orderId(), orderProductId(), orderProductName(), orderProductNum(), orderProductStyle(), orderTime(), soap() { }
        lkf2__order(int check,std::string * client,int cid,std::string *cost,int hide,int id,int pid,std::string *Pname,int Pnum,std::string *Pstyle,time_t* time) :
        orderCheck(check), orderClient(client), orderClientId(cid), orderCost(cost), orderHide(hide), orderId(id), orderProductId(pid), orderProductName(Pname), orderProductNum(Pnum), orderProductStyle(Pstyle), orderTime(time), soap() { }
        virtual ~lkf2__order() { }
        /// Friend allocator used by soap_new_lkf2__order(struct soap*, int)
        friend SOAP_FMAC1 lkf2__order * SOAP_FMAC2 soap_instantiate_lkf2__order(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:178 */
#ifndef SOAP_TYPE_lkf2__getProductListByInfo
#define SOAP_TYPE_lkf2__getProductListByInfo (18)
/* complex XML schema type 'lkf2:getProductListByInfo': */
class SOAP_CMAC lkf2__getProductListByInfo {
      public:
        /// Optional element 'arg0' of XML schema type 'lkf2:product'
        lkf2__product *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_lkf2__getProductListByInfo
        virtual long soap_type(void) const { return SOAP_TYPE_lkf2__getProductListByInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type lkf2__getProductListByInfo, default initialized and not managed by a soap context
        virtual lkf2__getProductListByInfo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(lkf2__getProductListByInfo); }
      public:
        /// Constructor with default initializations
        lkf2__getProductListByInfo() : arg0(), soap() { }
        virtual ~lkf2__getProductListByInfo() { }
        /// Friend allocator used by soap_new_lkf2__getProductListByInfo(struct soap*, int)
        friend SOAP_FMAC1 lkf2__getProductListByInfo * SOAP_FMAC2 soap_instantiate_lkf2__getProductListByInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:180 */
#ifndef SOAP_TYPE_lkf2__getProductListByInfoResponse
#define SOAP_TYPE_lkf2__getProductListByInfoResponse (19)
/* complex XML schema type 'lkf2:getProductListByInfoResponse': */
class SOAP_CMAC lkf2__getProductListByInfoResponse {
      public:
        /// Optional element 'return' of XML schema type 'lkf2:product'
        std::vector<lkf2__product *> return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_lkf2__getProductListByInfoResponse
        virtual long soap_type(void) const { return SOAP_TYPE_lkf2__getProductListByInfoResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type lkf2__getProductListByInfoResponse, default initialized and not managed by a soap context
        virtual lkf2__getProductListByInfoResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(lkf2__getProductListByInfoResponse); }
      public:
        /// Constructor with default initializations
        lkf2__getProductListByInfoResponse() : return_(), soap() { }
        virtual ~lkf2__getProductListByInfoResponse() { }
        /// Friend allocator used by soap_new_lkf2__getProductListByInfoResponse(struct soap*, int)
        friend SOAP_FMAC1 lkf2__getProductListByInfoResponse * SOAP_FMAC2 soap_instantiate_lkf2__getProductListByInfoResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:182 */
#ifndef SOAP_TYPE_lkf2__updateClient
#define SOAP_TYPE_lkf2__updateClient (20)
/* complex XML schema type 'lkf2:updateClient': */
class SOAP_CMAC lkf2__updateClient {
      public:
        /// Optional element 'arg0' of XML schema type 'lkf2:client'
        lkf2__client *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_lkf2__updateClient
        virtual long soap_type(void) const { return SOAP_TYPE_lkf2__updateClient; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type lkf2__updateClient, default initialized and not managed by a soap context
        virtual lkf2__updateClient *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(lkf2__updateClient); }
      public:
        /// Constructor with default initializations
        lkf2__updateClient() : arg0(), soap() { }
        virtual ~lkf2__updateClient() { }
        /// Friend allocator used by soap_new_lkf2__updateClient(struct soap*, int)
        friend SOAP_FMAC1 lkf2__updateClient * SOAP_FMAC2 soap_instantiate_lkf2__updateClient(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:184 */
#ifndef SOAP_TYPE_lkf2__client
#define SOAP_TYPE_lkf2__client (21)
/* complex XML schema type 'lkf2:client': */
class SOAP_CMAC lkf2__client {
      public:
        /// Required element 'clientBought' of XML schema type 'xsd:int'
        int clientBought;
        /// Optional element 'clientEmail' of XML schema type 'xsd:string'
        std::string *clientEmail;
        /// Required element 'clientId' of XML schema type 'xsd:int'
        int clientId;
        /// Optional element 'clientImage' of XML schema type 'xsd:string'
        std::string *clientImage;
        /// Optional element 'clientName' of XML schema type 'xsd:string'
        std::string *clientName;
        /// Optional element 'clientPhone' of XML schema type 'xsd:string'
        std::string *clientPhone;
        /// Optional element 'clientPwd' of XML schema type 'xsd:string'
        std::string *clientPwd;
        /// Optional element 'clientSignTime' of XML schema type 'xsd:dateTime'
        time_t *clientSignTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_lkf2__client
        virtual long soap_type(void) const { return SOAP_TYPE_lkf2__client; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type lkf2__client, default initialized and not managed by a soap context
        virtual lkf2__client *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(lkf2__client); }
      public:
        /// Constructor with default initializations
        lkf2__client() : clientBought(), clientEmail(), clientId(), clientImage(), clientName(), clientPhone(), clientPwd(), clientSignTime(), soap() { }
        lkf2__client(int bought,std::string *email,int id,std::string *image,std::string *name,std::string *phone,std::string *pwd,time_t *time) :
            clientBought(bought), clientEmail(email), clientId(id), clientImage(image), clientName(name), clientPhone(phone), clientPwd(pwd), clientSignTime(time), soap() { }
        virtual ~lkf2__client() { }
        /// Friend allocator used by soap_new_lkf2__client(struct soap*, int)
        friend SOAP_FMAC1 lkf2__client * SOAP_FMAC2 soap_instantiate_lkf2__client(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:186 */
#ifndef SOAP_TYPE_lkf2__updateClientResponse
#define SOAP_TYPE_lkf2__updateClientResponse (22)
/* complex XML schema type 'lkf2:updateClientResponse': */
class SOAP_CMAC lkf2__updateClientResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_lkf2__updateClientResponse
        virtual long soap_type(void) const { return SOAP_TYPE_lkf2__updateClientResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type lkf2__updateClientResponse, default initialized and not managed by a soap context
        virtual lkf2__updateClientResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(lkf2__updateClientResponse); }
      public:
        /// Constructor with default initializations
        lkf2__updateClientResponse() : soap() { }
        virtual ~lkf2__updateClientResponse() { }
        /// Friend allocator used by soap_new_lkf2__updateClientResponse(struct soap*, int)
        friend SOAP_FMAC1 lkf2__updateClientResponse * SOAP_FMAC2 soap_instantiate_lkf2__updateClientResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:188 */
#ifndef SOAP_TYPE_lkf2__deleteClientByNameAndPwd
#define SOAP_TYPE_lkf2__deleteClientByNameAndPwd (23)
/* complex XML schema type 'lkf2:deleteClientByNameAndPwd': */
class SOAP_CMAC lkf2__deleteClientByNameAndPwd {
      public:
        /// Optional element 'arg0' of XML schema type 'xsd:string'
        std::string *arg0;
        /// Optional element 'arg1' of XML schema type 'xsd:string'
        std::string *arg1;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_lkf2__deleteClientByNameAndPwd
        virtual long soap_type(void) const { return SOAP_TYPE_lkf2__deleteClientByNameAndPwd; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type lkf2__deleteClientByNameAndPwd, default initialized and not managed by a soap context
        virtual lkf2__deleteClientByNameAndPwd *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(lkf2__deleteClientByNameAndPwd); }
      public:
        /// Constructor with default initializations
        lkf2__deleteClientByNameAndPwd() : arg0(), arg1(), soap() { }
        virtual ~lkf2__deleteClientByNameAndPwd() { }
        /// Friend allocator used by soap_new_lkf2__deleteClientByNameAndPwd(struct soap*, int)
        friend SOAP_FMAC1 lkf2__deleteClientByNameAndPwd * SOAP_FMAC2 soap_instantiate_lkf2__deleteClientByNameAndPwd(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:190 */
#ifndef SOAP_TYPE_lkf2__deleteClientByNameAndPwdResponse
#define SOAP_TYPE_lkf2__deleteClientByNameAndPwdResponse (24)
/* complex XML schema type 'lkf2:deleteClientByNameAndPwdResponse': */
class SOAP_CMAC lkf2__deleteClientByNameAndPwdResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_lkf2__deleteClientByNameAndPwdResponse
        virtual long soap_type(void) const { return SOAP_TYPE_lkf2__deleteClientByNameAndPwdResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type lkf2__deleteClientByNameAndPwdResponse, default initialized and not managed by a soap context
        virtual lkf2__deleteClientByNameAndPwdResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(lkf2__deleteClientByNameAndPwdResponse); }
      public:
        /// Constructor with default initializations
        lkf2__deleteClientByNameAndPwdResponse() : soap() { }
        virtual ~lkf2__deleteClientByNameAndPwdResponse() { }
        /// Friend allocator used by soap_new_lkf2__deleteClientByNameAndPwdResponse(struct soap*, int)
        friend SOAP_FMAC1 lkf2__deleteClientByNameAndPwdResponse * SOAP_FMAC2 soap_instantiate_lkf2__deleteClientByNameAndPwdResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:192 */
#ifndef SOAP_TYPE_lkf2__deleteProductByInfo
#define SOAP_TYPE_lkf2__deleteProductByInfo (25)
/* complex XML schema type 'lkf2:deleteProductByInfo': */
class SOAP_CMAC lkf2__deleteProductByInfo {
      public:
        /// Optional element 'arg0' of XML schema type 'lkf2:product'
        lkf2__product *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_lkf2__deleteProductByInfo
        virtual long soap_type(void) const { return SOAP_TYPE_lkf2__deleteProductByInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type lkf2__deleteProductByInfo, default initialized and not managed by a soap context
        virtual lkf2__deleteProductByInfo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(lkf2__deleteProductByInfo); }
      public:
        /// Constructor with default initializations
        lkf2__deleteProductByInfo() : arg0(), soap() { }
        virtual ~lkf2__deleteProductByInfo() { }
        /// Friend allocator used by soap_new_lkf2__deleteProductByInfo(struct soap*, int)
        friend SOAP_FMAC1 lkf2__deleteProductByInfo * SOAP_FMAC2 soap_instantiate_lkf2__deleteProductByInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:194 */
#ifndef SOAP_TYPE_lkf2__deleteProductByInfoResponse
#define SOAP_TYPE_lkf2__deleteProductByInfoResponse (26)
/* complex XML schema type 'lkf2:deleteProductByInfoResponse': */
class SOAP_CMAC lkf2__deleteProductByInfoResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_lkf2__deleteProductByInfoResponse
        virtual long soap_type(void) const { return SOAP_TYPE_lkf2__deleteProductByInfoResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type lkf2__deleteProductByInfoResponse, default initialized and not managed by a soap context
        virtual lkf2__deleteProductByInfoResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(lkf2__deleteProductByInfoResponse); }
      public:
        /// Constructor with default initializations
        lkf2__deleteProductByInfoResponse() : soap() { }
        virtual ~lkf2__deleteProductByInfoResponse() { }
        /// Friend allocator used by soap_new_lkf2__deleteProductByInfoResponse(struct soap*, int)
        friend SOAP_FMAC1 lkf2__deleteProductByInfoResponse * SOAP_FMAC2 soap_instantiate_lkf2__deleteProductByInfoResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:196 */
#ifndef SOAP_TYPE_lkf2__getOrderLikeList
#define SOAP_TYPE_lkf2__getOrderLikeList (27)
/* complex XML schema type 'lkf2:getOrderLikeList': */
class SOAP_CMAC lkf2__getOrderLikeList {
      public:
        /// Optional element 'arg0' of XML schema type 'xsd:string'
        std::string *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_lkf2__getOrderLikeList
        virtual long soap_type(void) const { return SOAP_TYPE_lkf2__getOrderLikeList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type lkf2__getOrderLikeList, default initialized and not managed by a soap context
        virtual lkf2__getOrderLikeList *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(lkf2__getOrderLikeList); }
      public:
        /// Constructor with default initializations
        lkf2__getOrderLikeList() : arg0(), soap() { }
        virtual ~lkf2__getOrderLikeList() { }
        /// Friend allocator used by soap_new_lkf2__getOrderLikeList(struct soap*, int)
        friend SOAP_FMAC1 lkf2__getOrderLikeList * SOAP_FMAC2 soap_instantiate_lkf2__getOrderLikeList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:198 */
#ifndef SOAP_TYPE_lkf2__getOrderLikeListResponse
#define SOAP_TYPE_lkf2__getOrderLikeListResponse (28)
/* complex XML schema type 'lkf2:getOrderLikeListResponse': */
class SOAP_CMAC lkf2__getOrderLikeListResponse {
      public:
        /// Optional element 'return' of XML schema type 'lkf2:order'
        std::vector<lkf2__order *> return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_lkf2__getOrderLikeListResponse
        virtual long soap_type(void) const { return SOAP_TYPE_lkf2__getOrderLikeListResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type lkf2__getOrderLikeListResponse, default initialized and not managed by a soap context
        virtual lkf2__getOrderLikeListResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(lkf2__getOrderLikeListResponse); }
      public:
        /// Constructor with default initializations
        lkf2__getOrderLikeListResponse() : return_(), soap() { }
        virtual ~lkf2__getOrderLikeListResponse() { }
        /// Friend allocator used by soap_new_lkf2__getOrderLikeListResponse(struct soap*, int)
        friend SOAP_FMAC1 lkf2__getOrderLikeListResponse * SOAP_FMAC2 soap_instantiate_lkf2__getOrderLikeListResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:200 */
#ifndef SOAP_TYPE_lkf2__getClientLikeList
#define SOAP_TYPE_lkf2__getClientLikeList (29)
/* complex XML schema type 'lkf2:getClientLikeList': */
class SOAP_CMAC lkf2__getClientLikeList {
      public:
        /// Optional element 'arg0' of XML schema type 'xsd:string'
        std::string *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_lkf2__getClientLikeList
        virtual long soap_type(void) const { return SOAP_TYPE_lkf2__getClientLikeList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type lkf2__getClientLikeList, default initialized and not managed by a soap context
        virtual lkf2__getClientLikeList *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(lkf2__getClientLikeList); }
      public:
        /// Constructor with default initializations
        lkf2__getClientLikeList() : arg0(), soap() { }
        virtual ~lkf2__getClientLikeList() { }
        /// Friend allocator used by soap_new_lkf2__getClientLikeList(struct soap*, int)
        friend SOAP_FMAC1 lkf2__getClientLikeList * SOAP_FMAC2 soap_instantiate_lkf2__getClientLikeList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:202 */
#ifndef SOAP_TYPE_lkf2__getClientLikeListResponse
#define SOAP_TYPE_lkf2__getClientLikeListResponse (30)
/* complex XML schema type 'lkf2:getClientLikeListResponse': */
class SOAP_CMAC lkf2__getClientLikeListResponse {
      public:
        /// Optional element 'return' of XML schema type 'lkf2:client'
        std::vector<lkf2__client *> return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_lkf2__getClientLikeListResponse
        virtual long soap_type(void) const { return SOAP_TYPE_lkf2__getClientLikeListResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type lkf2__getClientLikeListResponse, default initialized and not managed by a soap context
        virtual lkf2__getClientLikeListResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(lkf2__getClientLikeListResponse); }
      public:
        /// Constructor with default initializations
        lkf2__getClientLikeListResponse() : return_(), soap() { }
        virtual ~lkf2__getClientLikeListResponse() { }
        /// Friend allocator used by soap_new_lkf2__getClientLikeListResponse(struct soap*, int)
        friend SOAP_FMAC1 lkf2__getClientLikeListResponse * SOAP_FMAC2 soap_instantiate_lkf2__getClientLikeListResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:204 */
#ifndef SOAP_TYPE_lkf2__getProductTypeByProName
#define SOAP_TYPE_lkf2__getProductTypeByProName (31)
/* complex XML schema type 'lkf2:getProductTypeByProName': */
class SOAP_CMAC lkf2__getProductTypeByProName {
      public:
        /// Optional element 'arg0' of XML schema type 'xsd:string'
        std::string *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_lkf2__getProductTypeByProName
        virtual long soap_type(void) const { return SOAP_TYPE_lkf2__getProductTypeByProName; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type lkf2__getProductTypeByProName, default initialized and not managed by a soap context
        virtual lkf2__getProductTypeByProName *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(lkf2__getProductTypeByProName); }
      public:
        /// Constructor with default initializations
        lkf2__getProductTypeByProName() : arg0(), soap() { }
        virtual ~lkf2__getProductTypeByProName() { }
        /// Friend allocator used by soap_new_lkf2__getProductTypeByProName(struct soap*, int)
        friend SOAP_FMAC1 lkf2__getProductTypeByProName * SOAP_FMAC2 soap_instantiate_lkf2__getProductTypeByProName(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:206 */
#ifndef SOAP_TYPE_lkf2__getProductTypeByProNameResponse
#define SOAP_TYPE_lkf2__getProductTypeByProNameResponse (32)
/* complex XML schema type 'lkf2:getProductTypeByProNameResponse': */
class SOAP_CMAC lkf2__getProductTypeByProNameResponse {
      public:
        /// Optional element 'return' of XML schema type 'lkf2:productType'
        std::vector<lkf2__productType *> return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_lkf2__getProductTypeByProNameResponse
        virtual long soap_type(void) const { return SOAP_TYPE_lkf2__getProductTypeByProNameResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type lkf2__getProductTypeByProNameResponse, default initialized and not managed by a soap context
        virtual lkf2__getProductTypeByProNameResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(lkf2__getProductTypeByProNameResponse); }
      public:
        /// Constructor with default initializations
        lkf2__getProductTypeByProNameResponse() : return_(), soap() { }
        virtual ~lkf2__getProductTypeByProNameResponse() { }
        /// Friend allocator used by soap_new_lkf2__getProductTypeByProNameResponse(struct soap*, int)
        friend SOAP_FMAC1 lkf2__getProductTypeByProNameResponse * SOAP_FMAC2 soap_instantiate_lkf2__getProductTypeByProNameResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:208 */
#ifndef SOAP_TYPE_lkf2__productType
#define SOAP_TYPE_lkf2__productType (33)
/* complex XML schema type 'lkf2:productType': */
class SOAP_CMAC lkf2__productType {
      public:
        /// Required element 'typeId' of XML schema type 'xsd:int'
        int typeId;
        /// Optional element 'typeName' of XML schema type 'xsd:string'
        std::string *typeName;
        /// Optional element 'typeProduct' of XML schema type 'xsd:string'
        std::string *typeProduct;
        /// Required element 'typeProductId' of XML schema type 'xsd:int'
        int typeProductId;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_lkf2__productType
        virtual long soap_type(void) const { return SOAP_TYPE_lkf2__productType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type lkf2__productType, default initialized and not managed by a soap context
        virtual lkf2__productType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(lkf2__productType); }
      public:
        /// Constructor with default initializations
        lkf2__productType() : typeId(), typeName(), typeProduct(), typeProductId(), soap() { }
        lkf2__productType(int id,std::string* tName,std::string*tProduct,int tId)
            : typeId(id), typeName(tName), typeProduct(tProduct), typeProductId(tId), soap() { }
        virtual ~lkf2__productType() { }
        /// Friend allocator used by soap_new_lkf2__productType(struct soap*, int)
        friend SOAP_FMAC1 lkf2__productType * SOAP_FMAC2 soap_instantiate_lkf2__productType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:210 */
#ifndef SOAP_TYPE_lkf2__getClientList
#define SOAP_TYPE_lkf2__getClientList (34)
/* complex XML schema type 'lkf2:getClientList': */
class SOAP_CMAC lkf2__getClientList {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_lkf2__getClientList
        virtual long soap_type(void) const { return SOAP_TYPE_lkf2__getClientList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type lkf2__getClientList, default initialized and not managed by a soap context
        virtual lkf2__getClientList *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(lkf2__getClientList); }
      public:
        /// Constructor with default initializations
        lkf2__getClientList() : soap() { }
        virtual ~lkf2__getClientList() { }
        /// Friend allocator used by soap_new_lkf2__getClientList(struct soap*, int)
        friend SOAP_FMAC1 lkf2__getClientList * SOAP_FMAC2 soap_instantiate_lkf2__getClientList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:212 */
#ifndef SOAP_TYPE_lkf2__getClientListResponse
#define SOAP_TYPE_lkf2__getClientListResponse (35)
/* complex XML schema type 'lkf2:getClientListResponse': */
class SOAP_CMAC lkf2__getClientListResponse {
      public:
        /// Optional element 'return' of XML schema type 'lkf2:client'
        std::vector<lkf2__client *> return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_lkf2__getClientListResponse
        virtual long soap_type(void) const { return SOAP_TYPE_lkf2__getClientListResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type lkf2__getClientListResponse, default initialized and not managed by a soap context
        virtual lkf2__getClientListResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(lkf2__getClientListResponse); }
      public:
        /// Constructor with default initializations
        lkf2__getClientListResponse() : return_(), soap() { }
        virtual ~lkf2__getClientListResponse() { }
        /// Friend allocator used by soap_new_lkf2__getClientListResponse(struct soap*, int)
        friend SOAP_FMAC1 lkf2__getClientListResponse * SOAP_FMAC2 soap_instantiate_lkf2__getClientListResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:214 */
#ifndef SOAP_TYPE_lkf2__getOrderListByInfo
#define SOAP_TYPE_lkf2__getOrderListByInfo (36)
/* complex XML schema type 'lkf2:getOrderListByInfo': */
class SOAP_CMAC lkf2__getOrderListByInfo {
      public:
        /// Optional element 'arg0' of XML schema type 'lkf2:order'
        lkf2__order *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_lkf2__getOrderListByInfo
        virtual long soap_type(void) const { return SOAP_TYPE_lkf2__getOrderListByInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type lkf2__getOrderListByInfo, default initialized and not managed by a soap context
        virtual lkf2__getOrderListByInfo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(lkf2__getOrderListByInfo); }
      public:
        /// Constructor with default initializations
        lkf2__getOrderListByInfo() : arg0(), soap() { }
        virtual ~lkf2__getOrderListByInfo() { }
        /// Friend allocator used by soap_new_lkf2__getOrderListByInfo(struct soap*, int)
        friend SOAP_FMAC1 lkf2__getOrderListByInfo * SOAP_FMAC2 soap_instantiate_lkf2__getOrderListByInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:216 */
#ifndef SOAP_TYPE_lkf2__getOrderListByInfoResponse
#define SOAP_TYPE_lkf2__getOrderListByInfoResponse (37)
/* complex XML schema type 'lkf2:getOrderListByInfoResponse': */
class SOAP_CMAC lkf2__getOrderListByInfoResponse {
      public:
        /// Optional element 'return' of XML schema type 'lkf2:order'
        std::vector<lkf2__order *> return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_lkf2__getOrderListByInfoResponse
        virtual long soap_type(void) const { return SOAP_TYPE_lkf2__getOrderListByInfoResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type lkf2__getOrderListByInfoResponse, default initialized and not managed by a soap context
        virtual lkf2__getOrderListByInfoResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(lkf2__getOrderListByInfoResponse); }
      public:
        /// Constructor with default initializations
        lkf2__getOrderListByInfoResponse() : return_(), soap() { }
        virtual ~lkf2__getOrderListByInfoResponse() { }
        /// Friend allocator used by soap_new_lkf2__getOrderListByInfoResponse(struct soap*, int)
        friend SOAP_FMAC1 lkf2__getOrderListByInfoResponse * SOAP_FMAC2 soap_instantiate_lkf2__getOrderListByInfoResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:218 */
#ifndef SOAP_TYPE_lkf2__addProductType
#define SOAP_TYPE_lkf2__addProductType (38)
/* complex XML schema type 'lkf2:addProductType': */
class SOAP_CMAC lkf2__addProductType {
      public:
        /// Optional element 'arg0' of XML schema type 'lkf2:productType'
        lkf2__productType *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_lkf2__addProductType
        virtual long soap_type(void) const { return SOAP_TYPE_lkf2__addProductType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type lkf2__addProductType, default initialized and not managed by a soap context
        virtual lkf2__addProductType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(lkf2__addProductType); }
      public:
        /// Constructor with default initializations
        lkf2__addProductType() : arg0(), soap() { }
        virtual ~lkf2__addProductType() { }
        /// Friend allocator used by soap_new_lkf2__addProductType(struct soap*, int)
        friend SOAP_FMAC1 lkf2__addProductType * SOAP_FMAC2 soap_instantiate_lkf2__addProductType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:220 */
#ifndef SOAP_TYPE_lkf2__addProductTypeResponse
#define SOAP_TYPE_lkf2__addProductTypeResponse (39)
/* complex XML schema type 'lkf2:addProductTypeResponse': */
class SOAP_CMAC lkf2__addProductTypeResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_lkf2__addProductTypeResponse
        virtual long soap_type(void) const { return SOAP_TYPE_lkf2__addProductTypeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type lkf2__addProductTypeResponse, default initialized and not managed by a soap context
        virtual lkf2__addProductTypeResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(lkf2__addProductTypeResponse); }
      public:
        /// Constructor with default initializations
        lkf2__addProductTypeResponse() : soap() { }
        virtual ~lkf2__addProductTypeResponse() { }
        /// Friend allocator used by soap_new_lkf2__addProductTypeResponse(struct soap*, int)
        friend SOAP_FMAC1 lkf2__addProductTypeResponse * SOAP_FMAC2 soap_instantiate_lkf2__addProductTypeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:222 */
#ifndef SOAP_TYPE_lkf2__updateProductByInfo
#define SOAP_TYPE_lkf2__updateProductByInfo (40)
/* complex XML schema type 'lkf2:updateProductByInfo': */
class SOAP_CMAC lkf2__updateProductByInfo {
      public:
        /// Optional element 'arg0' of XML schema type 'lkf2:product'
        lkf2__product *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_lkf2__updateProductByInfo
        virtual long soap_type(void) const { return SOAP_TYPE_lkf2__updateProductByInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type lkf2__updateProductByInfo, default initialized and not managed by a soap context
        virtual lkf2__updateProductByInfo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(lkf2__updateProductByInfo); }
      public:
        /// Constructor with default initializations
        lkf2__updateProductByInfo() : arg0(), soap() { }
        virtual ~lkf2__updateProductByInfo() { }
        /// Friend allocator used by soap_new_lkf2__updateProductByInfo(struct soap*, int)
        friend SOAP_FMAC1 lkf2__updateProductByInfo * SOAP_FMAC2 soap_instantiate_lkf2__updateProductByInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:224 */
#ifndef SOAP_TYPE_lkf2__updateProductByInfoResponse
#define SOAP_TYPE_lkf2__updateProductByInfoResponse (41)
/* complex XML schema type 'lkf2:updateProductByInfoResponse': */
class SOAP_CMAC lkf2__updateProductByInfoResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_lkf2__updateProductByInfoResponse
        virtual long soap_type(void) const { return SOAP_TYPE_lkf2__updateProductByInfoResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type lkf2__updateProductByInfoResponse, default initialized and not managed by a soap context
        virtual lkf2__updateProductByInfoResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(lkf2__updateProductByInfoResponse); }
      public:
        /// Constructor with default initializations
        lkf2__updateProductByInfoResponse() : soap() { }
        virtual ~lkf2__updateProductByInfoResponse() { }
        /// Friend allocator used by soap_new_lkf2__updateProductByInfoResponse(struct soap*, int)
        friend SOAP_FMAC1 lkf2__updateProductByInfoResponse * SOAP_FMAC2 soap_instantiate_lkf2__updateProductByInfoResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:226 */
#ifndef SOAP_TYPE_lkf2__getProductLikeList
#define SOAP_TYPE_lkf2__getProductLikeList (42)
/* complex XML schema type 'lkf2:getProductLikeList': */
class SOAP_CMAC lkf2__getProductLikeList {
      public:
        /// Optional element 'arg0' of XML schema type 'xsd:string'
        std::string *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_lkf2__getProductLikeList
        virtual long soap_type(void) const { return SOAP_TYPE_lkf2__getProductLikeList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type lkf2__getProductLikeList, default initialized and not managed by a soap context
        virtual lkf2__getProductLikeList *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(lkf2__getProductLikeList); }
      public:
        /// Constructor with default initializations
        lkf2__getProductLikeList() : arg0(), soap() { }
        virtual ~lkf2__getProductLikeList() { }
        /// Friend allocator used by soap_new_lkf2__getProductLikeList(struct soap*, int)
        friend SOAP_FMAC1 lkf2__getProductLikeList * SOAP_FMAC2 soap_instantiate_lkf2__getProductLikeList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:228 */
#ifndef SOAP_TYPE_lkf2__getProductLikeListResponse
#define SOAP_TYPE_lkf2__getProductLikeListResponse (43)
/* complex XML schema type 'lkf2:getProductLikeListResponse': */
class SOAP_CMAC lkf2__getProductLikeListResponse {
      public:
        /// Optional element 'return' of XML schema type 'lkf2:product'
        std::vector<lkf2__product *> return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_lkf2__getProductLikeListResponse
        virtual long soap_type(void) const { return SOAP_TYPE_lkf2__getProductLikeListResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type lkf2__getProductLikeListResponse, default initialized and not managed by a soap context
        virtual lkf2__getProductLikeListResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(lkf2__getProductLikeListResponse); }
      public:
        /// Constructor with default initializations
        lkf2__getProductLikeListResponse() : return_(), soap() { }
        virtual ~lkf2__getProductLikeListResponse() { }
        /// Friend allocator used by soap_new_lkf2__getProductLikeListResponse(struct soap*, int)
        friend SOAP_FMAC1 lkf2__getProductLikeListResponse * SOAP_FMAC2 soap_instantiate_lkf2__getProductLikeListResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:230 */
#ifndef SOAP_TYPE_lkf2__addOrder
#define SOAP_TYPE_lkf2__addOrder (44)
/* complex XML schema type 'lkf2:addOrder': */
class SOAP_CMAC lkf2__addOrder {
      public:
        /// Optional element 'arg0' of XML schema type 'lkf2:order'
        lkf2__order *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_lkf2__addOrder
        virtual long soap_type(void) const { return SOAP_TYPE_lkf2__addOrder; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type lkf2__addOrder, default initialized and not managed by a soap context
        virtual lkf2__addOrder *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(lkf2__addOrder); }
      public:
        /// Constructor with default initializations
        lkf2__addOrder() : arg0(), soap() { }
        virtual ~lkf2__addOrder() { }
        /// Friend allocator used by soap_new_lkf2__addOrder(struct soap*, int)
        friend SOAP_FMAC1 lkf2__addOrder * SOAP_FMAC2 soap_instantiate_lkf2__addOrder(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:232 */
#ifndef SOAP_TYPE_lkf2__addOrderResponse
#define SOAP_TYPE_lkf2__addOrderResponse (45)
/* complex XML schema type 'lkf2:addOrderResponse': */
class SOAP_CMAC lkf2__addOrderResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_lkf2__addOrderResponse
        virtual long soap_type(void) const { return SOAP_TYPE_lkf2__addOrderResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type lkf2__addOrderResponse, default initialized and not managed by a soap context
        virtual lkf2__addOrderResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(lkf2__addOrderResponse); }
      public:
        /// Constructor with default initializations
        lkf2__addOrderResponse() : soap() { }
        virtual ~lkf2__addOrderResponse() { }
        /// Friend allocator used by soap_new_lkf2__addOrderResponse(struct soap*, int)
        friend SOAP_FMAC1 lkf2__addOrderResponse * SOAP_FMAC2 soap_instantiate_lkf2__addOrderResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:234 */
#ifndef SOAP_TYPE_lkf2__getClientByNameAndPwd
#define SOAP_TYPE_lkf2__getClientByNameAndPwd (46)
/* complex XML schema type 'lkf2:getClientByNameAndPwd': */
class SOAP_CMAC lkf2__getClientByNameAndPwd {
      public:
        /// Optional element 'arg0' of XML schema type 'xsd:string'
        std::string *arg0;
        /// Optional element 'arg1' of XML schema type 'xsd:string'
        std::string *arg1;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_lkf2__getClientByNameAndPwd
        virtual long soap_type(void) const { return SOAP_TYPE_lkf2__getClientByNameAndPwd; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type lkf2__getClientByNameAndPwd, default initialized and not managed by a soap context
        virtual lkf2__getClientByNameAndPwd *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(lkf2__getClientByNameAndPwd); }
      public:
        /// Constructor with default initializations
        lkf2__getClientByNameAndPwd() : arg0(), arg1(), soap() { }
        virtual ~lkf2__getClientByNameAndPwd() { }
        /// Friend allocator used by soap_new_lkf2__getClientByNameAndPwd(struct soap*, int)
        friend SOAP_FMAC1 lkf2__getClientByNameAndPwd * SOAP_FMAC2 soap_instantiate_lkf2__getClientByNameAndPwd(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:236 */
#ifndef SOAP_TYPE_lkf2__getClientByNameAndPwdResponse
#define SOAP_TYPE_lkf2__getClientByNameAndPwdResponse (47)
/* complex XML schema type 'lkf2:getClientByNameAndPwdResponse': */
class SOAP_CMAC lkf2__getClientByNameAndPwdResponse {
      public:
        /// Optional element 'return' of XML schema type 'lkf2:client'
        lkf2__client *return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_lkf2__getClientByNameAndPwdResponse
        virtual long soap_type(void) const { return SOAP_TYPE_lkf2__getClientByNameAndPwdResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type lkf2__getClientByNameAndPwdResponse, default initialized and not managed by a soap context
        virtual lkf2__getClientByNameAndPwdResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(lkf2__getClientByNameAndPwdResponse); }
      public:
        /// Constructor with default initializations
        lkf2__getClientByNameAndPwdResponse() : return_(), soap() { }
        virtual ~lkf2__getClientByNameAndPwdResponse() { }
        /// Friend allocator used by soap_new_lkf2__getClientByNameAndPwdResponse(struct soap*, int)
        friend SOAP_FMAC1 lkf2__getClientByNameAndPwdResponse * SOAP_FMAC2 soap_instantiate_lkf2__getClientByNameAndPwdResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:238 */
#ifndef SOAP_TYPE_lkf2__deleteShoppingCart
#define SOAP_TYPE_lkf2__deleteShoppingCart (48)
/* complex XML schema type 'lkf2:deleteShoppingCart': */
class SOAP_CMAC lkf2__deleteShoppingCart {
      public:
        /// Optional element 'arg0' of XML schema type 'lkf2:order'
        lkf2__order *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_lkf2__deleteShoppingCart
        virtual long soap_type(void) const { return SOAP_TYPE_lkf2__deleteShoppingCart; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type lkf2__deleteShoppingCart, default initialized and not managed by a soap context
        virtual lkf2__deleteShoppingCart *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(lkf2__deleteShoppingCart); }
      public:
        /// Constructor with default initializations
        lkf2__deleteShoppingCart() : arg0(), soap() { }
        virtual ~lkf2__deleteShoppingCart() { }
        /// Friend allocator used by soap_new_lkf2__deleteShoppingCart(struct soap*, int)
        friend SOAP_FMAC1 lkf2__deleteShoppingCart * SOAP_FMAC2 soap_instantiate_lkf2__deleteShoppingCart(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:240 */
#ifndef SOAP_TYPE_lkf2__deleteShoppingCartResponse
#define SOAP_TYPE_lkf2__deleteShoppingCartResponse (49)
/* complex XML schema type 'lkf2:deleteShoppingCartResponse': */
class SOAP_CMAC lkf2__deleteShoppingCartResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_lkf2__deleteShoppingCartResponse
        virtual long soap_type(void) const { return SOAP_TYPE_lkf2__deleteShoppingCartResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type lkf2__deleteShoppingCartResponse, default initialized and not managed by a soap context
        virtual lkf2__deleteShoppingCartResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(lkf2__deleteShoppingCartResponse); }
      public:
        /// Constructor with default initializations
        lkf2__deleteShoppingCartResponse() : soap() { }
        virtual ~lkf2__deleteShoppingCartResponse() { }
        /// Friend allocator used by soap_new_lkf2__deleteShoppingCartResponse(struct soap*, int)
        friend SOAP_FMAC1 lkf2__deleteShoppingCartResponse * SOAP_FMAC2 soap_instantiate_lkf2__deleteShoppingCartResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:242 */
#ifndef SOAP_TYPE_lkf2__getProductList
#define SOAP_TYPE_lkf2__getProductList (50)
/* complex XML schema type 'lkf2:getProductList': */
class SOAP_CMAC lkf2__getProductList {
      public:
        /// Required element 'arg0' of XML schema type 'xsd:int'
        int arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_lkf2__getProductList
        virtual long soap_type(void) const { return SOAP_TYPE_lkf2__getProductList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type lkf2__getProductList, default initialized and not managed by a soap context
        virtual lkf2__getProductList *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(lkf2__getProductList); }
      public:
        /// Constructor with default initializations
        lkf2__getProductList() : arg0(), soap() { }
        virtual ~lkf2__getProductList() { }
        /// Friend allocator used by soap_new_lkf2__getProductList(struct soap*, int)
        friend SOAP_FMAC1 lkf2__getProductList * SOAP_FMAC2 soap_instantiate_lkf2__getProductList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:244 */
#ifndef SOAP_TYPE_lkf2__getProductListResponse
#define SOAP_TYPE_lkf2__getProductListResponse (51)
/* complex XML schema type 'lkf2:getProductListResponse': */
class SOAP_CMAC lkf2__getProductListResponse {
      public:
        /// Optional element 'return' of XML schema type 'lkf2:product'
        std::vector<lkf2__product *> return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_lkf2__getProductListResponse
        virtual long soap_type(void) const { return SOAP_TYPE_lkf2__getProductListResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type lkf2__getProductListResponse, default initialized and not managed by a soap context
        virtual lkf2__getProductListResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(lkf2__getProductListResponse); }
      public:
        /// Constructor with default initializations
        lkf2__getProductListResponse() : return_(), soap() { }
        virtual ~lkf2__getProductListResponse() { }
        /// Friend allocator used by soap_new_lkf2__getProductListResponse(struct soap*, int)
        friend SOAP_FMAC1 lkf2__getProductListResponse * SOAP_FMAC2 soap_instantiate_lkf2__getProductListResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:246 */
#ifndef SOAP_TYPE_lkf2__InsertClient
#define SOAP_TYPE_lkf2__InsertClient (52)
/* complex XML schema type 'lkf2:InsertClient': */
class SOAP_CMAC lkf2__InsertClient {
      public:
        /// Optional element 'arg0' of XML schema type 'lkf2:client'
        lkf2__client *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_lkf2__InsertClient
        virtual long soap_type(void) const { return SOAP_TYPE_lkf2__InsertClient; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type lkf2__InsertClient, default initialized and not managed by a soap context
        virtual lkf2__InsertClient *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(lkf2__InsertClient); }
      public:
        /// Constructor with default initializations
        lkf2__InsertClient() : arg0(), soap() { }
        virtual ~lkf2__InsertClient() { }
        /// Friend allocator used by soap_new_lkf2__InsertClient(struct soap*, int)
        friend SOAP_FMAC1 lkf2__InsertClient * SOAP_FMAC2 soap_instantiate_lkf2__InsertClient(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:248 */
#ifndef SOAP_TYPE_lkf2__InsertClientResponse
#define SOAP_TYPE_lkf2__InsertClientResponse (53)
/* complex XML schema type 'lkf2:InsertClientResponse': */
class SOAP_CMAC lkf2__InsertClientResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_lkf2__InsertClientResponse
        virtual long soap_type(void) const { return SOAP_TYPE_lkf2__InsertClientResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type lkf2__InsertClientResponse, default initialized and not managed by a soap context
        virtual lkf2__InsertClientResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(lkf2__InsertClientResponse); }
      public:
        /// Constructor with default initializations
        lkf2__InsertClientResponse() : soap() { }
        virtual ~lkf2__InsertClientResponse() { }
        /// Friend allocator used by soap_new_lkf2__InsertClientResponse(struct soap*, int)
        friend SOAP_FMAC1 lkf2__InsertClientResponse * SOAP_FMAC2 soap_instantiate_lkf2__InsertClientResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:250 */
#ifndef SOAP_TYPE_lkf2__getOrderListHistory
#define SOAP_TYPE_lkf2__getOrderListHistory (54)
/* complex XML schema type 'lkf2:getOrderListHistory': */
class SOAP_CMAC lkf2__getOrderListHistory {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_lkf2__getOrderListHistory
        virtual long soap_type(void) const { return SOAP_TYPE_lkf2__getOrderListHistory; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type lkf2__getOrderListHistory, default initialized and not managed by a soap context
        virtual lkf2__getOrderListHistory *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(lkf2__getOrderListHistory); }
      public:
        /// Constructor with default initializations
        lkf2__getOrderListHistory() : soap() { }
        virtual ~lkf2__getOrderListHistory() { }
        /// Friend allocator used by soap_new_lkf2__getOrderListHistory(struct soap*, int)
        friend SOAP_FMAC1 lkf2__getOrderListHistory * SOAP_FMAC2 soap_instantiate_lkf2__getOrderListHistory(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:252 */
#ifndef SOAP_TYPE_lkf2__getOrderListHistoryResponse
#define SOAP_TYPE_lkf2__getOrderListHistoryResponse (55)
/* complex XML schema type 'lkf2:getOrderListHistoryResponse': */
class SOAP_CMAC lkf2__getOrderListHistoryResponse {
      public:
        /// Optional element 'return' of XML schema type 'lkf2:order'
        std::vector<lkf2__order *> return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_lkf2__getOrderListHistoryResponse
        virtual long soap_type(void) const { return SOAP_TYPE_lkf2__getOrderListHistoryResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type lkf2__getOrderListHistoryResponse, default initialized and not managed by a soap context
        virtual lkf2__getOrderListHistoryResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(lkf2__getOrderListHistoryResponse); }
      public:
        /// Constructor with default initializations
        lkf2__getOrderListHistoryResponse() : return_(), soap() { }
        virtual ~lkf2__getOrderListHistoryResponse() { }
        /// Friend allocator used by soap_new_lkf2__getOrderListHistoryResponse(struct soap*, int)
        friend SOAP_FMAC1 lkf2__getOrderListHistoryResponse * SOAP_FMAC2 soap_instantiate_lkf2__getOrderListHistoryResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:254 */
#ifndef SOAP_TYPE_lkf2__updateHistory
#define SOAP_TYPE_lkf2__updateHistory (56)
/* complex XML schema type 'lkf2:updateHistory': */
class SOAP_CMAC lkf2__updateHistory {
      public:
        /// Optional element 'arg0' of XML schema type 'lkf2:order'
        lkf2__order *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_lkf2__updateHistory
        virtual long soap_type(void) const { return SOAP_TYPE_lkf2__updateHistory; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type lkf2__updateHistory, default initialized and not managed by a soap context
        virtual lkf2__updateHistory *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(lkf2__updateHistory); }
      public:
        /// Constructor with default initializations
        lkf2__updateHistory() : arg0(), soap() { }
        virtual ~lkf2__updateHistory() { }
        /// Friend allocator used by soap_new_lkf2__updateHistory(struct soap*, int)
        friend SOAP_FMAC1 lkf2__updateHistory * SOAP_FMAC2 soap_instantiate_lkf2__updateHistory(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:256 */
#ifndef SOAP_TYPE_lkf2__updateHistoryResponse
#define SOAP_TYPE_lkf2__updateHistoryResponse (57)
/* complex XML schema type 'lkf2:updateHistoryResponse': */
class SOAP_CMAC lkf2__updateHistoryResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_lkf2__updateHistoryResponse
        virtual long soap_type(void) const { return SOAP_TYPE_lkf2__updateHistoryResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type lkf2__updateHistoryResponse, default initialized and not managed by a soap context
        virtual lkf2__updateHistoryResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(lkf2__updateHistoryResponse); }
      public:
        /// Constructor with default initializations
        lkf2__updateHistoryResponse() : soap() { }
        virtual ~lkf2__updateHistoryResponse() { }
        /// Friend allocator used by soap_new_lkf2__updateHistoryResponse(struct soap*, int)
        friend SOAP_FMAC1 lkf2__updateHistoryResponse * SOAP_FMAC2 soap_instantiate_lkf2__updateHistoryResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:1621 */
#ifndef SOAP_TYPE___lkf1__addProduct
#define SOAP_TYPE___lkf1__addProduct (75)
/* Wrapper: */
struct SOAP_CMAC __lkf1__addProduct {
      public:
        /** Optional element 'lkf2:addProduct' of XML schema type 'lkf2:addProduct' */
        lkf2__addProduct *lkf2__addProduct_;
      public:
        /** Return unique type id SOAP_TYPE___lkf1__addProduct */
        long soap_type() const { return SOAP_TYPE___lkf1__addProduct; }
        /** Constructor with member initializations */
        __lkf1__addProduct() : lkf2__addProduct_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __lkf1__addProduct * SOAP_FMAC2 soap_instantiate___lkf1__addProduct(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:1688 */
#ifndef SOAP_TYPE___lkf1__deleteProductTypeByName
#define SOAP_TYPE___lkf1__deleteProductTypeByName (79)
/* Wrapper: */
struct SOAP_CMAC __lkf1__deleteProductTypeByName {
      public:
        /** Optional element 'lkf2:deleteProductTypeByName' of XML schema type 'lkf2:deleteProductTypeByName' */
        lkf2__deleteProductTypeByName *lkf2__deleteProductTypeByName_;
      public:
        /** Return unique type id SOAP_TYPE___lkf1__deleteProductTypeByName */
        long soap_type() const { return SOAP_TYPE___lkf1__deleteProductTypeByName; }
        /** Constructor with member initializations */
        __lkf1__deleteProductTypeByName() : lkf2__deleteProductTypeByName_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __lkf1__deleteProductTypeByName * SOAP_FMAC2 soap_instantiate___lkf1__deleteProductTypeByName(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:1755 */
#ifndef SOAP_TYPE___lkf1__getOrderList
#define SOAP_TYPE___lkf1__getOrderList (83)
/* Wrapper: */
struct SOAP_CMAC __lkf1__getOrderList {
      public:
        /** Optional element 'lkf2:getOrderList' of XML schema type 'lkf2:getOrderList' */
        lkf2__getOrderList *lkf2__getOrderList_;
      public:
        /** Return unique type id SOAP_TYPE___lkf1__getOrderList */
        long soap_type() const { return SOAP_TYPE___lkf1__getOrderList; }
        /** Constructor with member initializations */
        __lkf1__getOrderList() : lkf2__getOrderList_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __lkf1__getOrderList * SOAP_FMAC2 soap_instantiate___lkf1__getOrderList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:1822 */
#ifndef SOAP_TYPE___lkf1__getProductListByInfo
#define SOAP_TYPE___lkf1__getProductListByInfo (87)
/* Wrapper: */
struct SOAP_CMAC __lkf1__getProductListByInfo {
      public:
        /** Optional element 'lkf2:getProductListByInfo' of XML schema type 'lkf2:getProductListByInfo' */
        lkf2__getProductListByInfo *lkf2__getProductListByInfo_;
      public:
        /** Return unique type id SOAP_TYPE___lkf1__getProductListByInfo */
        long soap_type() const { return SOAP_TYPE___lkf1__getProductListByInfo; }
        /** Constructor with member initializations */
        __lkf1__getProductListByInfo() : lkf2__getProductListByInfo_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __lkf1__getProductListByInfo * SOAP_FMAC2 soap_instantiate___lkf1__getProductListByInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:1889 */
#ifndef SOAP_TYPE___lkf1__updateClient
#define SOAP_TYPE___lkf1__updateClient (91)
/* Wrapper: */
struct SOAP_CMAC __lkf1__updateClient {
      public:
        /** Optional element 'lkf2:updateClient' of XML schema type 'lkf2:updateClient' */
        lkf2__updateClient *lkf2__updateClient_;
      public:
        /** Return unique type id SOAP_TYPE___lkf1__updateClient */
        long soap_type() const { return SOAP_TYPE___lkf1__updateClient; }
        /** Constructor with member initializations */
        __lkf1__updateClient() : lkf2__updateClient_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __lkf1__updateClient * SOAP_FMAC2 soap_instantiate___lkf1__updateClient(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:1956 */
#ifndef SOAP_TYPE___lkf1__deleteClientByNameAndPwd
#define SOAP_TYPE___lkf1__deleteClientByNameAndPwd (95)
/* Wrapper: */
struct SOAP_CMAC __lkf1__deleteClientByNameAndPwd {
      public:
        /** Optional element 'lkf2:deleteClientByNameAndPwd' of XML schema type 'lkf2:deleteClientByNameAndPwd' */
        lkf2__deleteClientByNameAndPwd *lkf2__deleteClientByNameAndPwd_;
      public:
        /** Return unique type id SOAP_TYPE___lkf1__deleteClientByNameAndPwd */
        long soap_type() const { return SOAP_TYPE___lkf1__deleteClientByNameAndPwd; }
        /** Constructor with member initializations */
        __lkf1__deleteClientByNameAndPwd() : lkf2__deleteClientByNameAndPwd_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __lkf1__deleteClientByNameAndPwd * SOAP_FMAC2 soap_instantiate___lkf1__deleteClientByNameAndPwd(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:2023 */
#ifndef SOAP_TYPE___lkf1__deleteProductByInfo
#define SOAP_TYPE___lkf1__deleteProductByInfo (99)
/* Wrapper: */
struct SOAP_CMAC __lkf1__deleteProductByInfo {
      public:
        /** Optional element 'lkf2:deleteProductByInfo' of XML schema type 'lkf2:deleteProductByInfo' */
        lkf2__deleteProductByInfo *lkf2__deleteProductByInfo_;
      public:
        /** Return unique type id SOAP_TYPE___lkf1__deleteProductByInfo */
        long soap_type() const { return SOAP_TYPE___lkf1__deleteProductByInfo; }
        /** Constructor with member initializations */
        __lkf1__deleteProductByInfo() : lkf2__deleteProductByInfo_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __lkf1__deleteProductByInfo * SOAP_FMAC2 soap_instantiate___lkf1__deleteProductByInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:2090 */
#ifndef SOAP_TYPE___lkf1__getOrderLikeList
#define SOAP_TYPE___lkf1__getOrderLikeList (103)
/* Wrapper: */
struct SOAP_CMAC __lkf1__getOrderLikeList {
      public:
        /** Optional element 'lkf2:getOrderLikeList' of XML schema type 'lkf2:getOrderLikeList' */
        lkf2__getOrderLikeList *lkf2__getOrderLikeList_;
      public:
        /** Return unique type id SOAP_TYPE___lkf1__getOrderLikeList */
        long soap_type() const { return SOAP_TYPE___lkf1__getOrderLikeList; }
        /** Constructor with member initializations */
        __lkf1__getOrderLikeList() : lkf2__getOrderLikeList_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __lkf1__getOrderLikeList * SOAP_FMAC2 soap_instantiate___lkf1__getOrderLikeList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:2157 */
#ifndef SOAP_TYPE___lkf1__getClientLikeList
#define SOAP_TYPE___lkf1__getClientLikeList (107)
/* Wrapper: */
struct SOAP_CMAC __lkf1__getClientLikeList {
      public:
        /** Optional element 'lkf2:getClientLikeList' of XML schema type 'lkf2:getClientLikeList' */
        lkf2__getClientLikeList *lkf2__getClientLikeList_;
      public:
        /** Return unique type id SOAP_TYPE___lkf1__getClientLikeList */
        long soap_type() const { return SOAP_TYPE___lkf1__getClientLikeList; }
        /** Constructor with member initializations */
        __lkf1__getClientLikeList() : lkf2__getClientLikeList_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __lkf1__getClientLikeList * SOAP_FMAC2 soap_instantiate___lkf1__getClientLikeList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:2224 */
#ifndef SOAP_TYPE___lkf1__getProductTypeByProName
#define SOAP_TYPE___lkf1__getProductTypeByProName (111)
/* Wrapper: */
struct SOAP_CMAC __lkf1__getProductTypeByProName {
      public:
        /** Optional element 'lkf2:getProductTypeByProName' of XML schema type 'lkf2:getProductTypeByProName' */
        lkf2__getProductTypeByProName *lkf2__getProductTypeByProName_;
      public:
        /** Return unique type id SOAP_TYPE___lkf1__getProductTypeByProName */
        long soap_type() const { return SOAP_TYPE___lkf1__getProductTypeByProName; }
        /** Constructor with member initializations */
        __lkf1__getProductTypeByProName() : lkf2__getProductTypeByProName_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __lkf1__getProductTypeByProName * SOAP_FMAC2 soap_instantiate___lkf1__getProductTypeByProName(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:2291 */
#ifndef SOAP_TYPE___lkf1__getClientList
#define SOAP_TYPE___lkf1__getClientList (115)
/* Wrapper: */
struct SOAP_CMAC __lkf1__getClientList {
      public:
        /** Optional element 'lkf2:getClientList' of XML schema type 'lkf2:getClientList' */
        lkf2__getClientList *lkf2__getClientList_;
      public:
        /** Return unique type id SOAP_TYPE___lkf1__getClientList */
        long soap_type() const { return SOAP_TYPE___lkf1__getClientList; }
        /** Constructor with member initializations */
        __lkf1__getClientList() : lkf2__getClientList_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __lkf1__getClientList * SOAP_FMAC2 soap_instantiate___lkf1__getClientList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:2358 */
#ifndef SOAP_TYPE___lkf1__getOrderListByInfo
#define SOAP_TYPE___lkf1__getOrderListByInfo (119)
/* Wrapper: */
struct SOAP_CMAC __lkf1__getOrderListByInfo {
      public:
        /** Optional element 'lkf2:getOrderListByInfo' of XML schema type 'lkf2:getOrderListByInfo' */
        lkf2__getOrderListByInfo *lkf2__getOrderListByInfo_;
      public:
        /** Return unique type id SOAP_TYPE___lkf1__getOrderListByInfo */
        long soap_type() const { return SOAP_TYPE___lkf1__getOrderListByInfo; }
        /** Constructor with member initializations */
        __lkf1__getOrderListByInfo() : lkf2__getOrderListByInfo_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __lkf1__getOrderListByInfo * SOAP_FMAC2 soap_instantiate___lkf1__getOrderListByInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:2425 */
#ifndef SOAP_TYPE___lkf1__addProductType
#define SOAP_TYPE___lkf1__addProductType (123)
/* Wrapper: */
struct SOAP_CMAC __lkf1__addProductType {
      public:
        /** Optional element 'lkf2:addProductType' of XML schema type 'lkf2:addProductType' */
        lkf2__addProductType *lkf2__addProductType_;
      public:
        /** Return unique type id SOAP_TYPE___lkf1__addProductType */
        long soap_type() const { return SOAP_TYPE___lkf1__addProductType; }
        /** Constructor with member initializations */
        __lkf1__addProductType() : lkf2__addProductType_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __lkf1__addProductType * SOAP_FMAC2 soap_instantiate___lkf1__addProductType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:2492 */
#ifndef SOAP_TYPE___lkf1__updateProductByInfo
#define SOAP_TYPE___lkf1__updateProductByInfo (127)
/* Wrapper: */
struct SOAP_CMAC __lkf1__updateProductByInfo {
      public:
        /** Optional element 'lkf2:updateProductByInfo' of XML schema type 'lkf2:updateProductByInfo' */
        lkf2__updateProductByInfo *lkf2__updateProductByInfo_;
      public:
        /** Return unique type id SOAP_TYPE___lkf1__updateProductByInfo */
        long soap_type() const { return SOAP_TYPE___lkf1__updateProductByInfo; }
        /** Constructor with member initializations */
        __lkf1__updateProductByInfo() : lkf2__updateProductByInfo_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __lkf1__updateProductByInfo * SOAP_FMAC2 soap_instantiate___lkf1__updateProductByInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:2559 */
#ifndef SOAP_TYPE___lkf1__getProductLikeList
#define SOAP_TYPE___lkf1__getProductLikeList (131)
/* Wrapper: */
struct SOAP_CMAC __lkf1__getProductLikeList {
      public:
        /** Optional element 'lkf2:getProductLikeList' of XML schema type 'lkf2:getProductLikeList' */
        lkf2__getProductLikeList *lkf2__getProductLikeList_;
      public:
        /** Return unique type id SOAP_TYPE___lkf1__getProductLikeList */
        long soap_type() const { return SOAP_TYPE___lkf1__getProductLikeList; }
        /** Constructor with member initializations */
        __lkf1__getProductLikeList() : lkf2__getProductLikeList_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __lkf1__getProductLikeList * SOAP_FMAC2 soap_instantiate___lkf1__getProductLikeList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:2626 */
#ifndef SOAP_TYPE___lkf1__addOrder
#define SOAP_TYPE___lkf1__addOrder (135)
/* Wrapper: */
struct SOAP_CMAC __lkf1__addOrder {
      public:
        /** Optional element 'lkf2:addOrder' of XML schema type 'lkf2:addOrder' */
        lkf2__addOrder *lkf2__addOrder_;
      public:
        /** Return unique type id SOAP_TYPE___lkf1__addOrder */
        long soap_type() const { return SOAP_TYPE___lkf1__addOrder; }
        /** Constructor with member initializations */
        __lkf1__addOrder() : lkf2__addOrder_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __lkf1__addOrder * SOAP_FMAC2 soap_instantiate___lkf1__addOrder(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:2693 */
#ifndef SOAP_TYPE___lkf1__getClientByNameAndPwd
#define SOAP_TYPE___lkf1__getClientByNameAndPwd (139)
/* Wrapper: */
struct SOAP_CMAC __lkf1__getClientByNameAndPwd {
      public:
        /** Optional element 'lkf2:getClientByNameAndPwd' of XML schema type 'lkf2:getClientByNameAndPwd' */
        lkf2__getClientByNameAndPwd *lkf2__getClientByNameAndPwd_;
      public:
        /** Return unique type id SOAP_TYPE___lkf1__getClientByNameAndPwd */
        long soap_type() const { return SOAP_TYPE___lkf1__getClientByNameAndPwd; }
        /** Constructor with member initializations */
        __lkf1__getClientByNameAndPwd() : lkf2__getClientByNameAndPwd_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __lkf1__getClientByNameAndPwd * SOAP_FMAC2 soap_instantiate___lkf1__getClientByNameAndPwd(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:2760 */
#ifndef SOAP_TYPE___lkf1__deleteShoppingCart
#define SOAP_TYPE___lkf1__deleteShoppingCart (143)
/* Wrapper: */
struct SOAP_CMAC __lkf1__deleteShoppingCart {
      public:
        /** Optional element 'lkf2:deleteShoppingCart' of XML schema type 'lkf2:deleteShoppingCart' */
        lkf2__deleteShoppingCart *lkf2__deleteShoppingCart_;
      public:
        /** Return unique type id SOAP_TYPE___lkf1__deleteShoppingCart */
        long soap_type() const { return SOAP_TYPE___lkf1__deleteShoppingCart; }
        /** Constructor with member initializations */
        __lkf1__deleteShoppingCart() : lkf2__deleteShoppingCart_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __lkf1__deleteShoppingCart * SOAP_FMAC2 soap_instantiate___lkf1__deleteShoppingCart(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:2827 */
#ifndef SOAP_TYPE___lkf1__getProductList
#define SOAP_TYPE___lkf1__getProductList (147)
/* Wrapper: */
struct SOAP_CMAC __lkf1__getProductList {
      public:
        /** Optional element 'lkf2:getProductList' of XML schema type 'lkf2:getProductList' */
        lkf2__getProductList *lkf2__getProductList_;
      public:
        /** Return unique type id SOAP_TYPE___lkf1__getProductList */
        long soap_type() const { return SOAP_TYPE___lkf1__getProductList; }
        /** Constructor with member initializations */
        __lkf1__getProductList() : lkf2__getProductList_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __lkf1__getProductList * SOAP_FMAC2 soap_instantiate___lkf1__getProductList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:2894 */
#ifndef SOAP_TYPE___lkf1__InsertClient
#define SOAP_TYPE___lkf1__InsertClient (151)
/* Wrapper: */
struct SOAP_CMAC __lkf1__InsertClient {
      public:
        /** Optional element 'lkf2:InsertClient' of XML schema type 'lkf2:InsertClient' */
        lkf2__InsertClient *lkf2__InsertClient_;
      public:
        /** Return unique type id SOAP_TYPE___lkf1__InsertClient */
        long soap_type() const { return SOAP_TYPE___lkf1__InsertClient; }
        /** Constructor with member initializations */
        __lkf1__InsertClient() : lkf2__InsertClient_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __lkf1__InsertClient * SOAP_FMAC2 soap_instantiate___lkf1__InsertClient(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:2961 */
#ifndef SOAP_TYPE___lkf1__getOrderListHistory
#define SOAP_TYPE___lkf1__getOrderListHistory (155)
/* Wrapper: */
struct SOAP_CMAC __lkf1__getOrderListHistory {
      public:
        /** Optional element 'lkf2:getOrderListHistory' of XML schema type 'lkf2:getOrderListHistory' */
        lkf2__getOrderListHistory *lkf2__getOrderListHistory_;
      public:
        /** Return unique type id SOAP_TYPE___lkf1__getOrderListHistory */
        long soap_type() const { return SOAP_TYPE___lkf1__getOrderListHistory; }
        /** Constructor with member initializations */
        __lkf1__getOrderListHistory() : lkf2__getOrderListHistory_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __lkf1__getOrderListHistory * SOAP_FMAC2 soap_instantiate___lkf1__getOrderListHistory(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:3028 */
#ifndef SOAP_TYPE___lkf1__updateHistory
#define SOAP_TYPE___lkf1__updateHistory (159)
/* Wrapper: */
struct SOAP_CMAC __lkf1__updateHistory {
      public:
        /** Optional element 'lkf2:updateHistory' of XML schema type 'lkf2:updateHistory' */
        lkf2__updateHistory *lkf2__updateHistory_;
      public:
        /** Return unique type id SOAP_TYPE___lkf1__updateHistory */
        long soap_type() const { return SOAP_TYPE___lkf1__updateHistory; }
        /** Constructor with member initializations */
        __lkf1__updateHistory() : lkf2__updateHistory_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __lkf1__updateHistory * SOAP_FMAC2 soap_instantiate___lkf1__updateHistory(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* taskInfo.h:3177 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (160)
/* SOAP_ENV__Header: */
struct SOAP_CMAC SOAP_ENV__Header {
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* taskInfo.h:3177 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (161)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_CMAC SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XML schema type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Code */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code() : SOAP_ENV__Value(), SOAP_ENV__Subcode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* taskInfo.h:3177 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (163)
/* SOAP_ENV__Detail: */
struct SOAP_CMAC SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_<typename> assigned to __type */
        /** Do not create a cyclic data structure through this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail() : __any(), __type(), fault() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* taskInfo.h:3177 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (166)
/* SOAP_ENV__Reason: */
struct SOAP_CMAC SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Reason */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason() : SOAP_ENV__Text() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* taskInfo.h:3177 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (167)
/* SOAP_ENV__Fault: */
struct SOAP_CMAC SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XML schema type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XML schema type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XML schema type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XML schema type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault() : faultcode(), faultstring(), faultactor(), detail(), SOAP_ENV__Code(), SOAP_ENV__Reason(), SOAP_ENV__Node(), SOAP_ENV__Role(), SOAP_ENV__Detail() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* (built-in):0 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
typedef char *_XML;
#endif

/* (built-in):0 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
typedef char *_QName;
#endif

/* taskInfo.h:152 */
#ifndef SOAP_TYPE_xsd__decimal
#define SOAP_TYPE_xsd__decimal (9)
typedef std::string xsd__decimal;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_byte
#define SOAP_TYPE_byte (3)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_int
#define SOAP_TYPE_int (1)
#endif

/* float has binding name 'float' for type 'xsd:float' */
#ifndef SOAP_TYPE_float
#define SOAP_TYPE_float (60)
#endif

/* time_t has binding name 'dateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_dateTime
#define SOAP_TYPE_dateTime (65)
#endif

/* lkf2__updateHistoryResponse has binding name 'lkf2__updateHistoryResponse' for type 'lkf2:updateHistoryResponse' */
#ifndef SOAP_TYPE_lkf2__updateHistoryResponse
#define SOAP_TYPE_lkf2__updateHistoryResponse (57)
#endif

/* lkf2__updateHistory has binding name 'lkf2__updateHistory' for type 'lkf2:updateHistory' */
#ifndef SOAP_TYPE_lkf2__updateHistory
#define SOAP_TYPE_lkf2__updateHistory (56)
#endif

/* lkf2__getOrderListHistoryResponse has binding name 'lkf2__getOrderListHistoryResponse' for type 'lkf2:getOrderListHistoryResponse' */
#ifndef SOAP_TYPE_lkf2__getOrderListHistoryResponse
#define SOAP_TYPE_lkf2__getOrderListHistoryResponse (55)
#endif

/* lkf2__getOrderListHistory has binding name 'lkf2__getOrderListHistory' for type 'lkf2:getOrderListHistory' */
#ifndef SOAP_TYPE_lkf2__getOrderListHistory
#define SOAP_TYPE_lkf2__getOrderListHistory (54)
#endif

/* lkf2__InsertClientResponse has binding name 'lkf2__InsertClientResponse' for type 'lkf2:InsertClientResponse' */
#ifndef SOAP_TYPE_lkf2__InsertClientResponse
#define SOAP_TYPE_lkf2__InsertClientResponse (53)
#endif

/* lkf2__InsertClient has binding name 'lkf2__InsertClient' for type 'lkf2:InsertClient' */
#ifndef SOAP_TYPE_lkf2__InsertClient
#define SOAP_TYPE_lkf2__InsertClient (52)
#endif

/* lkf2__getProductListResponse has binding name 'lkf2__getProductListResponse' for type 'lkf2:getProductListResponse' */
#ifndef SOAP_TYPE_lkf2__getProductListResponse
#define SOAP_TYPE_lkf2__getProductListResponse (51)
#endif

/* lkf2__getProductList has binding name 'lkf2__getProductList' for type 'lkf2:getProductList' */
#ifndef SOAP_TYPE_lkf2__getProductList
#define SOAP_TYPE_lkf2__getProductList (50)
#endif

/* lkf2__deleteShoppingCartResponse has binding name 'lkf2__deleteShoppingCartResponse' for type 'lkf2:deleteShoppingCartResponse' */
#ifndef SOAP_TYPE_lkf2__deleteShoppingCartResponse
#define SOAP_TYPE_lkf2__deleteShoppingCartResponse (49)
#endif

/* lkf2__deleteShoppingCart has binding name 'lkf2__deleteShoppingCart' for type 'lkf2:deleteShoppingCart' */
#ifndef SOAP_TYPE_lkf2__deleteShoppingCart
#define SOAP_TYPE_lkf2__deleteShoppingCart (48)
#endif

/* lkf2__getClientByNameAndPwdResponse has binding name 'lkf2__getClientByNameAndPwdResponse' for type 'lkf2:getClientByNameAndPwdResponse' */
#ifndef SOAP_TYPE_lkf2__getClientByNameAndPwdResponse
#define SOAP_TYPE_lkf2__getClientByNameAndPwdResponse (47)
#endif

/* lkf2__getClientByNameAndPwd has binding name 'lkf2__getClientByNameAndPwd' for type 'lkf2:getClientByNameAndPwd' */
#ifndef SOAP_TYPE_lkf2__getClientByNameAndPwd
#define SOAP_TYPE_lkf2__getClientByNameAndPwd (46)
#endif

/* lkf2__addOrderResponse has binding name 'lkf2__addOrderResponse' for type 'lkf2:addOrderResponse' */
#ifndef SOAP_TYPE_lkf2__addOrderResponse
#define SOAP_TYPE_lkf2__addOrderResponse (45)
#endif

/* lkf2__addOrder has binding name 'lkf2__addOrder' for type 'lkf2:addOrder' */
#ifndef SOAP_TYPE_lkf2__addOrder
#define SOAP_TYPE_lkf2__addOrder (44)
#endif

/* lkf2__getProductLikeListResponse has binding name 'lkf2__getProductLikeListResponse' for type 'lkf2:getProductLikeListResponse' */
#ifndef SOAP_TYPE_lkf2__getProductLikeListResponse
#define SOAP_TYPE_lkf2__getProductLikeListResponse (43)
#endif

/* lkf2__getProductLikeList has binding name 'lkf2__getProductLikeList' for type 'lkf2:getProductLikeList' */
#ifndef SOAP_TYPE_lkf2__getProductLikeList
#define SOAP_TYPE_lkf2__getProductLikeList (42)
#endif

/* lkf2__updateProductByInfoResponse has binding name 'lkf2__updateProductByInfoResponse' for type 'lkf2:updateProductByInfoResponse' */
#ifndef SOAP_TYPE_lkf2__updateProductByInfoResponse
#define SOAP_TYPE_lkf2__updateProductByInfoResponse (41)
#endif

/* lkf2__updateProductByInfo has binding name 'lkf2__updateProductByInfo' for type 'lkf2:updateProductByInfo' */
#ifndef SOAP_TYPE_lkf2__updateProductByInfo
#define SOAP_TYPE_lkf2__updateProductByInfo (40)
#endif

/* lkf2__addProductTypeResponse has binding name 'lkf2__addProductTypeResponse' for type 'lkf2:addProductTypeResponse' */
#ifndef SOAP_TYPE_lkf2__addProductTypeResponse
#define SOAP_TYPE_lkf2__addProductTypeResponse (39)
#endif

/* lkf2__addProductType has binding name 'lkf2__addProductType' for type 'lkf2:addProductType' */
#ifndef SOAP_TYPE_lkf2__addProductType
#define SOAP_TYPE_lkf2__addProductType (38)
#endif

/* lkf2__getOrderListByInfoResponse has binding name 'lkf2__getOrderListByInfoResponse' for type 'lkf2:getOrderListByInfoResponse' */
#ifndef SOAP_TYPE_lkf2__getOrderListByInfoResponse
#define SOAP_TYPE_lkf2__getOrderListByInfoResponse (37)
#endif

/* lkf2__getOrderListByInfo has binding name 'lkf2__getOrderListByInfo' for type 'lkf2:getOrderListByInfo' */
#ifndef SOAP_TYPE_lkf2__getOrderListByInfo
#define SOAP_TYPE_lkf2__getOrderListByInfo (36)
#endif

/* lkf2__getClientListResponse has binding name 'lkf2__getClientListResponse' for type 'lkf2:getClientListResponse' */
#ifndef SOAP_TYPE_lkf2__getClientListResponse
#define SOAP_TYPE_lkf2__getClientListResponse (35)
#endif

/* lkf2__getClientList has binding name 'lkf2__getClientList' for type 'lkf2:getClientList' */
#ifndef SOAP_TYPE_lkf2__getClientList
#define SOAP_TYPE_lkf2__getClientList (34)
#endif

/* lkf2__productType has binding name 'lkf2__productType' for type 'lkf2:productType' */
#ifndef SOAP_TYPE_lkf2__productType
#define SOAP_TYPE_lkf2__productType (33)
#endif

/* lkf2__getProductTypeByProNameResponse has binding name 'lkf2__getProductTypeByProNameResponse' for type 'lkf2:getProductTypeByProNameResponse' */
#ifndef SOAP_TYPE_lkf2__getProductTypeByProNameResponse
#define SOAP_TYPE_lkf2__getProductTypeByProNameResponse (32)
#endif

/* lkf2__getProductTypeByProName has binding name 'lkf2__getProductTypeByProName' for type 'lkf2:getProductTypeByProName' */
#ifndef SOAP_TYPE_lkf2__getProductTypeByProName
#define SOAP_TYPE_lkf2__getProductTypeByProName (31)
#endif

/* lkf2__getClientLikeListResponse has binding name 'lkf2__getClientLikeListResponse' for type 'lkf2:getClientLikeListResponse' */
#ifndef SOAP_TYPE_lkf2__getClientLikeListResponse
#define SOAP_TYPE_lkf2__getClientLikeListResponse (30)
#endif

/* lkf2__getClientLikeList has binding name 'lkf2__getClientLikeList' for type 'lkf2:getClientLikeList' */
#ifndef SOAP_TYPE_lkf2__getClientLikeList
#define SOAP_TYPE_lkf2__getClientLikeList (29)
#endif

/* lkf2__getOrderLikeListResponse has binding name 'lkf2__getOrderLikeListResponse' for type 'lkf2:getOrderLikeListResponse' */
#ifndef SOAP_TYPE_lkf2__getOrderLikeListResponse
#define SOAP_TYPE_lkf2__getOrderLikeListResponse (28)
#endif

/* lkf2__getOrderLikeList has binding name 'lkf2__getOrderLikeList' for type 'lkf2:getOrderLikeList' */
#ifndef SOAP_TYPE_lkf2__getOrderLikeList
#define SOAP_TYPE_lkf2__getOrderLikeList (27)
#endif

/* lkf2__deleteProductByInfoResponse has binding name 'lkf2__deleteProductByInfoResponse' for type 'lkf2:deleteProductByInfoResponse' */
#ifndef SOAP_TYPE_lkf2__deleteProductByInfoResponse
#define SOAP_TYPE_lkf2__deleteProductByInfoResponse (26)
#endif

/* lkf2__deleteProductByInfo has binding name 'lkf2__deleteProductByInfo' for type 'lkf2:deleteProductByInfo' */
#ifndef SOAP_TYPE_lkf2__deleteProductByInfo
#define SOAP_TYPE_lkf2__deleteProductByInfo (25)
#endif

/* lkf2__deleteClientByNameAndPwdResponse has binding name 'lkf2__deleteClientByNameAndPwdResponse' for type 'lkf2:deleteClientByNameAndPwdResponse' */
#ifndef SOAP_TYPE_lkf2__deleteClientByNameAndPwdResponse
#define SOAP_TYPE_lkf2__deleteClientByNameAndPwdResponse (24)
#endif

/* lkf2__deleteClientByNameAndPwd has binding name 'lkf2__deleteClientByNameAndPwd' for type 'lkf2:deleteClientByNameAndPwd' */
#ifndef SOAP_TYPE_lkf2__deleteClientByNameAndPwd
#define SOAP_TYPE_lkf2__deleteClientByNameAndPwd (23)
#endif

/* lkf2__updateClientResponse has binding name 'lkf2__updateClientResponse' for type 'lkf2:updateClientResponse' */
#ifndef SOAP_TYPE_lkf2__updateClientResponse
#define SOAP_TYPE_lkf2__updateClientResponse (22)
#endif

/* lkf2__client has binding name 'lkf2__client' for type 'lkf2:client' */
#ifndef SOAP_TYPE_lkf2__client
#define SOAP_TYPE_lkf2__client (21)
#endif

/* lkf2__updateClient has binding name 'lkf2__updateClient' for type 'lkf2:updateClient' */
#ifndef SOAP_TYPE_lkf2__updateClient
#define SOAP_TYPE_lkf2__updateClient (20)
#endif

/* lkf2__getProductListByInfoResponse has binding name 'lkf2__getProductListByInfoResponse' for type 'lkf2:getProductListByInfoResponse' */
#ifndef SOAP_TYPE_lkf2__getProductListByInfoResponse
#define SOAP_TYPE_lkf2__getProductListByInfoResponse (19)
#endif

/* lkf2__getProductListByInfo has binding name 'lkf2__getProductListByInfo' for type 'lkf2:getProductListByInfo' */
#ifndef SOAP_TYPE_lkf2__getProductListByInfo
#define SOAP_TYPE_lkf2__getProductListByInfo (18)
#endif

/* lkf2__order has binding name 'lkf2__order' for type 'lkf2:order' */
#ifndef SOAP_TYPE_lkf2__order
#define SOAP_TYPE_lkf2__order (17)
#endif

/* lkf2__getOrderListResponse has binding name 'lkf2__getOrderListResponse' for type 'lkf2:getOrderListResponse' */
#ifndef SOAP_TYPE_lkf2__getOrderListResponse
#define SOAP_TYPE_lkf2__getOrderListResponse (16)
#endif

/* lkf2__getOrderList has binding name 'lkf2__getOrderList' for type 'lkf2:getOrderList' */
#ifndef SOAP_TYPE_lkf2__getOrderList
#define SOAP_TYPE_lkf2__getOrderList (15)
#endif

/* lkf2__deleteProductTypeByNameResponse has binding name 'lkf2__deleteProductTypeByNameResponse' for type 'lkf2:deleteProductTypeByNameResponse' */
#ifndef SOAP_TYPE_lkf2__deleteProductTypeByNameResponse
#define SOAP_TYPE_lkf2__deleteProductTypeByNameResponse (14)
#endif

/* lkf2__deleteProductTypeByName has binding name 'lkf2__deleteProductTypeByName' for type 'lkf2:deleteProductTypeByName' */
#ifndef SOAP_TYPE_lkf2__deleteProductTypeByName
#define SOAP_TYPE_lkf2__deleteProductTypeByName (13)
#endif

/* lkf2__addProductResponse has binding name 'lkf2__addProductResponse' for type 'lkf2:addProductResponse' */
#ifndef SOAP_TYPE_lkf2__addProductResponse
#define SOAP_TYPE_lkf2__addProductResponse (12)
#endif

/* lkf2__product has binding name 'lkf2__product' for type 'lkf2:product' */
#ifndef SOAP_TYPE_lkf2__product
#define SOAP_TYPE_lkf2__product (11)
#endif

/* lkf2__addProduct has binding name 'lkf2__addProduct' for type 'lkf2:addProduct' */
#ifndef SOAP_TYPE_lkf2__addProduct
#define SOAP_TYPE_lkf2__addProduct (10)
#endif

/* xsd__decimal has binding name 'xsd__decimal' for type 'xsd:decimal' */
#ifndef SOAP_TYPE_xsd__decimal
#define SOAP_TYPE_xsd__decimal (9)
#endif

/* std::string has binding name 'std__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__string
#define SOAP_TYPE_std__string (8)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (167)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (166)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (163)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (161)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (160)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_PointerToSOAP_ENV__Reason (169)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_PointerToSOAP_ENV__Detail (168)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
#define SOAP_TYPE_PointerToSOAP_ENV__Code (162)
#endif

/* lkf2__updateHistory * has binding name 'PointerTolkf2__updateHistory' for type 'lkf2:updateHistory' */
#ifndef SOAP_TYPE_PointerTolkf2__updateHistory
#define SOAP_TYPE_PointerTolkf2__updateHistory (156)
#endif

/* lkf2__getOrderListHistory * has binding name 'PointerTolkf2__getOrderListHistory' for type 'lkf2:getOrderListHistory' */
#ifndef SOAP_TYPE_PointerTolkf2__getOrderListHistory
#define SOAP_TYPE_PointerTolkf2__getOrderListHistory (152)
#endif

/* lkf2__InsertClient * has binding name 'PointerTolkf2__InsertClient' for type 'lkf2:InsertClient' */
#ifndef SOAP_TYPE_PointerTolkf2__InsertClient
#define SOAP_TYPE_PointerTolkf2__InsertClient (148)
#endif

/* lkf2__getProductList * has binding name 'PointerTolkf2__getProductList' for type 'lkf2:getProductList' */
#ifndef SOAP_TYPE_PointerTolkf2__getProductList
#define SOAP_TYPE_PointerTolkf2__getProductList (144)
#endif

/* lkf2__deleteShoppingCart * has binding name 'PointerTolkf2__deleteShoppingCart' for type 'lkf2:deleteShoppingCart' */
#ifndef SOAP_TYPE_PointerTolkf2__deleteShoppingCart
#define SOAP_TYPE_PointerTolkf2__deleteShoppingCart (140)
#endif

/* lkf2__getClientByNameAndPwd * has binding name 'PointerTolkf2__getClientByNameAndPwd' for type 'lkf2:getClientByNameAndPwd' */
#ifndef SOAP_TYPE_PointerTolkf2__getClientByNameAndPwd
#define SOAP_TYPE_PointerTolkf2__getClientByNameAndPwd (136)
#endif

/* lkf2__addOrder * has binding name 'PointerTolkf2__addOrder' for type 'lkf2:addOrder' */
#ifndef SOAP_TYPE_PointerTolkf2__addOrder
#define SOAP_TYPE_PointerTolkf2__addOrder (132)
#endif

/* lkf2__getProductLikeList * has binding name 'PointerTolkf2__getProductLikeList' for type 'lkf2:getProductLikeList' */
#ifndef SOAP_TYPE_PointerTolkf2__getProductLikeList
#define SOAP_TYPE_PointerTolkf2__getProductLikeList (128)
#endif

/* lkf2__updateProductByInfo * has binding name 'PointerTolkf2__updateProductByInfo' for type 'lkf2:updateProductByInfo' */
#ifndef SOAP_TYPE_PointerTolkf2__updateProductByInfo
#define SOAP_TYPE_PointerTolkf2__updateProductByInfo (124)
#endif

/* lkf2__addProductType * has binding name 'PointerTolkf2__addProductType' for type 'lkf2:addProductType' */
#ifndef SOAP_TYPE_PointerTolkf2__addProductType
#define SOAP_TYPE_PointerTolkf2__addProductType (120)
#endif

/* lkf2__getOrderListByInfo * has binding name 'PointerTolkf2__getOrderListByInfo' for type 'lkf2:getOrderListByInfo' */
#ifndef SOAP_TYPE_PointerTolkf2__getOrderListByInfo
#define SOAP_TYPE_PointerTolkf2__getOrderListByInfo (116)
#endif

/* lkf2__getClientList * has binding name 'PointerTolkf2__getClientList' for type 'lkf2:getClientList' */
#ifndef SOAP_TYPE_PointerTolkf2__getClientList
#define SOAP_TYPE_PointerTolkf2__getClientList (112)
#endif

/* lkf2__getProductTypeByProName * has binding name 'PointerTolkf2__getProductTypeByProName' for type 'lkf2:getProductTypeByProName' */
#ifndef SOAP_TYPE_PointerTolkf2__getProductTypeByProName
#define SOAP_TYPE_PointerTolkf2__getProductTypeByProName (108)
#endif

/* lkf2__getClientLikeList * has binding name 'PointerTolkf2__getClientLikeList' for type 'lkf2:getClientLikeList' */
#ifndef SOAP_TYPE_PointerTolkf2__getClientLikeList
#define SOAP_TYPE_PointerTolkf2__getClientLikeList (104)
#endif

/* lkf2__getOrderLikeList * has binding name 'PointerTolkf2__getOrderLikeList' for type 'lkf2:getOrderLikeList' */
#ifndef SOAP_TYPE_PointerTolkf2__getOrderLikeList
#define SOAP_TYPE_PointerTolkf2__getOrderLikeList (100)
#endif

/* lkf2__deleteProductByInfo * has binding name 'PointerTolkf2__deleteProductByInfo' for type 'lkf2:deleteProductByInfo' */
#ifndef SOAP_TYPE_PointerTolkf2__deleteProductByInfo
#define SOAP_TYPE_PointerTolkf2__deleteProductByInfo (96)
#endif

/* lkf2__deleteClientByNameAndPwd * has binding name 'PointerTolkf2__deleteClientByNameAndPwd' for type 'lkf2:deleteClientByNameAndPwd' */
#ifndef SOAP_TYPE_PointerTolkf2__deleteClientByNameAndPwd
#define SOAP_TYPE_PointerTolkf2__deleteClientByNameAndPwd (92)
#endif

/* lkf2__updateClient * has binding name 'PointerTolkf2__updateClient' for type 'lkf2:updateClient' */
#ifndef SOAP_TYPE_PointerTolkf2__updateClient
#define SOAP_TYPE_PointerTolkf2__updateClient (88)
#endif

/* lkf2__getProductListByInfo * has binding name 'PointerTolkf2__getProductListByInfo' for type 'lkf2:getProductListByInfo' */
#ifndef SOAP_TYPE_PointerTolkf2__getProductListByInfo
#define SOAP_TYPE_PointerTolkf2__getProductListByInfo (84)
#endif

/* lkf2__getOrderList * has binding name 'PointerTolkf2__getOrderList' for type 'lkf2:getOrderList' */
#ifndef SOAP_TYPE_PointerTolkf2__getOrderList
#define SOAP_TYPE_PointerTolkf2__getOrderList (80)
#endif

/* lkf2__deleteProductTypeByName * has binding name 'PointerTolkf2__deleteProductTypeByName' for type 'lkf2:deleteProductTypeByName' */
#ifndef SOAP_TYPE_PointerTolkf2__deleteProductTypeByName
#define SOAP_TYPE_PointerTolkf2__deleteProductTypeByName (76)
#endif

/* lkf2__addProduct * has binding name 'PointerTolkf2__addProduct' for type 'lkf2:addProduct' */
#ifndef SOAP_TYPE_PointerTolkf2__addProduct
#define SOAP_TYPE_PointerTolkf2__addProduct (72)
#endif

/* lkf2__productType * has binding name 'PointerTolkf2__productType' for type 'lkf2:productType' */
#ifndef SOAP_TYPE_PointerTolkf2__productType
#define SOAP_TYPE_PointerTolkf2__productType (70)
#endif

/* lkf2__client * has binding name 'PointerTolkf2__client' for type 'lkf2:client' */
#ifndef SOAP_TYPE_PointerTolkf2__client
#define SOAP_TYPE_PointerTolkf2__client (68)
#endif

/* time_t * has binding name 'PointerTodateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_PointerTodateTime
#define SOAP_TYPE_PointerTodateTime (66)
#endif

/* std::string * has binding name 'PointerToxsd__decimal' for type 'xsd:decimal' */
#ifndef SOAP_TYPE_PointerToxsd__decimal
#define SOAP_TYPE_PointerToxsd__decimal (64)
#endif

/* lkf2__order * has binding name 'PointerTolkf2__order' for type 'lkf2:order' */
#ifndef SOAP_TYPE_PointerTolkf2__order
#define SOAP_TYPE_PointerTolkf2__order (62)
#endif

/* std::string * has binding name 'PointerTostd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_PointerTostd__string
#define SOAP_TYPE_PointerTostd__string (61)
#endif

/* lkf2__product * has binding name 'PointerTolkf2__product' for type 'lkf2:product' */
#ifndef SOAP_TYPE_PointerTolkf2__product
#define SOAP_TYPE_PointerTolkf2__product (58)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_string
#define SOAP_TYPE_string (4)
#endif

/* std::vector<lkf2__productType *>  has binding name 'std__vectorTemplateOfPointerTolkf2__productType' for type 'lkf2:productType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTolkf2__productType
#define SOAP_TYPE_std__vectorTemplateOfPointerTolkf2__productType (71)
#endif

/* std::vector<lkf2__client *>  has binding name 'std__vectorTemplateOfPointerTolkf2__client' for type 'lkf2:client' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTolkf2__client
#define SOAP_TYPE_std__vectorTemplateOfPointerTolkf2__client (69)
#endif

/* std::vector<lkf2__product *>  has binding name 'std__vectorTemplateOfPointerTolkf2__product' for type 'lkf2:product' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTolkf2__product
#define SOAP_TYPE_std__vectorTemplateOfPointerTolkf2__product (67)
#endif

/* std::vector<lkf2__order *>  has binding name 'std__vectorTemplateOfPointerTolkf2__order' for type 'lkf2:order' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTolkf2__order
#define SOAP_TYPE_std__vectorTemplateOfPointerTolkf2__order (63)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Client-Side Call Stub Functions                                            *
 *                                                                            *
\******************************************************************************/

    
    /** Web service synchronous operation 'soap_call___lkf1__addProduct' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___lkf1__addProduct(struct soap *soap, const char *soap_endpoint, const char *soap_action, lkf2__addProduct *lkf2__addProduct_, lkf2__addProductResponse &lkf2__addProductResponse_);
    /** Web service asynchronous operation 'soap_send___lkf1__addProduct' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___lkf1__addProduct(struct soap *soap, const char *soap_endpoint, const char *soap_action, lkf2__addProduct *lkf2__addProduct_);
    /** Web service asynchronous operation 'soap_recv___lkf1__addProduct' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___lkf1__addProduct(struct soap *soap, lkf2__addProductResponse &lkf2__addProductResponse_);
    
    /** Web service synchronous operation 'soap_call___lkf1__deleteProductTypeByName' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___lkf1__deleteProductTypeByName(struct soap *soap, const char *soap_endpoint, const char *soap_action, lkf2__deleteProductTypeByName *lkf2__deleteProductTypeByName_, lkf2__deleteProductTypeByNameResponse &lkf2__deleteProductTypeByNameResponse_);
    /** Web service asynchronous operation 'soap_send___lkf1__deleteProductTypeByName' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___lkf1__deleteProductTypeByName(struct soap *soap, const char *soap_endpoint, const char *soap_action, lkf2__deleteProductTypeByName *lkf2__deleteProductTypeByName_);
    /** Web service asynchronous operation 'soap_recv___lkf1__deleteProductTypeByName' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___lkf1__deleteProductTypeByName(struct soap *soap, lkf2__deleteProductTypeByNameResponse &lkf2__deleteProductTypeByNameResponse_);
    
    /** Web service synchronous operation 'soap_call___lkf1__getOrderList' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___lkf1__getOrderList(struct soap *soap, const char *soap_endpoint, const char *soap_action, lkf2__getOrderList *lkf2__getOrderList_, lkf2__getOrderListResponse &lkf2__getOrderListResponse_);
    /** Web service asynchronous operation 'soap_send___lkf1__getOrderList' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___lkf1__getOrderList(struct soap *soap, const char *soap_endpoint, const char *soap_action, lkf2__getOrderList *lkf2__getOrderList_);
    /** Web service asynchronous operation 'soap_recv___lkf1__getOrderList' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___lkf1__getOrderList(struct soap *soap, lkf2__getOrderListResponse &lkf2__getOrderListResponse_);
    
    /** Web service synchronous operation 'soap_call___lkf1__getProductListByInfo' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___lkf1__getProductListByInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, lkf2__getProductListByInfo *lkf2__getProductListByInfo_, lkf2__getProductListByInfoResponse &lkf2__getProductListByInfoResponse_);
    /** Web service asynchronous operation 'soap_send___lkf1__getProductListByInfo' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___lkf1__getProductListByInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, lkf2__getProductListByInfo *lkf2__getProductListByInfo_);
    /** Web service asynchronous operation 'soap_recv___lkf1__getProductListByInfo' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___lkf1__getProductListByInfo(struct soap *soap, lkf2__getProductListByInfoResponse &lkf2__getProductListByInfoResponse_);
    
    /** Web service synchronous operation 'soap_call___lkf1__updateClient' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___lkf1__updateClient(struct soap *soap, const char *soap_endpoint, const char *soap_action, lkf2__updateClient *lkf2__updateClient_, lkf2__updateClientResponse &lkf2__updateClientResponse_);
    /** Web service asynchronous operation 'soap_send___lkf1__updateClient' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___lkf1__updateClient(struct soap *soap, const char *soap_endpoint, const char *soap_action, lkf2__updateClient *lkf2__updateClient_);
    /** Web service asynchronous operation 'soap_recv___lkf1__updateClient' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___lkf1__updateClient(struct soap *soap, lkf2__updateClientResponse &lkf2__updateClientResponse_);
    
    /** Web service synchronous operation 'soap_call___lkf1__deleteClientByNameAndPwd' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___lkf1__deleteClientByNameAndPwd(struct soap *soap, const char *soap_endpoint, const char *soap_action, lkf2__deleteClientByNameAndPwd *lkf2__deleteClientByNameAndPwd_, lkf2__deleteClientByNameAndPwdResponse &lkf2__deleteClientByNameAndPwdResponse_);
    /** Web service asynchronous operation 'soap_send___lkf1__deleteClientByNameAndPwd' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___lkf1__deleteClientByNameAndPwd(struct soap *soap, const char *soap_endpoint, const char *soap_action, lkf2__deleteClientByNameAndPwd *lkf2__deleteClientByNameAndPwd_);
    /** Web service asynchronous operation 'soap_recv___lkf1__deleteClientByNameAndPwd' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___lkf1__deleteClientByNameAndPwd(struct soap *soap, lkf2__deleteClientByNameAndPwdResponse &lkf2__deleteClientByNameAndPwdResponse_);
    
    /** Web service synchronous operation 'soap_call___lkf1__deleteProductByInfo' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___lkf1__deleteProductByInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, lkf2__deleteProductByInfo *lkf2__deleteProductByInfo_, lkf2__deleteProductByInfoResponse &lkf2__deleteProductByInfoResponse_);
    /** Web service asynchronous operation 'soap_send___lkf1__deleteProductByInfo' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___lkf1__deleteProductByInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, lkf2__deleteProductByInfo *lkf2__deleteProductByInfo_);
    /** Web service asynchronous operation 'soap_recv___lkf1__deleteProductByInfo' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___lkf1__deleteProductByInfo(struct soap *soap, lkf2__deleteProductByInfoResponse &lkf2__deleteProductByInfoResponse_);
    
    /** Web service synchronous operation 'soap_call___lkf1__getOrderLikeList' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___lkf1__getOrderLikeList(struct soap *soap, const char *soap_endpoint, const char *soap_action, lkf2__getOrderLikeList *lkf2__getOrderLikeList_, lkf2__getOrderLikeListResponse &lkf2__getOrderLikeListResponse_);
    /** Web service asynchronous operation 'soap_send___lkf1__getOrderLikeList' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___lkf1__getOrderLikeList(struct soap *soap, const char *soap_endpoint, const char *soap_action, lkf2__getOrderLikeList *lkf2__getOrderLikeList_);
    /** Web service asynchronous operation 'soap_recv___lkf1__getOrderLikeList' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___lkf1__getOrderLikeList(struct soap *soap, lkf2__getOrderLikeListResponse &lkf2__getOrderLikeListResponse_);
    
    /** Web service synchronous operation 'soap_call___lkf1__getClientLikeList' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___lkf1__getClientLikeList(struct soap *soap, const char *soap_endpoint, const char *soap_action, lkf2__getClientLikeList *lkf2__getClientLikeList_, lkf2__getClientLikeListResponse &lkf2__getClientLikeListResponse_);
    /** Web service asynchronous operation 'soap_send___lkf1__getClientLikeList' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___lkf1__getClientLikeList(struct soap *soap, const char *soap_endpoint, const char *soap_action, lkf2__getClientLikeList *lkf2__getClientLikeList_);
    /** Web service asynchronous operation 'soap_recv___lkf1__getClientLikeList' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___lkf1__getClientLikeList(struct soap *soap, lkf2__getClientLikeListResponse &lkf2__getClientLikeListResponse_);
    
    /** Web service synchronous operation 'soap_call___lkf1__getProductTypeByProName' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___lkf1__getProductTypeByProName(struct soap *soap, const char *soap_endpoint, const char *soap_action, lkf2__getProductTypeByProName *lkf2__getProductTypeByProName_, lkf2__getProductTypeByProNameResponse &lkf2__getProductTypeByProNameResponse_);
    /** Web service asynchronous operation 'soap_send___lkf1__getProductTypeByProName' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___lkf1__getProductTypeByProName(struct soap *soap, const char *soap_endpoint, const char *soap_action, lkf2__getProductTypeByProName *lkf2__getProductTypeByProName_);
    /** Web service asynchronous operation 'soap_recv___lkf1__getProductTypeByProName' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___lkf1__getProductTypeByProName(struct soap *soap, lkf2__getProductTypeByProNameResponse &lkf2__getProductTypeByProNameResponse_);
    
    /** Web service synchronous operation 'soap_call___lkf1__getClientList' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___lkf1__getClientList(struct soap *soap, const char *soap_endpoint, const char *soap_action, lkf2__getClientList *lkf2__getClientList_, lkf2__getClientListResponse &lkf2__getClientListResponse_);
    /** Web service asynchronous operation 'soap_send___lkf1__getClientList' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___lkf1__getClientList(struct soap *soap, const char *soap_endpoint, const char *soap_action, lkf2__getClientList *lkf2__getClientList_);
    /** Web service asynchronous operation 'soap_recv___lkf1__getClientList' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___lkf1__getClientList(struct soap *soap, lkf2__getClientListResponse &lkf2__getClientListResponse_);
    
    /** Web service synchronous operation 'soap_call___lkf1__getOrderListByInfo' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___lkf1__getOrderListByInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, lkf2__getOrderListByInfo *lkf2__getOrderListByInfo_, lkf2__getOrderListByInfoResponse &lkf2__getOrderListByInfoResponse_);
    /** Web service asynchronous operation 'soap_send___lkf1__getOrderListByInfo' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___lkf1__getOrderListByInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, lkf2__getOrderListByInfo *lkf2__getOrderListByInfo_);
    /** Web service asynchronous operation 'soap_recv___lkf1__getOrderListByInfo' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___lkf1__getOrderListByInfo(struct soap *soap, lkf2__getOrderListByInfoResponse &lkf2__getOrderListByInfoResponse_);
    
    /** Web service synchronous operation 'soap_call___lkf1__addProductType' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___lkf1__addProductType(struct soap *soap, const char *soap_endpoint, const char *soap_action, lkf2__addProductType *lkf2__addProductType_, lkf2__addProductTypeResponse &lkf2__addProductTypeResponse_);
    /** Web service asynchronous operation 'soap_send___lkf1__addProductType' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___lkf1__addProductType(struct soap *soap, const char *soap_endpoint, const char *soap_action, lkf2__addProductType *lkf2__addProductType_);
    /** Web service asynchronous operation 'soap_recv___lkf1__addProductType' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___lkf1__addProductType(struct soap *soap, lkf2__addProductTypeResponse &lkf2__addProductTypeResponse_);
    
    /** Web service synchronous operation 'soap_call___lkf1__updateProductByInfo' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___lkf1__updateProductByInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, lkf2__updateProductByInfo *lkf2__updateProductByInfo_, lkf2__updateProductByInfoResponse &lkf2__updateProductByInfoResponse_);
    /** Web service asynchronous operation 'soap_send___lkf1__updateProductByInfo' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___lkf1__updateProductByInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, lkf2__updateProductByInfo *lkf2__updateProductByInfo_);
    /** Web service asynchronous operation 'soap_recv___lkf1__updateProductByInfo' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___lkf1__updateProductByInfo(struct soap *soap, lkf2__updateProductByInfoResponse &lkf2__updateProductByInfoResponse_);
    
    /** Web service synchronous operation 'soap_call___lkf1__getProductLikeList' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___lkf1__getProductLikeList(struct soap *soap, const char *soap_endpoint, const char *soap_action, lkf2__getProductLikeList *lkf2__getProductLikeList_, lkf2__getProductLikeListResponse &lkf2__getProductLikeListResponse_);
    /** Web service asynchronous operation 'soap_send___lkf1__getProductLikeList' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___lkf1__getProductLikeList(struct soap *soap, const char *soap_endpoint, const char *soap_action, lkf2__getProductLikeList *lkf2__getProductLikeList_);
    /** Web service asynchronous operation 'soap_recv___lkf1__getProductLikeList' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___lkf1__getProductLikeList(struct soap *soap, lkf2__getProductLikeListResponse &lkf2__getProductLikeListResponse_);
    
    /** Web service synchronous operation 'soap_call___lkf1__addOrder' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___lkf1__addOrder(struct soap *soap, const char *soap_endpoint, const char *soap_action, lkf2__addOrder *lkf2__addOrder_, lkf2__addOrderResponse &lkf2__addOrderResponse_);
    /** Web service asynchronous operation 'soap_send___lkf1__addOrder' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___lkf1__addOrder(struct soap *soap, const char *soap_endpoint, const char *soap_action, lkf2__addOrder *lkf2__addOrder_);
    /** Web service asynchronous operation 'soap_recv___lkf1__addOrder' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___lkf1__addOrder(struct soap *soap, lkf2__addOrderResponse &lkf2__addOrderResponse_);
    
    /** Web service synchronous operation 'soap_call___lkf1__getClientByNameAndPwd' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___lkf1__getClientByNameAndPwd(struct soap *soap, const char *soap_endpoint, const char *soap_action, lkf2__getClientByNameAndPwd *lkf2__getClientByNameAndPwd_, lkf2__getClientByNameAndPwdResponse &lkf2__getClientByNameAndPwdResponse_);
    /** Web service asynchronous operation 'soap_send___lkf1__getClientByNameAndPwd' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___lkf1__getClientByNameAndPwd(struct soap *soap, const char *soap_endpoint, const char *soap_action, lkf2__getClientByNameAndPwd *lkf2__getClientByNameAndPwd_);
    /** Web service asynchronous operation 'soap_recv___lkf1__getClientByNameAndPwd' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___lkf1__getClientByNameAndPwd(struct soap *soap, lkf2__getClientByNameAndPwdResponse &lkf2__getClientByNameAndPwdResponse_);
    
    /** Web service synchronous operation 'soap_call___lkf1__deleteShoppingCart' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___lkf1__deleteShoppingCart(struct soap *soap, const char *soap_endpoint, const char *soap_action, lkf2__deleteShoppingCart *lkf2__deleteShoppingCart_, lkf2__deleteShoppingCartResponse &lkf2__deleteShoppingCartResponse_);
    /** Web service asynchronous operation 'soap_send___lkf1__deleteShoppingCart' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___lkf1__deleteShoppingCart(struct soap *soap, const char *soap_endpoint, const char *soap_action, lkf2__deleteShoppingCart *lkf2__deleteShoppingCart_);
    /** Web service asynchronous operation 'soap_recv___lkf1__deleteShoppingCart' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___lkf1__deleteShoppingCart(struct soap *soap, lkf2__deleteShoppingCartResponse &lkf2__deleteShoppingCartResponse_);
    
    /** Web service synchronous operation 'soap_call___lkf1__getProductList' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___lkf1__getProductList(struct soap *soap, const char *soap_endpoint, const char *soap_action, lkf2__getProductList *lkf2__getProductList_, lkf2__getProductListResponse &lkf2__getProductListResponse_);
    /** Web service asynchronous operation 'soap_send___lkf1__getProductList' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___lkf1__getProductList(struct soap *soap, const char *soap_endpoint, const char *soap_action, lkf2__getProductList *lkf2__getProductList_);
    /** Web service asynchronous operation 'soap_recv___lkf1__getProductList' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___lkf1__getProductList(struct soap *soap, lkf2__getProductListResponse &lkf2__getProductListResponse_);
    
    /** Web service synchronous operation 'soap_call___lkf1__InsertClient' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___lkf1__InsertClient(struct soap *soap, const char *soap_endpoint, const char *soap_action, lkf2__InsertClient *lkf2__InsertClient_, lkf2__InsertClientResponse &lkf2__InsertClientResponse_);
    /** Web service asynchronous operation 'soap_send___lkf1__InsertClient' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___lkf1__InsertClient(struct soap *soap, const char *soap_endpoint, const char *soap_action, lkf2__InsertClient *lkf2__InsertClient_);
    /** Web service asynchronous operation 'soap_recv___lkf1__InsertClient' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___lkf1__InsertClient(struct soap *soap, lkf2__InsertClientResponse &lkf2__InsertClientResponse_);
    
    /** Web service synchronous operation 'soap_call___lkf1__getOrderListHistory' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___lkf1__getOrderListHistory(struct soap *soap, const char *soap_endpoint, const char *soap_action, lkf2__getOrderListHistory *lkf2__getOrderListHistory_, lkf2__getOrderListHistoryResponse &lkf2__getOrderListHistoryResponse_);
    /** Web service asynchronous operation 'soap_send___lkf1__getOrderListHistory' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___lkf1__getOrderListHistory(struct soap *soap, const char *soap_endpoint, const char *soap_action, lkf2__getOrderListHistory *lkf2__getOrderListHistory_);
    /** Web service asynchronous operation 'soap_recv___lkf1__getOrderListHistory' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___lkf1__getOrderListHistory(struct soap *soap, lkf2__getOrderListHistoryResponse &lkf2__getOrderListHistoryResponse_);
    
    /** Web service synchronous operation 'soap_call___lkf1__updateHistory' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___lkf1__updateHistory(struct soap *soap, const char *soap_endpoint, const char *soap_action, lkf2__updateHistory *lkf2__updateHistory_, lkf2__updateHistoryResponse &lkf2__updateHistoryResponse_);
    /** Web service asynchronous operation 'soap_send___lkf1__updateHistory' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___lkf1__updateHistory(struct soap *soap, const char *soap_endpoint, const char *soap_action, lkf2__updateHistory *lkf2__updateHistory_);
    /** Web service asynchronous operation 'soap_recv___lkf1__updateHistory' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___lkf1__updateHistory(struct soap *soap, lkf2__updateHistoryResponse &lkf2__updateHistoryResponse_);

/******************************************************************************\
 *                                                                            *
 * Server-Side Operations                                                     *
 *                                                                            *
\******************************************************************************/

    /** Web service operation '__lkf1__addProduct' implementation, should return SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 __lkf1__addProduct(struct soap*, lkf2__addProduct *lkf2__addProduct_, lkf2__addProductResponse &lkf2__addProductResponse_);
    /** Web service operation '__lkf1__deleteProductTypeByName' implementation, should return SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 __lkf1__deleteProductTypeByName(struct soap*, lkf2__deleteProductTypeByName *lkf2__deleteProductTypeByName_, lkf2__deleteProductTypeByNameResponse &lkf2__deleteProductTypeByNameResponse_);
    /** Web service operation '__lkf1__getOrderList' implementation, should return SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 __lkf1__getOrderList(struct soap*, lkf2__getOrderList *lkf2__getOrderList_, lkf2__getOrderListResponse &lkf2__getOrderListResponse_);
    /** Web service operation '__lkf1__getProductListByInfo' implementation, should return SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 __lkf1__getProductListByInfo(struct soap*, lkf2__getProductListByInfo *lkf2__getProductListByInfo_, lkf2__getProductListByInfoResponse &lkf2__getProductListByInfoResponse_);
    /** Web service operation '__lkf1__updateClient' implementation, should return SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 __lkf1__updateClient(struct soap*, lkf2__updateClient *lkf2__updateClient_, lkf2__updateClientResponse &lkf2__updateClientResponse_);
    /** Web service operation '__lkf1__deleteClientByNameAndPwd' implementation, should return SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 __lkf1__deleteClientByNameAndPwd(struct soap*, lkf2__deleteClientByNameAndPwd *lkf2__deleteClientByNameAndPwd_, lkf2__deleteClientByNameAndPwdResponse &lkf2__deleteClientByNameAndPwdResponse_);
    /** Web service operation '__lkf1__deleteProductByInfo' implementation, should return SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 __lkf1__deleteProductByInfo(struct soap*, lkf2__deleteProductByInfo *lkf2__deleteProductByInfo_, lkf2__deleteProductByInfoResponse &lkf2__deleteProductByInfoResponse_);
    /** Web service operation '__lkf1__getOrderLikeList' implementation, should return SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 __lkf1__getOrderLikeList(struct soap*, lkf2__getOrderLikeList *lkf2__getOrderLikeList_, lkf2__getOrderLikeListResponse &lkf2__getOrderLikeListResponse_);
    /** Web service operation '__lkf1__getClientLikeList' implementation, should return SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 __lkf1__getClientLikeList(struct soap*, lkf2__getClientLikeList *lkf2__getClientLikeList_, lkf2__getClientLikeListResponse &lkf2__getClientLikeListResponse_);
    /** Web service operation '__lkf1__getProductTypeByProName' implementation, should return SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 __lkf1__getProductTypeByProName(struct soap*, lkf2__getProductTypeByProName *lkf2__getProductTypeByProName_, lkf2__getProductTypeByProNameResponse &lkf2__getProductTypeByProNameResponse_);
    /** Web service operation '__lkf1__getClientList' implementation, should return SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 __lkf1__getClientList(struct soap*, lkf2__getClientList *lkf2__getClientList_, lkf2__getClientListResponse &lkf2__getClientListResponse_);
    /** Web service operation '__lkf1__getOrderListByInfo' implementation, should return SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 __lkf1__getOrderListByInfo(struct soap*, lkf2__getOrderListByInfo *lkf2__getOrderListByInfo_, lkf2__getOrderListByInfoResponse &lkf2__getOrderListByInfoResponse_);
    /** Web service operation '__lkf1__addProductType' implementation, should return SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 __lkf1__addProductType(struct soap*, lkf2__addProductType *lkf2__addProductType_, lkf2__addProductTypeResponse &lkf2__addProductTypeResponse_);
    /** Web service operation '__lkf1__updateProductByInfo' implementation, should return SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 __lkf1__updateProductByInfo(struct soap*, lkf2__updateProductByInfo *lkf2__updateProductByInfo_, lkf2__updateProductByInfoResponse &lkf2__updateProductByInfoResponse_);
    /** Web service operation '__lkf1__getProductLikeList' implementation, should return SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 __lkf1__getProductLikeList(struct soap*, lkf2__getProductLikeList *lkf2__getProductLikeList_, lkf2__getProductLikeListResponse &lkf2__getProductLikeListResponse_);
    /** Web service operation '__lkf1__addOrder' implementation, should return SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 __lkf1__addOrder(struct soap*, lkf2__addOrder *lkf2__addOrder_, lkf2__addOrderResponse &lkf2__addOrderResponse_);
    /** Web service operation '__lkf1__getClientByNameAndPwd' implementation, should return SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 __lkf1__getClientByNameAndPwd(struct soap*, lkf2__getClientByNameAndPwd *lkf2__getClientByNameAndPwd_, lkf2__getClientByNameAndPwdResponse &lkf2__getClientByNameAndPwdResponse_);
    /** Web service operation '__lkf1__deleteShoppingCart' implementation, should return SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 __lkf1__deleteShoppingCart(struct soap*, lkf2__deleteShoppingCart *lkf2__deleteShoppingCart_, lkf2__deleteShoppingCartResponse &lkf2__deleteShoppingCartResponse_);
    /** Web service operation '__lkf1__getProductList' implementation, should return SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 __lkf1__getProductList(struct soap*, lkf2__getProductList *lkf2__getProductList_, lkf2__getProductListResponse &lkf2__getProductListResponse_);
    /** Web service operation '__lkf1__InsertClient' implementation, should return SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 __lkf1__InsertClient(struct soap*, lkf2__InsertClient *lkf2__InsertClient_, lkf2__InsertClientResponse &lkf2__InsertClientResponse_);
    /** Web service operation '__lkf1__getOrderListHistory' implementation, should return SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 __lkf1__getOrderListHistory(struct soap*, lkf2__getOrderListHistory *lkf2__getOrderListHistory_, lkf2__getOrderListHistoryResponse &lkf2__getOrderListHistoryResponse_);
    /** Web service operation '__lkf1__updateHistory' implementation, should return SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 __lkf1__updateHistory(struct soap*, lkf2__updateHistory *lkf2__updateHistory_, lkf2__updateHistoryResponse &lkf2__updateHistoryResponse_);

/******************************************************************************\
 *                                                                            *
 * Server-Side Skeletons to Invoke Service Operations                         *
 *                                                                            *
\******************************************************************************/

extern "C" SOAP_FMAC5 int SOAP_FMAC6 soap_serve(struct soap*);

extern "C" SOAP_FMAC5 int SOAP_FMAC6 soap_serve_request(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___lkf1__addProduct(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___lkf1__deleteProductTypeByName(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___lkf1__getOrderList(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___lkf1__getProductListByInfo(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___lkf1__updateClient(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___lkf1__deleteClientByNameAndPwd(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___lkf1__deleteProductByInfo(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___lkf1__getOrderLikeList(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___lkf1__getClientLikeList(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___lkf1__getProductTypeByProName(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___lkf1__getClientList(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___lkf1__getOrderListByInfo(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___lkf1__addProductType(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___lkf1__updateProductByInfo(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___lkf1__getProductLikeList(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___lkf1__addOrder(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___lkf1__getClientByNameAndPwd(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___lkf1__deleteShoppingCart(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___lkf1__getProductList(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___lkf1__InsertClient(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___lkf1__getOrderListHistory(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___lkf1__updateHistory(struct soap*);

#endif

/* End of soapStub.h */
