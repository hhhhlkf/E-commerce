/* soapC.cpp
   Generated by gSOAP 2.8.117 for taskInfo.h

gSOAP XML Web services tools
Copyright (C) 2000-2021, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.117 2021-12-18 16:24:44 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, ""))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (soap->fault == NULL)
			return;
	}
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code == NULL)
		soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Reason == NULL)
		soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", "");
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
				return NULL;
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_subcode(struct soap *soap)
{
	const char **s = soap_faultsubcode(soap);
	return s ? *s : NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Reason)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_string(struct soap *soap)
{
	const char **s = soap_faultstring(soap);
	return s ? *s : NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
			soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
		soap->fault->detail = soap_new_SOAP_ENV__Detail(soap, -1);
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_detail(struct soap *soap)
{
	const char **s = soap_faultdetail(soap);
	return s ? *s : NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, NULL, &t))
				if ((soap->error && soap->error != SOAP_TAG_MISMATCH) || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, const char *tag, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, tag, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, tag, NULL, "xsd:int");
	case SOAP_TYPE_float:
		return soap_in_float(soap, tag, NULL, "xsd:float");
	case SOAP_TYPE_dateTime:
		return soap_in_dateTime(soap, tag, NULL, "xsd:dateTime");
	case SOAP_TYPE_lkf2__updateHistoryResponse:
		return soap_in_lkf2__updateHistoryResponse(soap, tag, NULL, "lkf2:updateHistoryResponse");
	case SOAP_TYPE_lkf2__updateHistory:
		return soap_in_lkf2__updateHistory(soap, tag, NULL, "lkf2:updateHistory");
	case SOAP_TYPE_lkf2__getOrderListHistoryResponse:
		return soap_in_lkf2__getOrderListHistoryResponse(soap, tag, NULL, "lkf2:getOrderListHistoryResponse");
	case SOAP_TYPE_lkf2__getOrderListHistory:
		return soap_in_lkf2__getOrderListHistory(soap, tag, NULL, "lkf2:getOrderListHistory");
	case SOAP_TYPE_lkf2__InsertClientResponse:
		return soap_in_lkf2__InsertClientResponse(soap, tag, NULL, "lkf2:InsertClientResponse");
	case SOAP_TYPE_lkf2__InsertClient:
		return soap_in_lkf2__InsertClient(soap, tag, NULL, "lkf2:InsertClient");
	case SOAP_TYPE_lkf2__getProductListResponse:
		return soap_in_lkf2__getProductListResponse(soap, tag, NULL, "lkf2:getProductListResponse");
	case SOAP_TYPE_lkf2__getProductList:
		return soap_in_lkf2__getProductList(soap, tag, NULL, "lkf2:getProductList");
	case SOAP_TYPE_lkf2__deleteShoppingCartResponse:
		return soap_in_lkf2__deleteShoppingCartResponse(soap, tag, NULL, "lkf2:deleteShoppingCartResponse");
	case SOAP_TYPE_lkf2__deleteShoppingCart:
		return soap_in_lkf2__deleteShoppingCart(soap, tag, NULL, "lkf2:deleteShoppingCart");
	case SOAP_TYPE_lkf2__getClientByNameAndPwdResponse:
		return soap_in_lkf2__getClientByNameAndPwdResponse(soap, tag, NULL, "lkf2:getClientByNameAndPwdResponse");
	case SOAP_TYPE_lkf2__getClientByNameAndPwd:
		return soap_in_lkf2__getClientByNameAndPwd(soap, tag, NULL, "lkf2:getClientByNameAndPwd");
	case SOAP_TYPE_lkf2__addOrderResponse:
		return soap_in_lkf2__addOrderResponse(soap, tag, NULL, "lkf2:addOrderResponse");
	case SOAP_TYPE_lkf2__addOrder:
		return soap_in_lkf2__addOrder(soap, tag, NULL, "lkf2:addOrder");
	case SOAP_TYPE_lkf2__getProductLikeListResponse:
		return soap_in_lkf2__getProductLikeListResponse(soap, tag, NULL, "lkf2:getProductLikeListResponse");
	case SOAP_TYPE_lkf2__getProductLikeList:
		return soap_in_lkf2__getProductLikeList(soap, tag, NULL, "lkf2:getProductLikeList");
	case SOAP_TYPE_lkf2__updateProductByInfoResponse:
		return soap_in_lkf2__updateProductByInfoResponse(soap, tag, NULL, "lkf2:updateProductByInfoResponse");
	case SOAP_TYPE_lkf2__updateProductByInfo:
		return soap_in_lkf2__updateProductByInfo(soap, tag, NULL, "lkf2:updateProductByInfo");
	case SOAP_TYPE_lkf2__addProductTypeResponse:
		return soap_in_lkf2__addProductTypeResponse(soap, tag, NULL, "lkf2:addProductTypeResponse");
	case SOAP_TYPE_lkf2__addProductType:
		return soap_in_lkf2__addProductType(soap, tag, NULL, "lkf2:addProductType");
	case SOAP_TYPE_lkf2__getOrderListByInfoResponse:
		return soap_in_lkf2__getOrderListByInfoResponse(soap, tag, NULL, "lkf2:getOrderListByInfoResponse");
	case SOAP_TYPE_lkf2__getOrderListByInfo:
		return soap_in_lkf2__getOrderListByInfo(soap, tag, NULL, "lkf2:getOrderListByInfo");
	case SOAP_TYPE_lkf2__getClientListResponse:
		return soap_in_lkf2__getClientListResponse(soap, tag, NULL, "lkf2:getClientListResponse");
	case SOAP_TYPE_lkf2__getClientList:
		return soap_in_lkf2__getClientList(soap, tag, NULL, "lkf2:getClientList");
	case SOAP_TYPE_lkf2__productType:
		return soap_in_lkf2__productType(soap, tag, NULL, "lkf2:productType");
	case SOAP_TYPE_lkf2__getProductTypeByProNameResponse:
		return soap_in_lkf2__getProductTypeByProNameResponse(soap, tag, NULL, "lkf2:getProductTypeByProNameResponse");
	case SOAP_TYPE_lkf2__getProductTypeByProName:
		return soap_in_lkf2__getProductTypeByProName(soap, tag, NULL, "lkf2:getProductTypeByProName");
	case SOAP_TYPE_lkf2__getClientLikeListResponse:
		return soap_in_lkf2__getClientLikeListResponse(soap, tag, NULL, "lkf2:getClientLikeListResponse");
	case SOAP_TYPE_lkf2__getClientLikeList:
		return soap_in_lkf2__getClientLikeList(soap, tag, NULL, "lkf2:getClientLikeList");
	case SOAP_TYPE_lkf2__getOrderLikeListResponse:
		return soap_in_lkf2__getOrderLikeListResponse(soap, tag, NULL, "lkf2:getOrderLikeListResponse");
	case SOAP_TYPE_lkf2__getOrderLikeList:
		return soap_in_lkf2__getOrderLikeList(soap, tag, NULL, "lkf2:getOrderLikeList");
	case SOAP_TYPE_lkf2__deleteProductByInfoResponse:
		return soap_in_lkf2__deleteProductByInfoResponse(soap, tag, NULL, "lkf2:deleteProductByInfoResponse");
	case SOAP_TYPE_lkf2__deleteProductByInfo:
		return soap_in_lkf2__deleteProductByInfo(soap, tag, NULL, "lkf2:deleteProductByInfo");
	case SOAP_TYPE_lkf2__deleteClientByNameAndPwdResponse:
		return soap_in_lkf2__deleteClientByNameAndPwdResponse(soap, tag, NULL, "lkf2:deleteClientByNameAndPwdResponse");
	case SOAP_TYPE_lkf2__deleteClientByNameAndPwd:
		return soap_in_lkf2__deleteClientByNameAndPwd(soap, tag, NULL, "lkf2:deleteClientByNameAndPwd");
	case SOAP_TYPE_lkf2__updateClientResponse:
		return soap_in_lkf2__updateClientResponse(soap, tag, NULL, "lkf2:updateClientResponse");
	case SOAP_TYPE_lkf2__client:
		return soap_in_lkf2__client(soap, tag, NULL, "lkf2:client");
	case SOAP_TYPE_lkf2__updateClient:
		return soap_in_lkf2__updateClient(soap, tag, NULL, "lkf2:updateClient");
	case SOAP_TYPE_lkf2__getProductListByInfoResponse:
		return soap_in_lkf2__getProductListByInfoResponse(soap, tag, NULL, "lkf2:getProductListByInfoResponse");
	case SOAP_TYPE_lkf2__getProductListByInfo:
		return soap_in_lkf2__getProductListByInfo(soap, tag, NULL, "lkf2:getProductListByInfo");
	case SOAP_TYPE_lkf2__order:
		return soap_in_lkf2__order(soap, tag, NULL, "lkf2:order");
	case SOAP_TYPE_lkf2__getOrderListResponse:
		return soap_in_lkf2__getOrderListResponse(soap, tag, NULL, "lkf2:getOrderListResponse");
	case SOAP_TYPE_lkf2__getOrderList:
		return soap_in_lkf2__getOrderList(soap, tag, NULL, "lkf2:getOrderList");
	case SOAP_TYPE_lkf2__deleteProductTypeByNameResponse:
		return soap_in_lkf2__deleteProductTypeByNameResponse(soap, tag, NULL, "lkf2:deleteProductTypeByNameResponse");
	case SOAP_TYPE_lkf2__deleteProductTypeByName:
		return soap_in_lkf2__deleteProductTypeByName(soap, tag, NULL, "lkf2:deleteProductTypeByName");
	case SOAP_TYPE_lkf2__addProductResponse:
		return soap_in_lkf2__addProductResponse(soap, tag, NULL, "lkf2:addProductResponse");
	case SOAP_TYPE_lkf2__product:
		return soap_in_lkf2__product(soap, tag, NULL, "lkf2:product");
	case SOAP_TYPE_lkf2__addProduct:
		return soap_in_lkf2__addProduct(soap, tag, NULL, "lkf2:addProduct");
	case SOAP_TYPE_xsd__decimal:
		return soap_in_xsd__decimal(soap, tag, NULL, "xsd:decimal");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, tag, NULL, "xsd:string");
	case SOAP_TYPE_PointerTolkf2__updateHistory:
		return soap_in_PointerTolkf2__updateHistory(soap, tag, NULL, "lkf2:updateHistory");
	case SOAP_TYPE_PointerTolkf2__getOrderListHistory:
		return soap_in_PointerTolkf2__getOrderListHistory(soap, tag, NULL, "lkf2:getOrderListHistory");
	case SOAP_TYPE_PointerTolkf2__InsertClient:
		return soap_in_PointerTolkf2__InsertClient(soap, tag, NULL, "lkf2:InsertClient");
	case SOAP_TYPE_PointerTolkf2__getProductList:
		return soap_in_PointerTolkf2__getProductList(soap, tag, NULL, "lkf2:getProductList");
	case SOAP_TYPE_PointerTolkf2__deleteShoppingCart:
		return soap_in_PointerTolkf2__deleteShoppingCart(soap, tag, NULL, "lkf2:deleteShoppingCart");
	case SOAP_TYPE_PointerTolkf2__getClientByNameAndPwd:
		return soap_in_PointerTolkf2__getClientByNameAndPwd(soap, tag, NULL, "lkf2:getClientByNameAndPwd");
	case SOAP_TYPE_PointerTolkf2__addOrder:
		return soap_in_PointerTolkf2__addOrder(soap, tag, NULL, "lkf2:addOrder");
	case SOAP_TYPE_PointerTolkf2__getProductLikeList:
		return soap_in_PointerTolkf2__getProductLikeList(soap, tag, NULL, "lkf2:getProductLikeList");
	case SOAP_TYPE_PointerTolkf2__updateProductByInfo:
		return soap_in_PointerTolkf2__updateProductByInfo(soap, tag, NULL, "lkf2:updateProductByInfo");
	case SOAP_TYPE_PointerTolkf2__addProductType:
		return soap_in_PointerTolkf2__addProductType(soap, tag, NULL, "lkf2:addProductType");
	case SOAP_TYPE_PointerTolkf2__getOrderListByInfo:
		return soap_in_PointerTolkf2__getOrderListByInfo(soap, tag, NULL, "lkf2:getOrderListByInfo");
	case SOAP_TYPE_PointerTolkf2__getClientList:
		return soap_in_PointerTolkf2__getClientList(soap, tag, NULL, "lkf2:getClientList");
	case SOAP_TYPE_PointerTolkf2__getProductTypeByProName:
		return soap_in_PointerTolkf2__getProductTypeByProName(soap, tag, NULL, "lkf2:getProductTypeByProName");
	case SOAP_TYPE_PointerTolkf2__getClientLikeList:
		return soap_in_PointerTolkf2__getClientLikeList(soap, tag, NULL, "lkf2:getClientLikeList");
	case SOAP_TYPE_PointerTolkf2__getOrderLikeList:
		return soap_in_PointerTolkf2__getOrderLikeList(soap, tag, NULL, "lkf2:getOrderLikeList");
	case SOAP_TYPE_PointerTolkf2__deleteProductByInfo:
		return soap_in_PointerTolkf2__deleteProductByInfo(soap, tag, NULL, "lkf2:deleteProductByInfo");
	case SOAP_TYPE_PointerTolkf2__deleteClientByNameAndPwd:
		return soap_in_PointerTolkf2__deleteClientByNameAndPwd(soap, tag, NULL, "lkf2:deleteClientByNameAndPwd");
	case SOAP_TYPE_PointerTolkf2__updateClient:
		return soap_in_PointerTolkf2__updateClient(soap, tag, NULL, "lkf2:updateClient");
	case SOAP_TYPE_PointerTolkf2__getProductListByInfo:
		return soap_in_PointerTolkf2__getProductListByInfo(soap, tag, NULL, "lkf2:getProductListByInfo");
	case SOAP_TYPE_PointerTolkf2__getOrderList:
		return soap_in_PointerTolkf2__getOrderList(soap, tag, NULL, "lkf2:getOrderList");
	case SOAP_TYPE_PointerTolkf2__deleteProductTypeByName:
		return soap_in_PointerTolkf2__deleteProductTypeByName(soap, tag, NULL, "lkf2:deleteProductTypeByName");
	case SOAP_TYPE_PointerTolkf2__addProduct:
		return soap_in_PointerTolkf2__addProduct(soap, tag, NULL, "lkf2:addProduct");
	case SOAP_TYPE_PointerTolkf2__productType:
		return soap_in_PointerTolkf2__productType(soap, tag, NULL, "lkf2:productType");
	case SOAP_TYPE_PointerTolkf2__client:
		return soap_in_PointerTolkf2__client(soap, tag, NULL, "lkf2:client");
	case SOAP_TYPE_PointerTodateTime:
		return soap_in_PointerTodateTime(soap, tag, NULL, "xsd:dateTime");
	case SOAP_TYPE_PointerToxsd__decimal:
		return soap_in_PointerToxsd__decimal(soap, tag, NULL, "xsd:decimal");
	case SOAP_TYPE_PointerTolkf2__order:
		return soap_in_PointerTolkf2__order(soap, tag, NULL, "lkf2:order");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, tag, NULL, "xsd:string");
	case SOAP_TYPE_PointerTolkf2__product:
		return soap_in_PointerTolkf2__product(soap, tag, NULL, "lkf2:product");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, tag, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, tag, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "lkf2:updateHistoryResponse"))
		{	*type = SOAP_TYPE_lkf2__updateHistoryResponse;
			return soap_in_lkf2__updateHistoryResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "lkf2:updateHistory"))
		{	*type = SOAP_TYPE_lkf2__updateHistory;
			return soap_in_lkf2__updateHistory(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "lkf2:getOrderListHistoryResponse"))
		{	*type = SOAP_TYPE_lkf2__getOrderListHistoryResponse;
			return soap_in_lkf2__getOrderListHistoryResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "lkf2:getOrderListHistory"))
		{	*type = SOAP_TYPE_lkf2__getOrderListHistory;
			return soap_in_lkf2__getOrderListHistory(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "lkf2:InsertClientResponse"))
		{	*type = SOAP_TYPE_lkf2__InsertClientResponse;
			return soap_in_lkf2__InsertClientResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "lkf2:InsertClient"))
		{	*type = SOAP_TYPE_lkf2__InsertClient;
			return soap_in_lkf2__InsertClient(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "lkf2:getProductListResponse"))
		{	*type = SOAP_TYPE_lkf2__getProductListResponse;
			return soap_in_lkf2__getProductListResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "lkf2:getProductList"))
		{	*type = SOAP_TYPE_lkf2__getProductList;
			return soap_in_lkf2__getProductList(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "lkf2:deleteShoppingCartResponse"))
		{	*type = SOAP_TYPE_lkf2__deleteShoppingCartResponse;
			return soap_in_lkf2__deleteShoppingCartResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "lkf2:deleteShoppingCart"))
		{	*type = SOAP_TYPE_lkf2__deleteShoppingCart;
			return soap_in_lkf2__deleteShoppingCart(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "lkf2:getClientByNameAndPwdResponse"))
		{	*type = SOAP_TYPE_lkf2__getClientByNameAndPwdResponse;
			return soap_in_lkf2__getClientByNameAndPwdResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "lkf2:getClientByNameAndPwd"))
		{	*type = SOAP_TYPE_lkf2__getClientByNameAndPwd;
			return soap_in_lkf2__getClientByNameAndPwd(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "lkf2:addOrderResponse"))
		{	*type = SOAP_TYPE_lkf2__addOrderResponse;
			return soap_in_lkf2__addOrderResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "lkf2:addOrder"))
		{	*type = SOAP_TYPE_lkf2__addOrder;
			return soap_in_lkf2__addOrder(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "lkf2:getProductLikeListResponse"))
		{	*type = SOAP_TYPE_lkf2__getProductLikeListResponse;
			return soap_in_lkf2__getProductLikeListResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "lkf2:getProductLikeList"))
		{	*type = SOAP_TYPE_lkf2__getProductLikeList;
			return soap_in_lkf2__getProductLikeList(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "lkf2:updateProductByInfoResponse"))
		{	*type = SOAP_TYPE_lkf2__updateProductByInfoResponse;
			return soap_in_lkf2__updateProductByInfoResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "lkf2:updateProductByInfo"))
		{	*type = SOAP_TYPE_lkf2__updateProductByInfo;
			return soap_in_lkf2__updateProductByInfo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "lkf2:addProductTypeResponse"))
		{	*type = SOAP_TYPE_lkf2__addProductTypeResponse;
			return soap_in_lkf2__addProductTypeResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "lkf2:addProductType"))
		{	*type = SOAP_TYPE_lkf2__addProductType;
			return soap_in_lkf2__addProductType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "lkf2:getOrderListByInfoResponse"))
		{	*type = SOAP_TYPE_lkf2__getOrderListByInfoResponse;
			return soap_in_lkf2__getOrderListByInfoResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "lkf2:getOrderListByInfo"))
		{	*type = SOAP_TYPE_lkf2__getOrderListByInfo;
			return soap_in_lkf2__getOrderListByInfo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "lkf2:getClientListResponse"))
		{	*type = SOAP_TYPE_lkf2__getClientListResponse;
			return soap_in_lkf2__getClientListResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "lkf2:getClientList"))
		{	*type = SOAP_TYPE_lkf2__getClientList;
			return soap_in_lkf2__getClientList(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "lkf2:productType"))
		{	*type = SOAP_TYPE_lkf2__productType;
			return soap_in_lkf2__productType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "lkf2:getProductTypeByProNameResponse"))
		{	*type = SOAP_TYPE_lkf2__getProductTypeByProNameResponse;
			return soap_in_lkf2__getProductTypeByProNameResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "lkf2:getProductTypeByProName"))
		{	*type = SOAP_TYPE_lkf2__getProductTypeByProName;
			return soap_in_lkf2__getProductTypeByProName(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "lkf2:getClientLikeListResponse"))
		{	*type = SOAP_TYPE_lkf2__getClientLikeListResponse;
			return soap_in_lkf2__getClientLikeListResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "lkf2:getClientLikeList"))
		{	*type = SOAP_TYPE_lkf2__getClientLikeList;
			return soap_in_lkf2__getClientLikeList(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "lkf2:getOrderLikeListResponse"))
		{	*type = SOAP_TYPE_lkf2__getOrderLikeListResponse;
			return soap_in_lkf2__getOrderLikeListResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "lkf2:getOrderLikeList"))
		{	*type = SOAP_TYPE_lkf2__getOrderLikeList;
			return soap_in_lkf2__getOrderLikeList(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "lkf2:deleteProductByInfoResponse"))
		{	*type = SOAP_TYPE_lkf2__deleteProductByInfoResponse;
			return soap_in_lkf2__deleteProductByInfoResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "lkf2:deleteProductByInfo"))
		{	*type = SOAP_TYPE_lkf2__deleteProductByInfo;
			return soap_in_lkf2__deleteProductByInfo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "lkf2:deleteClientByNameAndPwdResponse"))
		{	*type = SOAP_TYPE_lkf2__deleteClientByNameAndPwdResponse;
			return soap_in_lkf2__deleteClientByNameAndPwdResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "lkf2:deleteClientByNameAndPwd"))
		{	*type = SOAP_TYPE_lkf2__deleteClientByNameAndPwd;
			return soap_in_lkf2__deleteClientByNameAndPwd(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "lkf2:updateClientResponse"))
		{	*type = SOAP_TYPE_lkf2__updateClientResponse;
			return soap_in_lkf2__updateClientResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "lkf2:client"))
		{	*type = SOAP_TYPE_lkf2__client;
			return soap_in_lkf2__client(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "lkf2:updateClient"))
		{	*type = SOAP_TYPE_lkf2__updateClient;
			return soap_in_lkf2__updateClient(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "lkf2:getProductListByInfoResponse"))
		{	*type = SOAP_TYPE_lkf2__getProductListByInfoResponse;
			return soap_in_lkf2__getProductListByInfoResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "lkf2:getProductListByInfo"))
		{	*type = SOAP_TYPE_lkf2__getProductListByInfo;
			return soap_in_lkf2__getProductListByInfo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "lkf2:order"))
		{	*type = SOAP_TYPE_lkf2__order;
			return soap_in_lkf2__order(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "lkf2:getOrderListResponse"))
		{	*type = SOAP_TYPE_lkf2__getOrderListResponse;
			return soap_in_lkf2__getOrderListResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "lkf2:getOrderList"))
		{	*type = SOAP_TYPE_lkf2__getOrderList;
			return soap_in_lkf2__getOrderList(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "lkf2:deleteProductTypeByNameResponse"))
		{	*type = SOAP_TYPE_lkf2__deleteProductTypeByNameResponse;
			return soap_in_lkf2__deleteProductTypeByNameResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "lkf2:deleteProductTypeByName"))
		{	*type = SOAP_TYPE_lkf2__deleteProductTypeByName;
			return soap_in_lkf2__deleteProductTypeByName(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "lkf2:addProductResponse"))
		{	*type = SOAP_TYPE_lkf2__addProductResponse;
			return soap_in_lkf2__addProductResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "lkf2:product"))
		{	*type = SOAP_TYPE_lkf2__product;
			return soap_in_lkf2__product(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "lkf2:addProduct"))
		{	*type = SOAP_TYPE_lkf2__addProduct;
			return soap_in_lkf2__addProduct(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:decimal"))
		{	*type = SOAP_TYPE_xsd__decimal;
			return soap_in_xsd__decimal(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:float"))
		{	*type = SOAP_TYPE_float;
			return soap_in_float(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_dateTime;
			return soap_in_dateTime(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input at level = %u body = %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other && !soap->fignore)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && !soap->fignore && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, NULL, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body && soap_ignore(soap))
				return soap->error;
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_float:
		return soap_out_float(soap, tag, id, (const float *)ptr, "xsd:float");
	case SOAP_TYPE_dateTime:
		return soap_out_dateTime(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_lkf2__updateHistoryResponse:
		return ((lkf2__updateHistoryResponse *)ptr)->soap_out(soap, tag, id, "lkf2:updateHistoryResponse");
	case SOAP_TYPE_lkf2__updateHistory:
		return ((lkf2__updateHistory *)ptr)->soap_out(soap, tag, id, "lkf2:updateHistory");
	case SOAP_TYPE_lkf2__getOrderListHistoryResponse:
		return ((lkf2__getOrderListHistoryResponse *)ptr)->soap_out(soap, tag, id, "lkf2:getOrderListHistoryResponse");
	case SOAP_TYPE_lkf2__getOrderListHistory:
		return ((lkf2__getOrderListHistory *)ptr)->soap_out(soap, tag, id, "lkf2:getOrderListHistory");
	case SOAP_TYPE_lkf2__InsertClientResponse:
		return ((lkf2__InsertClientResponse *)ptr)->soap_out(soap, tag, id, "lkf2:InsertClientResponse");
	case SOAP_TYPE_lkf2__InsertClient:
		return ((lkf2__InsertClient *)ptr)->soap_out(soap, tag, id, "lkf2:InsertClient");
	case SOAP_TYPE_lkf2__getProductListResponse:
		return ((lkf2__getProductListResponse *)ptr)->soap_out(soap, tag, id, "lkf2:getProductListResponse");
	case SOAP_TYPE_lkf2__getProductList:
		return ((lkf2__getProductList *)ptr)->soap_out(soap, tag, id, "lkf2:getProductList");
	case SOAP_TYPE_lkf2__deleteShoppingCartResponse:
		return ((lkf2__deleteShoppingCartResponse *)ptr)->soap_out(soap, tag, id, "lkf2:deleteShoppingCartResponse");
	case SOAP_TYPE_lkf2__deleteShoppingCart:
		return ((lkf2__deleteShoppingCart *)ptr)->soap_out(soap, tag, id, "lkf2:deleteShoppingCart");
	case SOAP_TYPE_lkf2__getClientByNameAndPwdResponse:
		return ((lkf2__getClientByNameAndPwdResponse *)ptr)->soap_out(soap, tag, id, "lkf2:getClientByNameAndPwdResponse");
	case SOAP_TYPE_lkf2__getClientByNameAndPwd:
		return ((lkf2__getClientByNameAndPwd *)ptr)->soap_out(soap, tag, id, "lkf2:getClientByNameAndPwd");
	case SOAP_TYPE_lkf2__addOrderResponse:
		return ((lkf2__addOrderResponse *)ptr)->soap_out(soap, tag, id, "lkf2:addOrderResponse");
	case SOAP_TYPE_lkf2__addOrder:
		return ((lkf2__addOrder *)ptr)->soap_out(soap, tag, id, "lkf2:addOrder");
	case SOAP_TYPE_lkf2__getProductLikeListResponse:
		return ((lkf2__getProductLikeListResponse *)ptr)->soap_out(soap, tag, id, "lkf2:getProductLikeListResponse");
	case SOAP_TYPE_lkf2__getProductLikeList:
		return ((lkf2__getProductLikeList *)ptr)->soap_out(soap, tag, id, "lkf2:getProductLikeList");
	case SOAP_TYPE_lkf2__updateProductByInfoResponse:
		return ((lkf2__updateProductByInfoResponse *)ptr)->soap_out(soap, tag, id, "lkf2:updateProductByInfoResponse");
	case SOAP_TYPE_lkf2__updateProductByInfo:
		return ((lkf2__updateProductByInfo *)ptr)->soap_out(soap, tag, id, "lkf2:updateProductByInfo");
	case SOAP_TYPE_lkf2__addProductTypeResponse:
		return ((lkf2__addProductTypeResponse *)ptr)->soap_out(soap, tag, id, "lkf2:addProductTypeResponse");
	case SOAP_TYPE_lkf2__addProductType:
		return ((lkf2__addProductType *)ptr)->soap_out(soap, tag, id, "lkf2:addProductType");
	case SOAP_TYPE_lkf2__getOrderListByInfoResponse:
		return ((lkf2__getOrderListByInfoResponse *)ptr)->soap_out(soap, tag, id, "lkf2:getOrderListByInfoResponse");
	case SOAP_TYPE_lkf2__getOrderListByInfo:
		return ((lkf2__getOrderListByInfo *)ptr)->soap_out(soap, tag, id, "lkf2:getOrderListByInfo");
	case SOAP_TYPE_lkf2__getClientListResponse:
		return ((lkf2__getClientListResponse *)ptr)->soap_out(soap, tag, id, "lkf2:getClientListResponse");
	case SOAP_TYPE_lkf2__getClientList:
		return ((lkf2__getClientList *)ptr)->soap_out(soap, tag, id, "lkf2:getClientList");
	case SOAP_TYPE_lkf2__productType:
		return ((lkf2__productType *)ptr)->soap_out(soap, tag, id, "lkf2:productType");
	case SOAP_TYPE_lkf2__getProductTypeByProNameResponse:
		return ((lkf2__getProductTypeByProNameResponse *)ptr)->soap_out(soap, tag, id, "lkf2:getProductTypeByProNameResponse");
	case SOAP_TYPE_lkf2__getProductTypeByProName:
		return ((lkf2__getProductTypeByProName *)ptr)->soap_out(soap, tag, id, "lkf2:getProductTypeByProName");
	case SOAP_TYPE_lkf2__getClientLikeListResponse:
		return ((lkf2__getClientLikeListResponse *)ptr)->soap_out(soap, tag, id, "lkf2:getClientLikeListResponse");
	case SOAP_TYPE_lkf2__getClientLikeList:
		return ((lkf2__getClientLikeList *)ptr)->soap_out(soap, tag, id, "lkf2:getClientLikeList");
	case SOAP_TYPE_lkf2__getOrderLikeListResponse:
		return ((lkf2__getOrderLikeListResponse *)ptr)->soap_out(soap, tag, id, "lkf2:getOrderLikeListResponse");
	case SOAP_TYPE_lkf2__getOrderLikeList:
		return ((lkf2__getOrderLikeList *)ptr)->soap_out(soap, tag, id, "lkf2:getOrderLikeList");
	case SOAP_TYPE_lkf2__deleteProductByInfoResponse:
		return ((lkf2__deleteProductByInfoResponse *)ptr)->soap_out(soap, tag, id, "lkf2:deleteProductByInfoResponse");
	case SOAP_TYPE_lkf2__deleteProductByInfo:
		return ((lkf2__deleteProductByInfo *)ptr)->soap_out(soap, tag, id, "lkf2:deleteProductByInfo");
	case SOAP_TYPE_lkf2__deleteClientByNameAndPwdResponse:
		return ((lkf2__deleteClientByNameAndPwdResponse *)ptr)->soap_out(soap, tag, id, "lkf2:deleteClientByNameAndPwdResponse");
	case SOAP_TYPE_lkf2__deleteClientByNameAndPwd:
		return ((lkf2__deleteClientByNameAndPwd *)ptr)->soap_out(soap, tag, id, "lkf2:deleteClientByNameAndPwd");
	case SOAP_TYPE_lkf2__updateClientResponse:
		return ((lkf2__updateClientResponse *)ptr)->soap_out(soap, tag, id, "lkf2:updateClientResponse");
	case SOAP_TYPE_lkf2__client:
		return ((lkf2__client *)ptr)->soap_out(soap, tag, id, "lkf2:client");
	case SOAP_TYPE_lkf2__updateClient:
		return ((lkf2__updateClient *)ptr)->soap_out(soap, tag, id, "lkf2:updateClient");
	case SOAP_TYPE_lkf2__getProductListByInfoResponse:
		return ((lkf2__getProductListByInfoResponse *)ptr)->soap_out(soap, tag, id, "lkf2:getProductListByInfoResponse");
	case SOAP_TYPE_lkf2__getProductListByInfo:
		return ((lkf2__getProductListByInfo *)ptr)->soap_out(soap, tag, id, "lkf2:getProductListByInfo");
	case SOAP_TYPE_lkf2__order:
		return ((lkf2__order *)ptr)->soap_out(soap, tag, id, "lkf2:order");
	case SOAP_TYPE_lkf2__getOrderListResponse:
		return ((lkf2__getOrderListResponse *)ptr)->soap_out(soap, tag, id, "lkf2:getOrderListResponse");
	case SOAP_TYPE_lkf2__getOrderList:
		return ((lkf2__getOrderList *)ptr)->soap_out(soap, tag, id, "lkf2:getOrderList");
	case SOAP_TYPE_lkf2__deleteProductTypeByNameResponse:
		return ((lkf2__deleteProductTypeByNameResponse *)ptr)->soap_out(soap, tag, id, "lkf2:deleteProductTypeByNameResponse");
	case SOAP_TYPE_lkf2__deleteProductTypeByName:
		return ((lkf2__deleteProductTypeByName *)ptr)->soap_out(soap, tag, id, "lkf2:deleteProductTypeByName");
	case SOAP_TYPE_lkf2__addProductResponse:
		return ((lkf2__addProductResponse *)ptr)->soap_out(soap, tag, id, "lkf2:addProductResponse");
	case SOAP_TYPE_lkf2__product:
		return ((lkf2__product *)ptr)->soap_out(soap, tag, id, "lkf2:product");
	case SOAP_TYPE_lkf2__addProduct:
		return ((lkf2__addProduct *)ptr)->soap_out(soap, tag, id, "lkf2:addProduct");
	case SOAP_TYPE_xsd__decimal:
		return soap_out_xsd__decimal(soap, tag, id, (const std::string *)ptr, "xsd:decimal");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_PointerTolkf2__updateHistory:
		return soap_out_PointerTolkf2__updateHistory(soap, tag, id, (lkf2__updateHistory *const*)ptr, "lkf2:updateHistory");
	case SOAP_TYPE_PointerTolkf2__getOrderListHistory:
		return soap_out_PointerTolkf2__getOrderListHistory(soap, tag, id, (lkf2__getOrderListHistory *const*)ptr, "lkf2:getOrderListHistory");
	case SOAP_TYPE_PointerTolkf2__InsertClient:
		return soap_out_PointerTolkf2__InsertClient(soap, tag, id, (lkf2__InsertClient *const*)ptr, "lkf2:InsertClient");
	case SOAP_TYPE_PointerTolkf2__getProductList:
		return soap_out_PointerTolkf2__getProductList(soap, tag, id, (lkf2__getProductList *const*)ptr, "lkf2:getProductList");
	case SOAP_TYPE_PointerTolkf2__deleteShoppingCart:
		return soap_out_PointerTolkf2__deleteShoppingCart(soap, tag, id, (lkf2__deleteShoppingCart *const*)ptr, "lkf2:deleteShoppingCart");
	case SOAP_TYPE_PointerTolkf2__getClientByNameAndPwd:
		return soap_out_PointerTolkf2__getClientByNameAndPwd(soap, tag, id, (lkf2__getClientByNameAndPwd *const*)ptr, "lkf2:getClientByNameAndPwd");
	case SOAP_TYPE_PointerTolkf2__addOrder:
		return soap_out_PointerTolkf2__addOrder(soap, tag, id, (lkf2__addOrder *const*)ptr, "lkf2:addOrder");
	case SOAP_TYPE_PointerTolkf2__getProductLikeList:
		return soap_out_PointerTolkf2__getProductLikeList(soap, tag, id, (lkf2__getProductLikeList *const*)ptr, "lkf2:getProductLikeList");
	case SOAP_TYPE_PointerTolkf2__updateProductByInfo:
		return soap_out_PointerTolkf2__updateProductByInfo(soap, tag, id, (lkf2__updateProductByInfo *const*)ptr, "lkf2:updateProductByInfo");
	case SOAP_TYPE_PointerTolkf2__addProductType:
		return soap_out_PointerTolkf2__addProductType(soap, tag, id, (lkf2__addProductType *const*)ptr, "lkf2:addProductType");
	case SOAP_TYPE_PointerTolkf2__getOrderListByInfo:
		return soap_out_PointerTolkf2__getOrderListByInfo(soap, tag, id, (lkf2__getOrderListByInfo *const*)ptr, "lkf2:getOrderListByInfo");
	case SOAP_TYPE_PointerTolkf2__getClientList:
		return soap_out_PointerTolkf2__getClientList(soap, tag, id, (lkf2__getClientList *const*)ptr, "lkf2:getClientList");
	case SOAP_TYPE_PointerTolkf2__getProductTypeByProName:
		return soap_out_PointerTolkf2__getProductTypeByProName(soap, tag, id, (lkf2__getProductTypeByProName *const*)ptr, "lkf2:getProductTypeByProName");
	case SOAP_TYPE_PointerTolkf2__getClientLikeList:
		return soap_out_PointerTolkf2__getClientLikeList(soap, tag, id, (lkf2__getClientLikeList *const*)ptr, "lkf2:getClientLikeList");
	case SOAP_TYPE_PointerTolkf2__getOrderLikeList:
		return soap_out_PointerTolkf2__getOrderLikeList(soap, tag, id, (lkf2__getOrderLikeList *const*)ptr, "lkf2:getOrderLikeList");
	case SOAP_TYPE_PointerTolkf2__deleteProductByInfo:
		return soap_out_PointerTolkf2__deleteProductByInfo(soap, tag, id, (lkf2__deleteProductByInfo *const*)ptr, "lkf2:deleteProductByInfo");
	case SOAP_TYPE_PointerTolkf2__deleteClientByNameAndPwd:
		return soap_out_PointerTolkf2__deleteClientByNameAndPwd(soap, tag, id, (lkf2__deleteClientByNameAndPwd *const*)ptr, "lkf2:deleteClientByNameAndPwd");
	case SOAP_TYPE_PointerTolkf2__updateClient:
		return soap_out_PointerTolkf2__updateClient(soap, tag, id, (lkf2__updateClient *const*)ptr, "lkf2:updateClient");
	case SOAP_TYPE_PointerTolkf2__getProductListByInfo:
		return soap_out_PointerTolkf2__getProductListByInfo(soap, tag, id, (lkf2__getProductListByInfo *const*)ptr, "lkf2:getProductListByInfo");
	case SOAP_TYPE_PointerTolkf2__getOrderList:
		return soap_out_PointerTolkf2__getOrderList(soap, tag, id, (lkf2__getOrderList *const*)ptr, "lkf2:getOrderList");
	case SOAP_TYPE_PointerTolkf2__deleteProductTypeByName:
		return soap_out_PointerTolkf2__deleteProductTypeByName(soap, tag, id, (lkf2__deleteProductTypeByName *const*)ptr, "lkf2:deleteProductTypeByName");
	case SOAP_TYPE_PointerTolkf2__addProduct:
		return soap_out_PointerTolkf2__addProduct(soap, tag, id, (lkf2__addProduct *const*)ptr, "lkf2:addProduct");
	case SOAP_TYPE_PointerTolkf2__productType:
		return soap_out_PointerTolkf2__productType(soap, tag, id, (lkf2__productType *const*)ptr, "lkf2:productType");
	case SOAP_TYPE_PointerTolkf2__client:
		return soap_out_PointerTolkf2__client(soap, tag, id, (lkf2__client *const*)ptr, "lkf2:client");
	case SOAP_TYPE_PointerTodateTime:
		return soap_out_PointerTodateTime(soap, tag, id, (time_t *const*)ptr, "xsd:dateTime");
	case SOAP_TYPE_PointerToxsd__decimal:
		return soap_out_PointerToxsd__decimal(soap, tag, id, (std::string *const*)ptr, "xsd:decimal");
	case SOAP_TYPE_PointerTolkf2__order:
		return soap_out_PointerTolkf2__order(soap, tag, id, (lkf2__order *const*)ptr, "lkf2:order");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTolkf2__product:
		return soap_out_PointerTolkf2__product(soap, tag, id, (lkf2__product *const*)ptr, "lkf2:product");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	case 0:
		return SOAP_OK;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_putelement '%s' failed for type %d in soapC.cpp\n", tag ? tag : "", type));
	return soap_element_empty(soap, tag, 0, NULL); /* unknown type to serialize */
}
#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_lkf2__updateHistoryResponse:
		((lkf2__updateHistoryResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_lkf2__updateHistory:
		((lkf2__updateHistory *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_lkf2__getOrderListHistoryResponse:
		((lkf2__getOrderListHistoryResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_lkf2__getOrderListHistory:
		((lkf2__getOrderListHistory *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_lkf2__InsertClientResponse:
		((lkf2__InsertClientResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_lkf2__InsertClient:
		((lkf2__InsertClient *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_lkf2__getProductListResponse:
		((lkf2__getProductListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_lkf2__getProductList:
		((lkf2__getProductList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_lkf2__deleteShoppingCartResponse:
		((lkf2__deleteShoppingCartResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_lkf2__deleteShoppingCart:
		((lkf2__deleteShoppingCart *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_lkf2__getClientByNameAndPwdResponse:
		((lkf2__getClientByNameAndPwdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_lkf2__getClientByNameAndPwd:
		((lkf2__getClientByNameAndPwd *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_lkf2__addOrderResponse:
		((lkf2__addOrderResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_lkf2__addOrder:
		((lkf2__addOrder *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_lkf2__getProductLikeListResponse:
		((lkf2__getProductLikeListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_lkf2__getProductLikeList:
		((lkf2__getProductLikeList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_lkf2__updateProductByInfoResponse:
		((lkf2__updateProductByInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_lkf2__updateProductByInfo:
		((lkf2__updateProductByInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_lkf2__addProductTypeResponse:
		((lkf2__addProductTypeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_lkf2__addProductType:
		((lkf2__addProductType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_lkf2__getOrderListByInfoResponse:
		((lkf2__getOrderListByInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_lkf2__getOrderListByInfo:
		((lkf2__getOrderListByInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_lkf2__getClientListResponse:
		((lkf2__getClientListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_lkf2__getClientList:
		((lkf2__getClientList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_lkf2__productType:
		((lkf2__productType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_lkf2__getProductTypeByProNameResponse:
		((lkf2__getProductTypeByProNameResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_lkf2__getProductTypeByProName:
		((lkf2__getProductTypeByProName *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_lkf2__getClientLikeListResponse:
		((lkf2__getClientLikeListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_lkf2__getClientLikeList:
		((lkf2__getClientLikeList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_lkf2__getOrderLikeListResponse:
		((lkf2__getOrderLikeListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_lkf2__getOrderLikeList:
		((lkf2__getOrderLikeList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_lkf2__deleteProductByInfoResponse:
		((lkf2__deleteProductByInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_lkf2__deleteProductByInfo:
		((lkf2__deleteProductByInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_lkf2__deleteClientByNameAndPwdResponse:
		((lkf2__deleteClientByNameAndPwdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_lkf2__deleteClientByNameAndPwd:
		((lkf2__deleteClientByNameAndPwd *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_lkf2__updateClientResponse:
		((lkf2__updateClientResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_lkf2__client:
		((lkf2__client *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_lkf2__updateClient:
		((lkf2__updateClient *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_lkf2__getProductListByInfoResponse:
		((lkf2__getProductListByInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_lkf2__getProductListByInfo:
		((lkf2__getProductListByInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_lkf2__order:
		((lkf2__order *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_lkf2__getOrderListResponse:
		((lkf2__getOrderListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_lkf2__getOrderList:
		((lkf2__getOrderList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_lkf2__deleteProductTypeByNameResponse:
		((lkf2__deleteProductTypeByNameResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_lkf2__deleteProductTypeByName:
		((lkf2__deleteProductTypeByName *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_lkf2__addProductResponse:
		((lkf2__addProductResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_lkf2__product:
		((lkf2__product *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_lkf2__addProduct:
		((lkf2__addProduct *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__decimal:
		soap_serialize_xsd__decimal(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE___lkf1__updateHistory:
		soap_serialize___lkf1__updateHistory(soap, (const struct __lkf1__updateHistory *)ptr);
		break;
	case SOAP_TYPE___lkf1__getOrderListHistory:
		soap_serialize___lkf1__getOrderListHistory(soap, (const struct __lkf1__getOrderListHistory *)ptr);
		break;
	case SOAP_TYPE___lkf1__InsertClient:
		soap_serialize___lkf1__InsertClient(soap, (const struct __lkf1__InsertClient *)ptr);
		break;
	case SOAP_TYPE___lkf1__getProductList:
		soap_serialize___lkf1__getProductList(soap, (const struct __lkf1__getProductList *)ptr);
		break;
	case SOAP_TYPE___lkf1__deleteShoppingCart:
		soap_serialize___lkf1__deleteShoppingCart(soap, (const struct __lkf1__deleteShoppingCart *)ptr);
		break;
	case SOAP_TYPE___lkf1__getClientByNameAndPwd:
		soap_serialize___lkf1__getClientByNameAndPwd(soap, (const struct __lkf1__getClientByNameAndPwd *)ptr);
		break;
	case SOAP_TYPE___lkf1__addOrder:
		soap_serialize___lkf1__addOrder(soap, (const struct __lkf1__addOrder *)ptr);
		break;
	case SOAP_TYPE___lkf1__getProductLikeList:
		soap_serialize___lkf1__getProductLikeList(soap, (const struct __lkf1__getProductLikeList *)ptr);
		break;
	case SOAP_TYPE___lkf1__updateProductByInfo:
		soap_serialize___lkf1__updateProductByInfo(soap, (const struct __lkf1__updateProductByInfo *)ptr);
		break;
	case SOAP_TYPE___lkf1__addProductType:
		soap_serialize___lkf1__addProductType(soap, (const struct __lkf1__addProductType *)ptr);
		break;
	case SOAP_TYPE___lkf1__getOrderListByInfo:
		soap_serialize___lkf1__getOrderListByInfo(soap, (const struct __lkf1__getOrderListByInfo *)ptr);
		break;
	case SOAP_TYPE___lkf1__getClientList:
		soap_serialize___lkf1__getClientList(soap, (const struct __lkf1__getClientList *)ptr);
		break;
	case SOAP_TYPE___lkf1__getProductTypeByProName:
		soap_serialize___lkf1__getProductTypeByProName(soap, (const struct __lkf1__getProductTypeByProName *)ptr);
		break;
	case SOAP_TYPE___lkf1__getClientLikeList:
		soap_serialize___lkf1__getClientLikeList(soap, (const struct __lkf1__getClientLikeList *)ptr);
		break;
	case SOAP_TYPE___lkf1__getOrderLikeList:
		soap_serialize___lkf1__getOrderLikeList(soap, (const struct __lkf1__getOrderLikeList *)ptr);
		break;
	case SOAP_TYPE___lkf1__deleteProductByInfo:
		soap_serialize___lkf1__deleteProductByInfo(soap, (const struct __lkf1__deleteProductByInfo *)ptr);
		break;
	case SOAP_TYPE___lkf1__deleteClientByNameAndPwd:
		soap_serialize___lkf1__deleteClientByNameAndPwd(soap, (const struct __lkf1__deleteClientByNameAndPwd *)ptr);
		break;
	case SOAP_TYPE___lkf1__updateClient:
		soap_serialize___lkf1__updateClient(soap, (const struct __lkf1__updateClient *)ptr);
		break;
	case SOAP_TYPE___lkf1__getProductListByInfo:
		soap_serialize___lkf1__getProductListByInfo(soap, (const struct __lkf1__getProductListByInfo *)ptr);
		break;
	case SOAP_TYPE___lkf1__getOrderList:
		soap_serialize___lkf1__getOrderList(soap, (const struct __lkf1__getOrderList *)ptr);
		break;
	case SOAP_TYPE___lkf1__deleteProductTypeByName:
		soap_serialize___lkf1__deleteProductTypeByName(soap, (const struct __lkf1__deleteProductTypeByName *)ptr);
		break;
	case SOAP_TYPE___lkf1__addProduct:
		soap_serialize___lkf1__addProduct(soap, (const struct __lkf1__addProduct *)ptr);
		break;
	case SOAP_TYPE_PointerTolkf2__updateHistory:
		soap_serialize_PointerTolkf2__updateHistory(soap, (lkf2__updateHistory *const*)ptr);
		break;
	case SOAP_TYPE_PointerTolkf2__getOrderListHistory:
		soap_serialize_PointerTolkf2__getOrderListHistory(soap, (lkf2__getOrderListHistory *const*)ptr);
		break;
	case SOAP_TYPE_PointerTolkf2__InsertClient:
		soap_serialize_PointerTolkf2__InsertClient(soap, (lkf2__InsertClient *const*)ptr);
		break;
	case SOAP_TYPE_PointerTolkf2__getProductList:
		soap_serialize_PointerTolkf2__getProductList(soap, (lkf2__getProductList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTolkf2__deleteShoppingCart:
		soap_serialize_PointerTolkf2__deleteShoppingCart(soap, (lkf2__deleteShoppingCart *const*)ptr);
		break;
	case SOAP_TYPE_PointerTolkf2__getClientByNameAndPwd:
		soap_serialize_PointerTolkf2__getClientByNameAndPwd(soap, (lkf2__getClientByNameAndPwd *const*)ptr);
		break;
	case SOAP_TYPE_PointerTolkf2__addOrder:
		soap_serialize_PointerTolkf2__addOrder(soap, (lkf2__addOrder *const*)ptr);
		break;
	case SOAP_TYPE_PointerTolkf2__getProductLikeList:
		soap_serialize_PointerTolkf2__getProductLikeList(soap, (lkf2__getProductLikeList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTolkf2__updateProductByInfo:
		soap_serialize_PointerTolkf2__updateProductByInfo(soap, (lkf2__updateProductByInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTolkf2__addProductType:
		soap_serialize_PointerTolkf2__addProductType(soap, (lkf2__addProductType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTolkf2__getOrderListByInfo:
		soap_serialize_PointerTolkf2__getOrderListByInfo(soap, (lkf2__getOrderListByInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTolkf2__getClientList:
		soap_serialize_PointerTolkf2__getClientList(soap, (lkf2__getClientList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTolkf2__getProductTypeByProName:
		soap_serialize_PointerTolkf2__getProductTypeByProName(soap, (lkf2__getProductTypeByProName *const*)ptr);
		break;
	case SOAP_TYPE_PointerTolkf2__getClientLikeList:
		soap_serialize_PointerTolkf2__getClientLikeList(soap, (lkf2__getClientLikeList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTolkf2__getOrderLikeList:
		soap_serialize_PointerTolkf2__getOrderLikeList(soap, (lkf2__getOrderLikeList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTolkf2__deleteProductByInfo:
		soap_serialize_PointerTolkf2__deleteProductByInfo(soap, (lkf2__deleteProductByInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTolkf2__deleteClientByNameAndPwd:
		soap_serialize_PointerTolkf2__deleteClientByNameAndPwd(soap, (lkf2__deleteClientByNameAndPwd *const*)ptr);
		break;
	case SOAP_TYPE_PointerTolkf2__updateClient:
		soap_serialize_PointerTolkf2__updateClient(soap, (lkf2__updateClient *const*)ptr);
		break;
	case SOAP_TYPE_PointerTolkf2__getProductListByInfo:
		soap_serialize_PointerTolkf2__getProductListByInfo(soap, (lkf2__getProductListByInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTolkf2__getOrderList:
		soap_serialize_PointerTolkf2__getOrderList(soap, (lkf2__getOrderList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTolkf2__deleteProductTypeByName:
		soap_serialize_PointerTolkf2__deleteProductTypeByName(soap, (lkf2__deleteProductTypeByName *const*)ptr);
		break;
	case SOAP_TYPE_PointerTolkf2__addProduct:
		soap_serialize_PointerTolkf2__addProduct(soap, (lkf2__addProduct *const*)ptr);
		break;
	case SOAP_TYPE_PointerTolkf2__productType:
		soap_serialize_PointerTolkf2__productType(soap, (lkf2__productType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTolkf2__client:
		soap_serialize_PointerTolkf2__client(soap, (lkf2__client *const*)ptr);
		break;
	case SOAP_TYPE_PointerTodateTime:
		soap_serialize_PointerTodateTime(soap, (time_t *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__decimal:
		soap_serialize_PointerToxsd__decimal(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTolkf2__order:
		soap_serialize_PointerTolkf2__order(soap, (lkf2__order *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTolkf2__product:
		soap_serialize_PointerTolkf2__product(soap, (lkf2__product *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}
#ifdef __cplusplus
}
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_dupelement(struct soap *soap, const void *ptr, int type)
{(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	return NULL;
}
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_delelement(const void *ptr, int type)
{(void)ptr; (void)type; /* appease -Wall -Werror */
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_lkf2__addProduct:
		return (void*)soap_instantiate_lkf2__addProduct(soap, -1, type, arrayType, n);
	case SOAP_TYPE_lkf2__product:
		return (void*)soap_instantiate_lkf2__product(soap, -1, type, arrayType, n);
	case SOAP_TYPE_lkf2__addProductResponse:
		return (void*)soap_instantiate_lkf2__addProductResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_lkf2__deleteProductTypeByName:
		return (void*)soap_instantiate_lkf2__deleteProductTypeByName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_lkf2__deleteProductTypeByNameResponse:
		return (void*)soap_instantiate_lkf2__deleteProductTypeByNameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_lkf2__getOrderList:
		return (void*)soap_instantiate_lkf2__getOrderList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_lkf2__getOrderListResponse:
		return (void*)soap_instantiate_lkf2__getOrderListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_lkf2__order:
		return (void*)soap_instantiate_lkf2__order(soap, -1, type, arrayType, n);
	case SOAP_TYPE_lkf2__getProductListByInfo:
		return (void*)soap_instantiate_lkf2__getProductListByInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_lkf2__getProductListByInfoResponse:
		return (void*)soap_instantiate_lkf2__getProductListByInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_lkf2__updateClient:
		return (void*)soap_instantiate_lkf2__updateClient(soap, -1, type, arrayType, n);
	case SOAP_TYPE_lkf2__client:
		return (void*)soap_instantiate_lkf2__client(soap, -1, type, arrayType, n);
	case SOAP_TYPE_lkf2__updateClientResponse:
		return (void*)soap_instantiate_lkf2__updateClientResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_lkf2__deleteClientByNameAndPwd:
		return (void*)soap_instantiate_lkf2__deleteClientByNameAndPwd(soap, -1, type, arrayType, n);
	case SOAP_TYPE_lkf2__deleteClientByNameAndPwdResponse:
		return (void*)soap_instantiate_lkf2__deleteClientByNameAndPwdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_lkf2__deleteProductByInfo:
		return (void*)soap_instantiate_lkf2__deleteProductByInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_lkf2__deleteProductByInfoResponse:
		return (void*)soap_instantiate_lkf2__deleteProductByInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_lkf2__getOrderLikeList:
		return (void*)soap_instantiate_lkf2__getOrderLikeList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_lkf2__getOrderLikeListResponse:
		return (void*)soap_instantiate_lkf2__getOrderLikeListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_lkf2__getClientLikeList:
		return (void*)soap_instantiate_lkf2__getClientLikeList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_lkf2__getClientLikeListResponse:
		return (void*)soap_instantiate_lkf2__getClientLikeListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_lkf2__getProductTypeByProName:
		return (void*)soap_instantiate_lkf2__getProductTypeByProName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_lkf2__getProductTypeByProNameResponse:
		return (void*)soap_instantiate_lkf2__getProductTypeByProNameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_lkf2__productType:
		return (void*)soap_instantiate_lkf2__productType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_lkf2__getClientList:
		return (void*)soap_instantiate_lkf2__getClientList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_lkf2__getClientListResponse:
		return (void*)soap_instantiate_lkf2__getClientListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_lkf2__getOrderListByInfo:
		return (void*)soap_instantiate_lkf2__getOrderListByInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_lkf2__getOrderListByInfoResponse:
		return (void*)soap_instantiate_lkf2__getOrderListByInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_lkf2__addProductType:
		return (void*)soap_instantiate_lkf2__addProductType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_lkf2__addProductTypeResponse:
		return (void*)soap_instantiate_lkf2__addProductTypeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_lkf2__updateProductByInfo:
		return (void*)soap_instantiate_lkf2__updateProductByInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_lkf2__updateProductByInfoResponse:
		return (void*)soap_instantiate_lkf2__updateProductByInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_lkf2__getProductLikeList:
		return (void*)soap_instantiate_lkf2__getProductLikeList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_lkf2__getProductLikeListResponse:
		return (void*)soap_instantiate_lkf2__getProductLikeListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_lkf2__addOrder:
		return (void*)soap_instantiate_lkf2__addOrder(soap, -1, type, arrayType, n);
	case SOAP_TYPE_lkf2__addOrderResponse:
		return (void*)soap_instantiate_lkf2__addOrderResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_lkf2__getClientByNameAndPwd:
		return (void*)soap_instantiate_lkf2__getClientByNameAndPwd(soap, -1, type, arrayType, n);
	case SOAP_TYPE_lkf2__getClientByNameAndPwdResponse:
		return (void*)soap_instantiate_lkf2__getClientByNameAndPwdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_lkf2__deleteShoppingCart:
		return (void*)soap_instantiate_lkf2__deleteShoppingCart(soap, -1, type, arrayType, n);
	case SOAP_TYPE_lkf2__deleteShoppingCartResponse:
		return (void*)soap_instantiate_lkf2__deleteShoppingCartResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_lkf2__getProductList:
		return (void*)soap_instantiate_lkf2__getProductList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_lkf2__getProductListResponse:
		return (void*)soap_instantiate_lkf2__getProductListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_lkf2__InsertClient:
		return (void*)soap_instantiate_lkf2__InsertClient(soap, -1, type, arrayType, n);
	case SOAP_TYPE_lkf2__InsertClientResponse:
		return (void*)soap_instantiate_lkf2__InsertClientResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_lkf2__getOrderListHistory:
		return (void*)soap_instantiate_lkf2__getOrderListHistory(soap, -1, type, arrayType, n);
	case SOAP_TYPE_lkf2__getOrderListHistoryResponse:
		return (void*)soap_instantiate_lkf2__getOrderListHistoryResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_lkf2__updateHistory:
		return (void*)soap_instantiate_lkf2__updateHistory(soap, -1, type, arrayType, n);
	case SOAP_TYPE_lkf2__updateHistoryResponse:
		return (void*)soap_instantiate_lkf2__updateHistoryResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___lkf1__addProduct:
		return (void*)soap_instantiate___lkf1__addProduct(soap, -1, type, arrayType, n);
	case SOAP_TYPE___lkf1__deleteProductTypeByName:
		return (void*)soap_instantiate___lkf1__deleteProductTypeByName(soap, -1, type, arrayType, n);
	case SOAP_TYPE___lkf1__getOrderList:
		return (void*)soap_instantiate___lkf1__getOrderList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___lkf1__getProductListByInfo:
		return (void*)soap_instantiate___lkf1__getProductListByInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___lkf1__updateClient:
		return (void*)soap_instantiate___lkf1__updateClient(soap, -1, type, arrayType, n);
	case SOAP_TYPE___lkf1__deleteClientByNameAndPwd:
		return (void*)soap_instantiate___lkf1__deleteClientByNameAndPwd(soap, -1, type, arrayType, n);
	case SOAP_TYPE___lkf1__deleteProductByInfo:
		return (void*)soap_instantiate___lkf1__deleteProductByInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___lkf1__getOrderLikeList:
		return (void*)soap_instantiate___lkf1__getOrderLikeList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___lkf1__getClientLikeList:
		return (void*)soap_instantiate___lkf1__getClientLikeList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___lkf1__getProductTypeByProName:
		return (void*)soap_instantiate___lkf1__getProductTypeByProName(soap, -1, type, arrayType, n);
	case SOAP_TYPE___lkf1__getClientList:
		return (void*)soap_instantiate___lkf1__getClientList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___lkf1__getOrderListByInfo:
		return (void*)soap_instantiate___lkf1__getOrderListByInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___lkf1__addProductType:
		return (void*)soap_instantiate___lkf1__addProductType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___lkf1__updateProductByInfo:
		return (void*)soap_instantiate___lkf1__updateProductByInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___lkf1__getProductLikeList:
		return (void*)soap_instantiate___lkf1__getProductLikeList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___lkf1__addOrder:
		return (void*)soap_instantiate___lkf1__addOrder(soap, -1, type, arrayType, n);
	case SOAP_TYPE___lkf1__getClientByNameAndPwd:
		return (void*)soap_instantiate___lkf1__getClientByNameAndPwd(soap, -1, type, arrayType, n);
	case SOAP_TYPE___lkf1__deleteShoppingCart:
		return (void*)soap_instantiate___lkf1__deleteShoppingCart(soap, -1, type, arrayType, n);
	case SOAP_TYPE___lkf1__getProductList:
		return (void*)soap_instantiate___lkf1__getProductList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___lkf1__InsertClient:
		return (void*)soap_instantiate___lkf1__InsertClient(soap, -1, type, arrayType, n);
	case SOAP_TYPE___lkf1__getOrderListHistory:
		return (void*)soap_instantiate___lkf1__getOrderListHistory(soap, -1, type, arrayType, n);
	case SOAP_TYPE___lkf1__updateHistory:
		return (void*)soap_instantiate___lkf1__updateHistory(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_xsd__decimal:
		return (void*)soap_instantiate_xsd__decimal(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTolkf2__productType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTolkf2__productType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTolkf2__client:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTolkf2__client(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTolkf2__product:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTolkf2__product(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTolkf2__order:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTolkf2__order(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap *soap, struct soap_clist *p)
{
	(void)soap; /* appease -Wall -Werror */
	if (!p->ptr)
		return SOAP_OK;
	switch (p->type)
	{
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_lkf2__addProduct:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<lkf2__addProduct*>(p->ptr), lkf2__addProduct);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<lkf2__addProduct*>(p->ptr), lkf2__addProduct);
		break;
	case SOAP_TYPE_lkf2__product:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<lkf2__product*>(p->ptr), lkf2__product);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<lkf2__product*>(p->ptr), lkf2__product);
		break;
	case SOAP_TYPE_lkf2__addProductResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<lkf2__addProductResponse*>(p->ptr), lkf2__addProductResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<lkf2__addProductResponse*>(p->ptr), lkf2__addProductResponse);
		break;
	case SOAP_TYPE_lkf2__deleteProductTypeByName:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<lkf2__deleteProductTypeByName*>(p->ptr), lkf2__deleteProductTypeByName);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<lkf2__deleteProductTypeByName*>(p->ptr), lkf2__deleteProductTypeByName);
		break;
	case SOAP_TYPE_lkf2__deleteProductTypeByNameResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<lkf2__deleteProductTypeByNameResponse*>(p->ptr), lkf2__deleteProductTypeByNameResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<lkf2__deleteProductTypeByNameResponse*>(p->ptr), lkf2__deleteProductTypeByNameResponse);
		break;
	case SOAP_TYPE_lkf2__getOrderList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<lkf2__getOrderList*>(p->ptr), lkf2__getOrderList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<lkf2__getOrderList*>(p->ptr), lkf2__getOrderList);
		break;
	case SOAP_TYPE_lkf2__getOrderListResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<lkf2__getOrderListResponse*>(p->ptr), lkf2__getOrderListResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<lkf2__getOrderListResponse*>(p->ptr), lkf2__getOrderListResponse);
		break;
	case SOAP_TYPE_lkf2__order:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<lkf2__order*>(p->ptr), lkf2__order);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<lkf2__order*>(p->ptr), lkf2__order);
		break;
	case SOAP_TYPE_lkf2__getProductListByInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<lkf2__getProductListByInfo*>(p->ptr), lkf2__getProductListByInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<lkf2__getProductListByInfo*>(p->ptr), lkf2__getProductListByInfo);
		break;
	case SOAP_TYPE_lkf2__getProductListByInfoResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<lkf2__getProductListByInfoResponse*>(p->ptr), lkf2__getProductListByInfoResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<lkf2__getProductListByInfoResponse*>(p->ptr), lkf2__getProductListByInfoResponse);
		break;
	case SOAP_TYPE_lkf2__updateClient:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<lkf2__updateClient*>(p->ptr), lkf2__updateClient);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<lkf2__updateClient*>(p->ptr), lkf2__updateClient);
		break;
	case SOAP_TYPE_lkf2__client:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<lkf2__client*>(p->ptr), lkf2__client);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<lkf2__client*>(p->ptr), lkf2__client);
		break;
	case SOAP_TYPE_lkf2__updateClientResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<lkf2__updateClientResponse*>(p->ptr), lkf2__updateClientResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<lkf2__updateClientResponse*>(p->ptr), lkf2__updateClientResponse);
		break;
	case SOAP_TYPE_lkf2__deleteClientByNameAndPwd:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<lkf2__deleteClientByNameAndPwd*>(p->ptr), lkf2__deleteClientByNameAndPwd);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<lkf2__deleteClientByNameAndPwd*>(p->ptr), lkf2__deleteClientByNameAndPwd);
		break;
	case SOAP_TYPE_lkf2__deleteClientByNameAndPwdResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<lkf2__deleteClientByNameAndPwdResponse*>(p->ptr), lkf2__deleteClientByNameAndPwdResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<lkf2__deleteClientByNameAndPwdResponse*>(p->ptr), lkf2__deleteClientByNameAndPwdResponse);
		break;
	case SOAP_TYPE_lkf2__deleteProductByInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<lkf2__deleteProductByInfo*>(p->ptr), lkf2__deleteProductByInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<lkf2__deleteProductByInfo*>(p->ptr), lkf2__deleteProductByInfo);
		break;
	case SOAP_TYPE_lkf2__deleteProductByInfoResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<lkf2__deleteProductByInfoResponse*>(p->ptr), lkf2__deleteProductByInfoResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<lkf2__deleteProductByInfoResponse*>(p->ptr), lkf2__deleteProductByInfoResponse);
		break;
	case SOAP_TYPE_lkf2__getOrderLikeList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<lkf2__getOrderLikeList*>(p->ptr), lkf2__getOrderLikeList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<lkf2__getOrderLikeList*>(p->ptr), lkf2__getOrderLikeList);
		break;
	case SOAP_TYPE_lkf2__getOrderLikeListResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<lkf2__getOrderLikeListResponse*>(p->ptr), lkf2__getOrderLikeListResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<lkf2__getOrderLikeListResponse*>(p->ptr), lkf2__getOrderLikeListResponse);
		break;
	case SOAP_TYPE_lkf2__getClientLikeList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<lkf2__getClientLikeList*>(p->ptr), lkf2__getClientLikeList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<lkf2__getClientLikeList*>(p->ptr), lkf2__getClientLikeList);
		break;
	case SOAP_TYPE_lkf2__getClientLikeListResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<lkf2__getClientLikeListResponse*>(p->ptr), lkf2__getClientLikeListResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<lkf2__getClientLikeListResponse*>(p->ptr), lkf2__getClientLikeListResponse);
		break;
	case SOAP_TYPE_lkf2__getProductTypeByProName:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<lkf2__getProductTypeByProName*>(p->ptr), lkf2__getProductTypeByProName);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<lkf2__getProductTypeByProName*>(p->ptr), lkf2__getProductTypeByProName);
		break;
	case SOAP_TYPE_lkf2__getProductTypeByProNameResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<lkf2__getProductTypeByProNameResponse*>(p->ptr), lkf2__getProductTypeByProNameResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<lkf2__getProductTypeByProNameResponse*>(p->ptr), lkf2__getProductTypeByProNameResponse);
		break;
	case SOAP_TYPE_lkf2__productType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<lkf2__productType*>(p->ptr), lkf2__productType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<lkf2__productType*>(p->ptr), lkf2__productType);
		break;
	case SOAP_TYPE_lkf2__getClientList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<lkf2__getClientList*>(p->ptr), lkf2__getClientList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<lkf2__getClientList*>(p->ptr), lkf2__getClientList);
		break;
	case SOAP_TYPE_lkf2__getClientListResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<lkf2__getClientListResponse*>(p->ptr), lkf2__getClientListResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<lkf2__getClientListResponse*>(p->ptr), lkf2__getClientListResponse);
		break;
	case SOAP_TYPE_lkf2__getOrderListByInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<lkf2__getOrderListByInfo*>(p->ptr), lkf2__getOrderListByInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<lkf2__getOrderListByInfo*>(p->ptr), lkf2__getOrderListByInfo);
		break;
	case SOAP_TYPE_lkf2__getOrderListByInfoResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<lkf2__getOrderListByInfoResponse*>(p->ptr), lkf2__getOrderListByInfoResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<lkf2__getOrderListByInfoResponse*>(p->ptr), lkf2__getOrderListByInfoResponse);
		break;
	case SOAP_TYPE_lkf2__addProductType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<lkf2__addProductType*>(p->ptr), lkf2__addProductType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<lkf2__addProductType*>(p->ptr), lkf2__addProductType);
		break;
	case SOAP_TYPE_lkf2__addProductTypeResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<lkf2__addProductTypeResponse*>(p->ptr), lkf2__addProductTypeResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<lkf2__addProductTypeResponse*>(p->ptr), lkf2__addProductTypeResponse);
		break;
	case SOAP_TYPE_lkf2__updateProductByInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<lkf2__updateProductByInfo*>(p->ptr), lkf2__updateProductByInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<lkf2__updateProductByInfo*>(p->ptr), lkf2__updateProductByInfo);
		break;
	case SOAP_TYPE_lkf2__updateProductByInfoResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<lkf2__updateProductByInfoResponse*>(p->ptr), lkf2__updateProductByInfoResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<lkf2__updateProductByInfoResponse*>(p->ptr), lkf2__updateProductByInfoResponse);
		break;
	case SOAP_TYPE_lkf2__getProductLikeList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<lkf2__getProductLikeList*>(p->ptr), lkf2__getProductLikeList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<lkf2__getProductLikeList*>(p->ptr), lkf2__getProductLikeList);
		break;
	case SOAP_TYPE_lkf2__getProductLikeListResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<lkf2__getProductLikeListResponse*>(p->ptr), lkf2__getProductLikeListResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<lkf2__getProductLikeListResponse*>(p->ptr), lkf2__getProductLikeListResponse);
		break;
	case SOAP_TYPE_lkf2__addOrder:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<lkf2__addOrder*>(p->ptr), lkf2__addOrder);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<lkf2__addOrder*>(p->ptr), lkf2__addOrder);
		break;
	case SOAP_TYPE_lkf2__addOrderResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<lkf2__addOrderResponse*>(p->ptr), lkf2__addOrderResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<lkf2__addOrderResponse*>(p->ptr), lkf2__addOrderResponse);
		break;
	case SOAP_TYPE_lkf2__getClientByNameAndPwd:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<lkf2__getClientByNameAndPwd*>(p->ptr), lkf2__getClientByNameAndPwd);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<lkf2__getClientByNameAndPwd*>(p->ptr), lkf2__getClientByNameAndPwd);
		break;
	case SOAP_TYPE_lkf2__getClientByNameAndPwdResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<lkf2__getClientByNameAndPwdResponse*>(p->ptr), lkf2__getClientByNameAndPwdResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<lkf2__getClientByNameAndPwdResponse*>(p->ptr), lkf2__getClientByNameAndPwdResponse);
		break;
	case SOAP_TYPE_lkf2__deleteShoppingCart:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<lkf2__deleteShoppingCart*>(p->ptr), lkf2__deleteShoppingCart);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<lkf2__deleteShoppingCart*>(p->ptr), lkf2__deleteShoppingCart);
		break;
	case SOAP_TYPE_lkf2__deleteShoppingCartResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<lkf2__deleteShoppingCartResponse*>(p->ptr), lkf2__deleteShoppingCartResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<lkf2__deleteShoppingCartResponse*>(p->ptr), lkf2__deleteShoppingCartResponse);
		break;
	case SOAP_TYPE_lkf2__getProductList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<lkf2__getProductList*>(p->ptr), lkf2__getProductList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<lkf2__getProductList*>(p->ptr), lkf2__getProductList);
		break;
	case SOAP_TYPE_lkf2__getProductListResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<lkf2__getProductListResponse*>(p->ptr), lkf2__getProductListResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<lkf2__getProductListResponse*>(p->ptr), lkf2__getProductListResponse);
		break;
	case SOAP_TYPE_lkf2__InsertClient:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<lkf2__InsertClient*>(p->ptr), lkf2__InsertClient);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<lkf2__InsertClient*>(p->ptr), lkf2__InsertClient);
		break;
	case SOAP_TYPE_lkf2__InsertClientResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<lkf2__InsertClientResponse*>(p->ptr), lkf2__InsertClientResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<lkf2__InsertClientResponse*>(p->ptr), lkf2__InsertClientResponse);
		break;
	case SOAP_TYPE_lkf2__getOrderListHistory:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<lkf2__getOrderListHistory*>(p->ptr), lkf2__getOrderListHistory);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<lkf2__getOrderListHistory*>(p->ptr), lkf2__getOrderListHistory);
		break;
	case SOAP_TYPE_lkf2__getOrderListHistoryResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<lkf2__getOrderListHistoryResponse*>(p->ptr), lkf2__getOrderListHistoryResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<lkf2__getOrderListHistoryResponse*>(p->ptr), lkf2__getOrderListHistoryResponse);
		break;
	case SOAP_TYPE_lkf2__updateHistory:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<lkf2__updateHistory*>(p->ptr), lkf2__updateHistory);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<lkf2__updateHistory*>(p->ptr), lkf2__updateHistory);
		break;
	case SOAP_TYPE_lkf2__updateHistoryResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<lkf2__updateHistoryResponse*>(p->ptr), lkf2__updateHistoryResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<lkf2__updateHistoryResponse*>(p->ptr), lkf2__updateHistoryResponse);
		break;
	case SOAP_TYPE___lkf1__addProduct:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __lkf1__addProduct*>(p->ptr), struct __lkf1__addProduct);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __lkf1__addProduct*>(p->ptr), struct __lkf1__addProduct);
		break;
	case SOAP_TYPE___lkf1__deleteProductTypeByName:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __lkf1__deleteProductTypeByName*>(p->ptr), struct __lkf1__deleteProductTypeByName);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __lkf1__deleteProductTypeByName*>(p->ptr), struct __lkf1__deleteProductTypeByName);
		break;
	case SOAP_TYPE___lkf1__getOrderList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __lkf1__getOrderList*>(p->ptr), struct __lkf1__getOrderList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __lkf1__getOrderList*>(p->ptr), struct __lkf1__getOrderList);
		break;
	case SOAP_TYPE___lkf1__getProductListByInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __lkf1__getProductListByInfo*>(p->ptr), struct __lkf1__getProductListByInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __lkf1__getProductListByInfo*>(p->ptr), struct __lkf1__getProductListByInfo);
		break;
	case SOAP_TYPE___lkf1__updateClient:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __lkf1__updateClient*>(p->ptr), struct __lkf1__updateClient);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __lkf1__updateClient*>(p->ptr), struct __lkf1__updateClient);
		break;
	case SOAP_TYPE___lkf1__deleteClientByNameAndPwd:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __lkf1__deleteClientByNameAndPwd*>(p->ptr), struct __lkf1__deleteClientByNameAndPwd);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __lkf1__deleteClientByNameAndPwd*>(p->ptr), struct __lkf1__deleteClientByNameAndPwd);
		break;
	case SOAP_TYPE___lkf1__deleteProductByInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __lkf1__deleteProductByInfo*>(p->ptr), struct __lkf1__deleteProductByInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __lkf1__deleteProductByInfo*>(p->ptr), struct __lkf1__deleteProductByInfo);
		break;
	case SOAP_TYPE___lkf1__getOrderLikeList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __lkf1__getOrderLikeList*>(p->ptr), struct __lkf1__getOrderLikeList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __lkf1__getOrderLikeList*>(p->ptr), struct __lkf1__getOrderLikeList);
		break;
	case SOAP_TYPE___lkf1__getClientLikeList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __lkf1__getClientLikeList*>(p->ptr), struct __lkf1__getClientLikeList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __lkf1__getClientLikeList*>(p->ptr), struct __lkf1__getClientLikeList);
		break;
	case SOAP_TYPE___lkf1__getProductTypeByProName:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __lkf1__getProductTypeByProName*>(p->ptr), struct __lkf1__getProductTypeByProName);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __lkf1__getProductTypeByProName*>(p->ptr), struct __lkf1__getProductTypeByProName);
		break;
	case SOAP_TYPE___lkf1__getClientList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __lkf1__getClientList*>(p->ptr), struct __lkf1__getClientList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __lkf1__getClientList*>(p->ptr), struct __lkf1__getClientList);
		break;
	case SOAP_TYPE___lkf1__getOrderListByInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __lkf1__getOrderListByInfo*>(p->ptr), struct __lkf1__getOrderListByInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __lkf1__getOrderListByInfo*>(p->ptr), struct __lkf1__getOrderListByInfo);
		break;
	case SOAP_TYPE___lkf1__addProductType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __lkf1__addProductType*>(p->ptr), struct __lkf1__addProductType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __lkf1__addProductType*>(p->ptr), struct __lkf1__addProductType);
		break;
	case SOAP_TYPE___lkf1__updateProductByInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __lkf1__updateProductByInfo*>(p->ptr), struct __lkf1__updateProductByInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __lkf1__updateProductByInfo*>(p->ptr), struct __lkf1__updateProductByInfo);
		break;
	case SOAP_TYPE___lkf1__getProductLikeList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __lkf1__getProductLikeList*>(p->ptr), struct __lkf1__getProductLikeList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __lkf1__getProductLikeList*>(p->ptr), struct __lkf1__getProductLikeList);
		break;
	case SOAP_TYPE___lkf1__addOrder:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __lkf1__addOrder*>(p->ptr), struct __lkf1__addOrder);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __lkf1__addOrder*>(p->ptr), struct __lkf1__addOrder);
		break;
	case SOAP_TYPE___lkf1__getClientByNameAndPwd:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __lkf1__getClientByNameAndPwd*>(p->ptr), struct __lkf1__getClientByNameAndPwd);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __lkf1__getClientByNameAndPwd*>(p->ptr), struct __lkf1__getClientByNameAndPwd);
		break;
	case SOAP_TYPE___lkf1__deleteShoppingCart:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __lkf1__deleteShoppingCart*>(p->ptr), struct __lkf1__deleteShoppingCart);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __lkf1__deleteShoppingCart*>(p->ptr), struct __lkf1__deleteShoppingCart);
		break;
	case SOAP_TYPE___lkf1__getProductList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __lkf1__getProductList*>(p->ptr), struct __lkf1__getProductList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __lkf1__getProductList*>(p->ptr), struct __lkf1__getProductList);
		break;
	case SOAP_TYPE___lkf1__InsertClient:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __lkf1__InsertClient*>(p->ptr), struct __lkf1__InsertClient);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __lkf1__InsertClient*>(p->ptr), struct __lkf1__InsertClient);
		break;
	case SOAP_TYPE___lkf1__getOrderListHistory:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __lkf1__getOrderListHistory*>(p->ptr), struct __lkf1__getOrderListHistory);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __lkf1__getOrderListHistory*>(p->ptr), struct __lkf1__getOrderListHistory);
		break;
	case SOAP_TYPE___lkf1__updateHistory:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __lkf1__updateHistory*>(p->ptr), struct __lkf1__updateHistory);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __lkf1__updateHistory*>(p->ptr), struct __lkf1__updateHistory);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Header*>(p->ptr), struct SOAP_ENV__Header);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Header*>(p->ptr), struct SOAP_ENV__Header);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Code*>(p->ptr), struct SOAP_ENV__Code);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Code*>(p->ptr), struct SOAP_ENV__Code);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Detail*>(p->ptr), struct SOAP_ENV__Detail);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Detail*>(p->ptr), struct SOAP_ENV__Detail);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Reason*>(p->ptr), struct SOAP_ENV__Reason);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Reason*>(p->ptr), struct SOAP_ENV__Reason);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Fault*>(p->ptr), struct SOAP_ENV__Fault);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Fault*>(p->ptr), struct SOAP_ENV__Fault);
		break;
#endif
	case SOAP_TYPE_xsd__decimal:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTolkf2__productType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<lkf2__productType *> *>(p->ptr), std::vector<lkf2__productType *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<lkf2__productType *> *>(p->ptr), std::vector<lkf2__productType *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTolkf2__client:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<lkf2__client *> *>(p->ptr), std::vector<lkf2__client *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<lkf2__client *> *>(p->ptr), std::vector<lkf2__client *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTolkf2__product:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<lkf2__product *> *>(p->ptr), std::vector<lkf2__product *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<lkf2__product *> *>(p->ptr), std::vector<lkf2__product *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTolkf2__order:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<lkf2__order *> *>(p->ptr), std::vector<lkf2__order *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<lkf2__order *> *>(p->ptr), std::vector<lkf2__order *> );
		break;
	default:
		return SOAP_ERR;
	}
	return SOAP_OK;
}

#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_fbase(int t, int b)
{
	(void)t; (void)b; /* appease -Wall -Werror */
	return 0;
}
#ifdef WIN32
#pragma warning(pop)
#endif

#ifndef WITH_NOIDREF
#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_finsert(struct soap *soap, int t, int tt, void *p, size_t index, const void *q, void **x)
{
	(void)soap; (void)t; (void)p; (void)index; (void)q; (void)x; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfPointerTolkf2__productType:
		if (t == SOAP_TYPE_lkf2__productType || soap_fbase(t, SOAP_TYPE_lkf2__productType))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<lkf2__productType *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<lkf2__productType *> *)p)[index] = *(lkf2__productType **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTolkf2__client:
		if (t == SOAP_TYPE_lkf2__client || soap_fbase(t, SOAP_TYPE_lkf2__client))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<lkf2__client *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<lkf2__client *> *)p)[index] = *(lkf2__client **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTolkf2__product:
		if (t == SOAP_TYPE_lkf2__product || soap_fbase(t, SOAP_TYPE_lkf2__product))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<lkf2__product *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<lkf2__product *> *)p)[index] = *(lkf2__product **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTolkf2__order:
		if (t == SOAP_TYPE_lkf2__order || soap_fbase(t, SOAP_TYPE_lkf2__order))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<lkf2__order *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<lkf2__order *> *)p)[index] = *(lkf2__order **)q;
		}
		break;
	case SOAP_TYPE_std__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_lkf2__addProduct:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy lkf2__addProduct type=%d location=%p object=%p\n", t, p, q));
		*(lkf2__addProduct*)p = *(lkf2__addProduct*)q;
		break;
	case SOAP_TYPE_lkf2__product:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy lkf2__product type=%d location=%p object=%p\n", t, p, q));
		*(lkf2__product*)p = *(lkf2__product*)q;
		break;
	case SOAP_TYPE_lkf2__addProductResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy lkf2__addProductResponse type=%d location=%p object=%p\n", t, p, q));
		*(lkf2__addProductResponse*)p = *(lkf2__addProductResponse*)q;
		break;
	case SOAP_TYPE_lkf2__deleteProductTypeByName:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy lkf2__deleteProductTypeByName type=%d location=%p object=%p\n", t, p, q));
		*(lkf2__deleteProductTypeByName*)p = *(lkf2__deleteProductTypeByName*)q;
		break;
	case SOAP_TYPE_lkf2__deleteProductTypeByNameResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy lkf2__deleteProductTypeByNameResponse type=%d location=%p object=%p\n", t, p, q));
		*(lkf2__deleteProductTypeByNameResponse*)p = *(lkf2__deleteProductTypeByNameResponse*)q;
		break;
	case SOAP_TYPE_lkf2__getOrderList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy lkf2__getOrderList type=%d location=%p object=%p\n", t, p, q));
		*(lkf2__getOrderList*)p = *(lkf2__getOrderList*)q;
		break;
	case SOAP_TYPE_lkf2__getOrderListResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy lkf2__getOrderListResponse type=%d location=%p object=%p\n", t, p, q));
		*(lkf2__getOrderListResponse*)p = *(lkf2__getOrderListResponse*)q;
		break;
	case SOAP_TYPE_lkf2__order:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy lkf2__order type=%d location=%p object=%p\n", t, p, q));
		*(lkf2__order*)p = *(lkf2__order*)q;
		break;
	case SOAP_TYPE_lkf2__getProductListByInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy lkf2__getProductListByInfo type=%d location=%p object=%p\n", t, p, q));
		*(lkf2__getProductListByInfo*)p = *(lkf2__getProductListByInfo*)q;
		break;
	case SOAP_TYPE_lkf2__getProductListByInfoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy lkf2__getProductListByInfoResponse type=%d location=%p object=%p\n", t, p, q));
		*(lkf2__getProductListByInfoResponse*)p = *(lkf2__getProductListByInfoResponse*)q;
		break;
	case SOAP_TYPE_lkf2__updateClient:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy lkf2__updateClient type=%d location=%p object=%p\n", t, p, q));
		*(lkf2__updateClient*)p = *(lkf2__updateClient*)q;
		break;
	case SOAP_TYPE_lkf2__client:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy lkf2__client type=%d location=%p object=%p\n", t, p, q));
		*(lkf2__client*)p = *(lkf2__client*)q;
		break;
	case SOAP_TYPE_lkf2__updateClientResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy lkf2__updateClientResponse type=%d location=%p object=%p\n", t, p, q));
		*(lkf2__updateClientResponse*)p = *(lkf2__updateClientResponse*)q;
		break;
	case SOAP_TYPE_lkf2__deleteClientByNameAndPwd:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy lkf2__deleteClientByNameAndPwd type=%d location=%p object=%p\n", t, p, q));
		*(lkf2__deleteClientByNameAndPwd*)p = *(lkf2__deleteClientByNameAndPwd*)q;
		break;
	case SOAP_TYPE_lkf2__deleteClientByNameAndPwdResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy lkf2__deleteClientByNameAndPwdResponse type=%d location=%p object=%p\n", t, p, q));
		*(lkf2__deleteClientByNameAndPwdResponse*)p = *(lkf2__deleteClientByNameAndPwdResponse*)q;
		break;
	case SOAP_TYPE_lkf2__deleteProductByInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy lkf2__deleteProductByInfo type=%d location=%p object=%p\n", t, p, q));
		*(lkf2__deleteProductByInfo*)p = *(lkf2__deleteProductByInfo*)q;
		break;
	case SOAP_TYPE_lkf2__deleteProductByInfoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy lkf2__deleteProductByInfoResponse type=%d location=%p object=%p\n", t, p, q));
		*(lkf2__deleteProductByInfoResponse*)p = *(lkf2__deleteProductByInfoResponse*)q;
		break;
	case SOAP_TYPE_lkf2__getOrderLikeList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy lkf2__getOrderLikeList type=%d location=%p object=%p\n", t, p, q));
		*(lkf2__getOrderLikeList*)p = *(lkf2__getOrderLikeList*)q;
		break;
	case SOAP_TYPE_lkf2__getOrderLikeListResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy lkf2__getOrderLikeListResponse type=%d location=%p object=%p\n", t, p, q));
		*(lkf2__getOrderLikeListResponse*)p = *(lkf2__getOrderLikeListResponse*)q;
		break;
	case SOAP_TYPE_lkf2__getClientLikeList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy lkf2__getClientLikeList type=%d location=%p object=%p\n", t, p, q));
		*(lkf2__getClientLikeList*)p = *(lkf2__getClientLikeList*)q;
		break;
	case SOAP_TYPE_lkf2__getClientLikeListResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy lkf2__getClientLikeListResponse type=%d location=%p object=%p\n", t, p, q));
		*(lkf2__getClientLikeListResponse*)p = *(lkf2__getClientLikeListResponse*)q;
		break;
	case SOAP_TYPE_lkf2__getProductTypeByProName:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy lkf2__getProductTypeByProName type=%d location=%p object=%p\n", t, p, q));
		*(lkf2__getProductTypeByProName*)p = *(lkf2__getProductTypeByProName*)q;
		break;
	case SOAP_TYPE_lkf2__getProductTypeByProNameResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy lkf2__getProductTypeByProNameResponse type=%d location=%p object=%p\n", t, p, q));
		*(lkf2__getProductTypeByProNameResponse*)p = *(lkf2__getProductTypeByProNameResponse*)q;
		break;
	case SOAP_TYPE_lkf2__productType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy lkf2__productType type=%d location=%p object=%p\n", t, p, q));
		*(lkf2__productType*)p = *(lkf2__productType*)q;
		break;
	case SOAP_TYPE_lkf2__getClientList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy lkf2__getClientList type=%d location=%p object=%p\n", t, p, q));
		*(lkf2__getClientList*)p = *(lkf2__getClientList*)q;
		break;
	case SOAP_TYPE_lkf2__getClientListResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy lkf2__getClientListResponse type=%d location=%p object=%p\n", t, p, q));
		*(lkf2__getClientListResponse*)p = *(lkf2__getClientListResponse*)q;
		break;
	case SOAP_TYPE_lkf2__getOrderListByInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy lkf2__getOrderListByInfo type=%d location=%p object=%p\n", t, p, q));
		*(lkf2__getOrderListByInfo*)p = *(lkf2__getOrderListByInfo*)q;
		break;
	case SOAP_TYPE_lkf2__getOrderListByInfoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy lkf2__getOrderListByInfoResponse type=%d location=%p object=%p\n", t, p, q));
		*(lkf2__getOrderListByInfoResponse*)p = *(lkf2__getOrderListByInfoResponse*)q;
		break;
	case SOAP_TYPE_lkf2__addProductType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy lkf2__addProductType type=%d location=%p object=%p\n", t, p, q));
		*(lkf2__addProductType*)p = *(lkf2__addProductType*)q;
		break;
	case SOAP_TYPE_lkf2__addProductTypeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy lkf2__addProductTypeResponse type=%d location=%p object=%p\n", t, p, q));
		*(lkf2__addProductTypeResponse*)p = *(lkf2__addProductTypeResponse*)q;
		break;
	case SOAP_TYPE_lkf2__updateProductByInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy lkf2__updateProductByInfo type=%d location=%p object=%p\n", t, p, q));
		*(lkf2__updateProductByInfo*)p = *(lkf2__updateProductByInfo*)q;
		break;
	case SOAP_TYPE_lkf2__updateProductByInfoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy lkf2__updateProductByInfoResponse type=%d location=%p object=%p\n", t, p, q));
		*(lkf2__updateProductByInfoResponse*)p = *(lkf2__updateProductByInfoResponse*)q;
		break;
	case SOAP_TYPE_lkf2__getProductLikeList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy lkf2__getProductLikeList type=%d location=%p object=%p\n", t, p, q));
		*(lkf2__getProductLikeList*)p = *(lkf2__getProductLikeList*)q;
		break;
	case SOAP_TYPE_lkf2__getProductLikeListResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy lkf2__getProductLikeListResponse type=%d location=%p object=%p\n", t, p, q));
		*(lkf2__getProductLikeListResponse*)p = *(lkf2__getProductLikeListResponse*)q;
		break;
	case SOAP_TYPE_lkf2__addOrder:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy lkf2__addOrder type=%d location=%p object=%p\n", t, p, q));
		*(lkf2__addOrder*)p = *(lkf2__addOrder*)q;
		break;
	case SOAP_TYPE_lkf2__addOrderResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy lkf2__addOrderResponse type=%d location=%p object=%p\n", t, p, q));
		*(lkf2__addOrderResponse*)p = *(lkf2__addOrderResponse*)q;
		break;
	case SOAP_TYPE_lkf2__getClientByNameAndPwd:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy lkf2__getClientByNameAndPwd type=%d location=%p object=%p\n", t, p, q));
		*(lkf2__getClientByNameAndPwd*)p = *(lkf2__getClientByNameAndPwd*)q;
		break;
	case SOAP_TYPE_lkf2__getClientByNameAndPwdResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy lkf2__getClientByNameAndPwdResponse type=%d location=%p object=%p\n", t, p, q));
		*(lkf2__getClientByNameAndPwdResponse*)p = *(lkf2__getClientByNameAndPwdResponse*)q;
		break;
	case SOAP_TYPE_lkf2__deleteShoppingCart:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy lkf2__deleteShoppingCart type=%d location=%p object=%p\n", t, p, q));
		*(lkf2__deleteShoppingCart*)p = *(lkf2__deleteShoppingCart*)q;
		break;
	case SOAP_TYPE_lkf2__deleteShoppingCartResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy lkf2__deleteShoppingCartResponse type=%d location=%p object=%p\n", t, p, q));
		*(lkf2__deleteShoppingCartResponse*)p = *(lkf2__deleteShoppingCartResponse*)q;
		break;
	case SOAP_TYPE_lkf2__getProductList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy lkf2__getProductList type=%d location=%p object=%p\n", t, p, q));
		*(lkf2__getProductList*)p = *(lkf2__getProductList*)q;
		break;
	case SOAP_TYPE_lkf2__getProductListResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy lkf2__getProductListResponse type=%d location=%p object=%p\n", t, p, q));
		*(lkf2__getProductListResponse*)p = *(lkf2__getProductListResponse*)q;
		break;
	case SOAP_TYPE_lkf2__InsertClient:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy lkf2__InsertClient type=%d location=%p object=%p\n", t, p, q));
		*(lkf2__InsertClient*)p = *(lkf2__InsertClient*)q;
		break;
	case SOAP_TYPE_lkf2__InsertClientResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy lkf2__InsertClientResponse type=%d location=%p object=%p\n", t, p, q));
		*(lkf2__InsertClientResponse*)p = *(lkf2__InsertClientResponse*)q;
		break;
	case SOAP_TYPE_lkf2__getOrderListHistory:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy lkf2__getOrderListHistory type=%d location=%p object=%p\n", t, p, q));
		*(lkf2__getOrderListHistory*)p = *(lkf2__getOrderListHistory*)q;
		break;
	case SOAP_TYPE_lkf2__getOrderListHistoryResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy lkf2__getOrderListHistoryResponse type=%d location=%p object=%p\n", t, p, q));
		*(lkf2__getOrderListHistoryResponse*)p = *(lkf2__getOrderListHistoryResponse*)q;
		break;
	case SOAP_TYPE_lkf2__updateHistory:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy lkf2__updateHistory type=%d location=%p object=%p\n", t, p, q));
		*(lkf2__updateHistory*)p = *(lkf2__updateHistory*)q;
		break;
	case SOAP_TYPE_lkf2__updateHistoryResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy lkf2__updateHistoryResponse type=%d location=%p object=%p\n", t, p, q));
		*(lkf2__updateHistoryResponse*)p = *(lkf2__updateHistoryResponse*)q;
		break;
	case SOAP_TYPE___lkf1__addProduct:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __lkf1__addProduct type=%d location=%p object=%p\n", t, p, q));
		*(struct __lkf1__addProduct*)p = *(struct __lkf1__addProduct*)q;
		break;
	case SOAP_TYPE___lkf1__deleteProductTypeByName:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __lkf1__deleteProductTypeByName type=%d location=%p object=%p\n", t, p, q));
		*(struct __lkf1__deleteProductTypeByName*)p = *(struct __lkf1__deleteProductTypeByName*)q;
		break;
	case SOAP_TYPE___lkf1__getOrderList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __lkf1__getOrderList type=%d location=%p object=%p\n", t, p, q));
		*(struct __lkf1__getOrderList*)p = *(struct __lkf1__getOrderList*)q;
		break;
	case SOAP_TYPE___lkf1__getProductListByInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __lkf1__getProductListByInfo type=%d location=%p object=%p\n", t, p, q));
		*(struct __lkf1__getProductListByInfo*)p = *(struct __lkf1__getProductListByInfo*)q;
		break;
	case SOAP_TYPE___lkf1__updateClient:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __lkf1__updateClient type=%d location=%p object=%p\n", t, p, q));
		*(struct __lkf1__updateClient*)p = *(struct __lkf1__updateClient*)q;
		break;
	case SOAP_TYPE___lkf1__deleteClientByNameAndPwd:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __lkf1__deleteClientByNameAndPwd type=%d location=%p object=%p\n", t, p, q));
		*(struct __lkf1__deleteClientByNameAndPwd*)p = *(struct __lkf1__deleteClientByNameAndPwd*)q;
		break;
	case SOAP_TYPE___lkf1__deleteProductByInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __lkf1__deleteProductByInfo type=%d location=%p object=%p\n", t, p, q));
		*(struct __lkf1__deleteProductByInfo*)p = *(struct __lkf1__deleteProductByInfo*)q;
		break;
	case SOAP_TYPE___lkf1__getOrderLikeList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __lkf1__getOrderLikeList type=%d location=%p object=%p\n", t, p, q));
		*(struct __lkf1__getOrderLikeList*)p = *(struct __lkf1__getOrderLikeList*)q;
		break;
	case SOAP_TYPE___lkf1__getClientLikeList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __lkf1__getClientLikeList type=%d location=%p object=%p\n", t, p, q));
		*(struct __lkf1__getClientLikeList*)p = *(struct __lkf1__getClientLikeList*)q;
		break;
	case SOAP_TYPE___lkf1__getProductTypeByProName:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __lkf1__getProductTypeByProName type=%d location=%p object=%p\n", t, p, q));
		*(struct __lkf1__getProductTypeByProName*)p = *(struct __lkf1__getProductTypeByProName*)q;
		break;
	case SOAP_TYPE___lkf1__getClientList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __lkf1__getClientList type=%d location=%p object=%p\n", t, p, q));
		*(struct __lkf1__getClientList*)p = *(struct __lkf1__getClientList*)q;
		break;
	case SOAP_TYPE___lkf1__getOrderListByInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __lkf1__getOrderListByInfo type=%d location=%p object=%p\n", t, p, q));
		*(struct __lkf1__getOrderListByInfo*)p = *(struct __lkf1__getOrderListByInfo*)q;
		break;
	case SOAP_TYPE___lkf1__addProductType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __lkf1__addProductType type=%d location=%p object=%p\n", t, p, q));
		*(struct __lkf1__addProductType*)p = *(struct __lkf1__addProductType*)q;
		break;
	case SOAP_TYPE___lkf1__updateProductByInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __lkf1__updateProductByInfo type=%d location=%p object=%p\n", t, p, q));
		*(struct __lkf1__updateProductByInfo*)p = *(struct __lkf1__updateProductByInfo*)q;
		break;
	case SOAP_TYPE___lkf1__getProductLikeList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __lkf1__getProductLikeList type=%d location=%p object=%p\n", t, p, q));
		*(struct __lkf1__getProductLikeList*)p = *(struct __lkf1__getProductLikeList*)q;
		break;
	case SOAP_TYPE___lkf1__addOrder:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __lkf1__addOrder type=%d location=%p object=%p\n", t, p, q));
		*(struct __lkf1__addOrder*)p = *(struct __lkf1__addOrder*)q;
		break;
	case SOAP_TYPE___lkf1__getClientByNameAndPwd:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __lkf1__getClientByNameAndPwd type=%d location=%p object=%p\n", t, p, q));
		*(struct __lkf1__getClientByNameAndPwd*)p = *(struct __lkf1__getClientByNameAndPwd*)q;
		break;
	case SOAP_TYPE___lkf1__deleteShoppingCart:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __lkf1__deleteShoppingCart type=%d location=%p object=%p\n", t, p, q));
		*(struct __lkf1__deleteShoppingCart*)p = *(struct __lkf1__deleteShoppingCart*)q;
		break;
	case SOAP_TYPE___lkf1__getProductList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __lkf1__getProductList type=%d location=%p object=%p\n", t, p, q));
		*(struct __lkf1__getProductList*)p = *(struct __lkf1__getProductList*)q;
		break;
	case SOAP_TYPE___lkf1__InsertClient:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __lkf1__InsertClient type=%d location=%p object=%p\n", t, p, q));
		*(struct __lkf1__InsertClient*)p = *(struct __lkf1__InsertClient*)q;
		break;
	case SOAP_TYPE___lkf1__getOrderListHistory:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __lkf1__getOrderListHistory type=%d location=%p object=%p\n", t, p, q));
		*(struct __lkf1__getOrderListHistory*)p = *(struct __lkf1__getOrderListHistory*)q;
		break;
	case SOAP_TYPE___lkf1__updateHistory:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __lkf1__updateHistory type=%d location=%p object=%p\n", t, p, q));
		*(struct __lkf1__updateHistory*)p = *(struct __lkf1__updateHistory*)q;
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Header type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Code type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Detail type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Reason type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Fault type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
		break;
#endif
	case SOAP_TYPE_xsd__decimal:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", t, tt));
	}
}
#ifdef WIN32
#pragma warning(pop)
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return a;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_new_byte(struct soap *soap, int n)
{
	char *a = static_cast<char *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char)));
	for (char *p = a; p && n--; ++p)
		soap_default_byte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_byte(soap, tag ? tag : "byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return a;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_new_int(struct soap *soap, int n)
{
	int *a = static_cast<int *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(int)));
	for (int *p = a; p && n--; ++p)
		soap_default_int(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_int(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_float(struct soap *soap, const char *tag, int id, const float *a, const char *type)
{
	return soap_outfloat(soap, tag, id, a, type, SOAP_TYPE_float);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_in_float(struct soap *soap, const char *tag, float *a, const char *type)
{
	a = soap_infloat(soap, tag, a, type, SOAP_TYPE_float);
	return a;
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_new_float(struct soap *soap, int n)
{
	float *a = static_cast<float *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(float)));
	for (float *p = a; p && n--; ++p)
		soap_default_float(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_float(struct soap *soap, const float *a, const char *tag, const char *type)
{
	if (soap_out_float(soap, tag ? tag : "float", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_get_float(struct soap *soap, float *p, const char *tag, const char *type)
{
	if ((p = soap_in_float(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dateTime(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_dateTime);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_dateTime(struct soap *soap, const char *tag, time_t *a, const char *type)
{
	a = soap_indateTime(soap, tag, a, type, SOAP_TYPE_dateTime);
	return a;
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_new_dateTime(struct soap *soap, int n)
{
	time_t *a = static_cast<time_t *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(time_t)));
	for (time_t *p = a; p && n--; ++p)
		soap_default_dateTime(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dateTime(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	if (soap_out_dateTime(soap, tag ? tag : "dateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_dateTime(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_dateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void lkf2__updateHistoryResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void lkf2__updateHistoryResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int lkf2__updateHistoryResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_lkf2__updateHistoryResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_lkf2__updateHistoryResponse(struct soap *soap, const char *tag, int id, const lkf2__updateHistoryResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_lkf2__updateHistoryResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *lkf2__updateHistoryResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_lkf2__updateHistoryResponse(soap, tag, this, type);
}

SOAP_FMAC3 lkf2__updateHistoryResponse * SOAP_FMAC4 soap_in_lkf2__updateHistoryResponse(struct soap *soap, const char *tag, lkf2__updateHistoryResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (lkf2__updateHistoryResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_lkf2__updateHistoryResponse, sizeof(lkf2__updateHistoryResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_lkf2__updateHistoryResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (lkf2__updateHistoryResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (lkf2__updateHistoryResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_lkf2__updateHistoryResponse, SOAP_TYPE_lkf2__updateHistoryResponse, sizeof(lkf2__updateHistoryResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 lkf2__updateHistoryResponse * SOAP_FMAC2 soap_instantiate_lkf2__updateHistoryResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_lkf2__updateHistoryResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	lkf2__updateHistoryResponse *p;
	size_t k = sizeof(lkf2__updateHistoryResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_lkf2__updateHistoryResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, lkf2__updateHistoryResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, lkf2__updateHistoryResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated lkf2__updateHistoryResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int lkf2__updateHistoryResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_lkf2__updateHistoryResponse(soap, tag ? tag : "lkf2:updateHistoryResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *lkf2__updateHistoryResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_lkf2__updateHistoryResponse(soap, this, tag, type);
}

SOAP_FMAC3 lkf2__updateHistoryResponse * SOAP_FMAC4 soap_get_lkf2__updateHistoryResponse(struct soap *soap, lkf2__updateHistoryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_lkf2__updateHistoryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void lkf2__updateHistory::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->lkf2__updateHistory::arg0 = NULL;
}

void lkf2__updateHistory::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTolkf2__order(soap, &this->lkf2__updateHistory::arg0);
#endif
}

int lkf2__updateHistory::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_lkf2__updateHistory(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_lkf2__updateHistory(struct soap *soap, const char *tag, int id, const lkf2__updateHistory *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_lkf2__updateHistory), type))
		return soap->error;
	if (soap_out_PointerTolkf2__order(soap, "arg0", -1, &a->lkf2__updateHistory::arg0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *lkf2__updateHistory::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_lkf2__updateHistory(soap, tag, this, type);
}

SOAP_FMAC3 lkf2__updateHistory * SOAP_FMAC4 soap_in_lkf2__updateHistory(struct soap *soap, const char *tag, lkf2__updateHistory *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (lkf2__updateHistory*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_lkf2__updateHistory, sizeof(lkf2__updateHistory), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_lkf2__updateHistory)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (lkf2__updateHistory *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTolkf2__order(soap, "arg0", &a->lkf2__updateHistory::arg0, "lkf2:order"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (lkf2__updateHistory *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_lkf2__updateHistory, SOAP_TYPE_lkf2__updateHistory, sizeof(lkf2__updateHistory), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 lkf2__updateHistory * SOAP_FMAC2 soap_instantiate_lkf2__updateHistory(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_lkf2__updateHistory(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	lkf2__updateHistory *p;
	size_t k = sizeof(lkf2__updateHistory);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_lkf2__updateHistory, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, lkf2__updateHistory);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, lkf2__updateHistory, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated lkf2__updateHistory location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int lkf2__updateHistory::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_lkf2__updateHistory(soap, tag ? tag : "lkf2:updateHistory", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *lkf2__updateHistory::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_lkf2__updateHistory(soap, this, tag, type);
}

SOAP_FMAC3 lkf2__updateHistory * SOAP_FMAC4 soap_get_lkf2__updateHistory(struct soap *soap, lkf2__updateHistory *p, const char *tag, const char *type)
{
	if ((p = soap_in_lkf2__updateHistory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void lkf2__getOrderListHistoryResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTolkf2__order(soap, &this->lkf2__getOrderListHistoryResponse::return_);
}

void lkf2__getOrderListHistoryResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTolkf2__order(soap, &this->lkf2__getOrderListHistoryResponse::return_);
#endif
}

int lkf2__getOrderListHistoryResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_lkf2__getOrderListHistoryResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_lkf2__getOrderListHistoryResponse(struct soap *soap, const char *tag, int id, const lkf2__getOrderListHistoryResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_lkf2__getOrderListHistoryResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTolkf2__order(soap, "return", -1, &a->lkf2__getOrderListHistoryResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *lkf2__getOrderListHistoryResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_lkf2__getOrderListHistoryResponse(soap, tag, this, type);
}

SOAP_FMAC3 lkf2__getOrderListHistoryResponse * SOAP_FMAC4 soap_in_lkf2__getOrderListHistoryResponse(struct soap *soap, const char *tag, lkf2__getOrderListHistoryResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (lkf2__getOrderListHistoryResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_lkf2__getOrderListHistoryResponse, sizeof(lkf2__getOrderListHistoryResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_lkf2__getOrderListHistoryResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (lkf2__getOrderListHistoryResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTolkf2__order(soap, "return", &a->lkf2__getOrderListHistoryResponse::return_, "lkf2:order"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (lkf2__getOrderListHistoryResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_lkf2__getOrderListHistoryResponse, SOAP_TYPE_lkf2__getOrderListHistoryResponse, sizeof(lkf2__getOrderListHistoryResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 lkf2__getOrderListHistoryResponse * SOAP_FMAC2 soap_instantiate_lkf2__getOrderListHistoryResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_lkf2__getOrderListHistoryResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	lkf2__getOrderListHistoryResponse *p;
	size_t k = sizeof(lkf2__getOrderListHistoryResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_lkf2__getOrderListHistoryResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, lkf2__getOrderListHistoryResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, lkf2__getOrderListHistoryResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated lkf2__getOrderListHistoryResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int lkf2__getOrderListHistoryResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_lkf2__getOrderListHistoryResponse(soap, tag ? tag : "lkf2:getOrderListHistoryResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *lkf2__getOrderListHistoryResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_lkf2__getOrderListHistoryResponse(soap, this, tag, type);
}

SOAP_FMAC3 lkf2__getOrderListHistoryResponse * SOAP_FMAC4 soap_get_lkf2__getOrderListHistoryResponse(struct soap *soap, lkf2__getOrderListHistoryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_lkf2__getOrderListHistoryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void lkf2__getOrderListHistory::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void lkf2__getOrderListHistory::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int lkf2__getOrderListHistory::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_lkf2__getOrderListHistory(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_lkf2__getOrderListHistory(struct soap *soap, const char *tag, int id, const lkf2__getOrderListHistory *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_lkf2__getOrderListHistory), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *lkf2__getOrderListHistory::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_lkf2__getOrderListHistory(soap, tag, this, type);
}

SOAP_FMAC3 lkf2__getOrderListHistory * SOAP_FMAC4 soap_in_lkf2__getOrderListHistory(struct soap *soap, const char *tag, lkf2__getOrderListHistory *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (lkf2__getOrderListHistory*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_lkf2__getOrderListHistory, sizeof(lkf2__getOrderListHistory), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_lkf2__getOrderListHistory)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (lkf2__getOrderListHistory *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (lkf2__getOrderListHistory *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_lkf2__getOrderListHistory, SOAP_TYPE_lkf2__getOrderListHistory, sizeof(lkf2__getOrderListHistory), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 lkf2__getOrderListHistory * SOAP_FMAC2 soap_instantiate_lkf2__getOrderListHistory(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_lkf2__getOrderListHistory(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	lkf2__getOrderListHistory *p;
	size_t k = sizeof(lkf2__getOrderListHistory);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_lkf2__getOrderListHistory, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, lkf2__getOrderListHistory);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, lkf2__getOrderListHistory, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated lkf2__getOrderListHistory location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int lkf2__getOrderListHistory::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_lkf2__getOrderListHistory(soap, tag ? tag : "lkf2:getOrderListHistory", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *lkf2__getOrderListHistory::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_lkf2__getOrderListHistory(soap, this, tag, type);
}

SOAP_FMAC3 lkf2__getOrderListHistory * SOAP_FMAC4 soap_get_lkf2__getOrderListHistory(struct soap *soap, lkf2__getOrderListHistory *p, const char *tag, const char *type)
{
	if ((p = soap_in_lkf2__getOrderListHistory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void lkf2__InsertClientResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void lkf2__InsertClientResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int lkf2__InsertClientResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_lkf2__InsertClientResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_lkf2__InsertClientResponse(struct soap *soap, const char *tag, int id, const lkf2__InsertClientResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_lkf2__InsertClientResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *lkf2__InsertClientResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_lkf2__InsertClientResponse(soap, tag, this, type);
}

SOAP_FMAC3 lkf2__InsertClientResponse * SOAP_FMAC4 soap_in_lkf2__InsertClientResponse(struct soap *soap, const char *tag, lkf2__InsertClientResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (lkf2__InsertClientResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_lkf2__InsertClientResponse, sizeof(lkf2__InsertClientResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_lkf2__InsertClientResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (lkf2__InsertClientResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (lkf2__InsertClientResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_lkf2__InsertClientResponse, SOAP_TYPE_lkf2__InsertClientResponse, sizeof(lkf2__InsertClientResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 lkf2__InsertClientResponse * SOAP_FMAC2 soap_instantiate_lkf2__InsertClientResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_lkf2__InsertClientResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	lkf2__InsertClientResponse *p;
	size_t k = sizeof(lkf2__InsertClientResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_lkf2__InsertClientResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, lkf2__InsertClientResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, lkf2__InsertClientResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated lkf2__InsertClientResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int lkf2__InsertClientResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_lkf2__InsertClientResponse(soap, tag ? tag : "lkf2:InsertClientResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *lkf2__InsertClientResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_lkf2__InsertClientResponse(soap, this, tag, type);
}

SOAP_FMAC3 lkf2__InsertClientResponse * SOAP_FMAC4 soap_get_lkf2__InsertClientResponse(struct soap *soap, lkf2__InsertClientResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_lkf2__InsertClientResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void lkf2__InsertClient::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->lkf2__InsertClient::arg0 = NULL;
}

void lkf2__InsertClient::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTolkf2__client(soap, &this->lkf2__InsertClient::arg0);
#endif
}

int lkf2__InsertClient::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_lkf2__InsertClient(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_lkf2__InsertClient(struct soap *soap, const char *tag, int id, const lkf2__InsertClient *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_lkf2__InsertClient), type))
		return soap->error;
	if (soap_out_PointerTolkf2__client(soap, "arg0", -1, &a->lkf2__InsertClient::arg0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *lkf2__InsertClient::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_lkf2__InsertClient(soap, tag, this, type);
}

SOAP_FMAC3 lkf2__InsertClient * SOAP_FMAC4 soap_in_lkf2__InsertClient(struct soap *soap, const char *tag, lkf2__InsertClient *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (lkf2__InsertClient*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_lkf2__InsertClient, sizeof(lkf2__InsertClient), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_lkf2__InsertClient)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (lkf2__InsertClient *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTolkf2__client(soap, "arg0", &a->lkf2__InsertClient::arg0, "lkf2:client"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (lkf2__InsertClient *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_lkf2__InsertClient, SOAP_TYPE_lkf2__InsertClient, sizeof(lkf2__InsertClient), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 lkf2__InsertClient * SOAP_FMAC2 soap_instantiate_lkf2__InsertClient(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_lkf2__InsertClient(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	lkf2__InsertClient *p;
	size_t k = sizeof(lkf2__InsertClient);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_lkf2__InsertClient, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, lkf2__InsertClient);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, lkf2__InsertClient, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated lkf2__InsertClient location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int lkf2__InsertClient::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_lkf2__InsertClient(soap, tag ? tag : "lkf2:InsertClient", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *lkf2__InsertClient::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_lkf2__InsertClient(soap, this, tag, type);
}

SOAP_FMAC3 lkf2__InsertClient * SOAP_FMAC4 soap_get_lkf2__InsertClient(struct soap *soap, lkf2__InsertClient *p, const char *tag, const char *type)
{
	if ((p = soap_in_lkf2__InsertClient(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void lkf2__getProductListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTolkf2__product(soap, &this->lkf2__getProductListResponse::return_);
}

void lkf2__getProductListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTolkf2__product(soap, &this->lkf2__getProductListResponse::return_);
#endif
}

int lkf2__getProductListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_lkf2__getProductListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_lkf2__getProductListResponse(struct soap *soap, const char *tag, int id, const lkf2__getProductListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_lkf2__getProductListResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTolkf2__product(soap, "return", -1, &a->lkf2__getProductListResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *lkf2__getProductListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_lkf2__getProductListResponse(soap, tag, this, type);
}

SOAP_FMAC3 lkf2__getProductListResponse * SOAP_FMAC4 soap_in_lkf2__getProductListResponse(struct soap *soap, const char *tag, lkf2__getProductListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (lkf2__getProductListResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_lkf2__getProductListResponse, sizeof(lkf2__getProductListResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_lkf2__getProductListResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (lkf2__getProductListResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTolkf2__product(soap, "return", &a->lkf2__getProductListResponse::return_, "lkf2:product"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (lkf2__getProductListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_lkf2__getProductListResponse, SOAP_TYPE_lkf2__getProductListResponse, sizeof(lkf2__getProductListResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 lkf2__getProductListResponse * SOAP_FMAC2 soap_instantiate_lkf2__getProductListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_lkf2__getProductListResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	lkf2__getProductListResponse *p;
	size_t k = sizeof(lkf2__getProductListResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_lkf2__getProductListResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, lkf2__getProductListResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, lkf2__getProductListResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated lkf2__getProductListResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int lkf2__getProductListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_lkf2__getProductListResponse(soap, tag ? tag : "lkf2:getProductListResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *lkf2__getProductListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_lkf2__getProductListResponse(soap, this, tag, type);
}

SOAP_FMAC3 lkf2__getProductListResponse * SOAP_FMAC4 soap_get_lkf2__getProductListResponse(struct soap *soap, lkf2__getProductListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_lkf2__getProductListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void lkf2__getProductList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->lkf2__getProductList::arg0);
}

void lkf2__getProductList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int lkf2__getProductList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_lkf2__getProductList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_lkf2__getProductList(struct soap *soap, const char *tag, int id, const lkf2__getProductList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_lkf2__getProductList), type))
		return soap->error;
	if (soap_out_int(soap, "arg0", -1, &a->lkf2__getProductList::arg0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *lkf2__getProductList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_lkf2__getProductList(soap, tag, this, type);
}

SOAP_FMAC3 lkf2__getProductList * SOAP_FMAC4 soap_in_lkf2__getProductList(struct soap *soap, const char *tag, lkf2__getProductList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (lkf2__getProductList*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_lkf2__getProductList, sizeof(lkf2__getProductList), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_lkf2__getProductList)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (lkf2__getProductList *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "arg0", &a->lkf2__getProductList::arg0, "xsd:int"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (lkf2__getProductList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_lkf2__getProductList, SOAP_TYPE_lkf2__getProductList, sizeof(lkf2__getProductList), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 lkf2__getProductList * SOAP_FMAC2 soap_instantiate_lkf2__getProductList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_lkf2__getProductList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	lkf2__getProductList *p;
	size_t k = sizeof(lkf2__getProductList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_lkf2__getProductList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, lkf2__getProductList);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, lkf2__getProductList, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated lkf2__getProductList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int lkf2__getProductList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_lkf2__getProductList(soap, tag ? tag : "lkf2:getProductList", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *lkf2__getProductList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_lkf2__getProductList(soap, this, tag, type);
}

SOAP_FMAC3 lkf2__getProductList * SOAP_FMAC4 soap_get_lkf2__getProductList(struct soap *soap, lkf2__getProductList *p, const char *tag, const char *type)
{
	if ((p = soap_in_lkf2__getProductList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void lkf2__deleteShoppingCartResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void lkf2__deleteShoppingCartResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int lkf2__deleteShoppingCartResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_lkf2__deleteShoppingCartResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_lkf2__deleteShoppingCartResponse(struct soap *soap, const char *tag, int id, const lkf2__deleteShoppingCartResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_lkf2__deleteShoppingCartResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *lkf2__deleteShoppingCartResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_lkf2__deleteShoppingCartResponse(soap, tag, this, type);
}

SOAP_FMAC3 lkf2__deleteShoppingCartResponse * SOAP_FMAC4 soap_in_lkf2__deleteShoppingCartResponse(struct soap *soap, const char *tag, lkf2__deleteShoppingCartResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (lkf2__deleteShoppingCartResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_lkf2__deleteShoppingCartResponse, sizeof(lkf2__deleteShoppingCartResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_lkf2__deleteShoppingCartResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (lkf2__deleteShoppingCartResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (lkf2__deleteShoppingCartResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_lkf2__deleteShoppingCartResponse, SOAP_TYPE_lkf2__deleteShoppingCartResponse, sizeof(lkf2__deleteShoppingCartResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 lkf2__deleteShoppingCartResponse * SOAP_FMAC2 soap_instantiate_lkf2__deleteShoppingCartResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_lkf2__deleteShoppingCartResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	lkf2__deleteShoppingCartResponse *p;
	size_t k = sizeof(lkf2__deleteShoppingCartResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_lkf2__deleteShoppingCartResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, lkf2__deleteShoppingCartResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, lkf2__deleteShoppingCartResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated lkf2__deleteShoppingCartResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int lkf2__deleteShoppingCartResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_lkf2__deleteShoppingCartResponse(soap, tag ? tag : "lkf2:deleteShoppingCartResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *lkf2__deleteShoppingCartResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_lkf2__deleteShoppingCartResponse(soap, this, tag, type);
}

SOAP_FMAC3 lkf2__deleteShoppingCartResponse * SOAP_FMAC4 soap_get_lkf2__deleteShoppingCartResponse(struct soap *soap, lkf2__deleteShoppingCartResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_lkf2__deleteShoppingCartResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void lkf2__deleteShoppingCart::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->lkf2__deleteShoppingCart::arg0 = NULL;
}

void lkf2__deleteShoppingCart::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTolkf2__order(soap, &this->lkf2__deleteShoppingCart::arg0);
#endif
}

int lkf2__deleteShoppingCart::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_lkf2__deleteShoppingCart(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_lkf2__deleteShoppingCart(struct soap *soap, const char *tag, int id, const lkf2__deleteShoppingCart *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_lkf2__deleteShoppingCart), type))
		return soap->error;
	if (soap_out_PointerTolkf2__order(soap, "arg0", -1, &a->lkf2__deleteShoppingCart::arg0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *lkf2__deleteShoppingCart::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_lkf2__deleteShoppingCart(soap, tag, this, type);
}

SOAP_FMAC3 lkf2__deleteShoppingCart * SOAP_FMAC4 soap_in_lkf2__deleteShoppingCart(struct soap *soap, const char *tag, lkf2__deleteShoppingCart *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (lkf2__deleteShoppingCart*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_lkf2__deleteShoppingCart, sizeof(lkf2__deleteShoppingCart), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_lkf2__deleteShoppingCart)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (lkf2__deleteShoppingCart *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTolkf2__order(soap, "arg0", &a->lkf2__deleteShoppingCart::arg0, "lkf2:order"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (lkf2__deleteShoppingCart *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_lkf2__deleteShoppingCart, SOAP_TYPE_lkf2__deleteShoppingCart, sizeof(lkf2__deleteShoppingCart), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 lkf2__deleteShoppingCart * SOAP_FMAC2 soap_instantiate_lkf2__deleteShoppingCart(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_lkf2__deleteShoppingCart(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	lkf2__deleteShoppingCart *p;
	size_t k = sizeof(lkf2__deleteShoppingCart);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_lkf2__deleteShoppingCart, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, lkf2__deleteShoppingCart);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, lkf2__deleteShoppingCart, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated lkf2__deleteShoppingCart location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int lkf2__deleteShoppingCart::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_lkf2__deleteShoppingCart(soap, tag ? tag : "lkf2:deleteShoppingCart", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *lkf2__deleteShoppingCart::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_lkf2__deleteShoppingCart(soap, this, tag, type);
}

SOAP_FMAC3 lkf2__deleteShoppingCart * SOAP_FMAC4 soap_get_lkf2__deleteShoppingCart(struct soap *soap, lkf2__deleteShoppingCart *p, const char *tag, const char *type)
{
	if ((p = soap_in_lkf2__deleteShoppingCart(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void lkf2__getClientByNameAndPwdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->lkf2__getClientByNameAndPwdResponse::return_ = NULL;
}

void lkf2__getClientByNameAndPwdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTolkf2__client(soap, &this->lkf2__getClientByNameAndPwdResponse::return_);
#endif
}

int lkf2__getClientByNameAndPwdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_lkf2__getClientByNameAndPwdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_lkf2__getClientByNameAndPwdResponse(struct soap *soap, const char *tag, int id, const lkf2__getClientByNameAndPwdResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_lkf2__getClientByNameAndPwdResponse), type))
		return soap->error;
	if (soap_out_PointerTolkf2__client(soap, "return", -1, &a->lkf2__getClientByNameAndPwdResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *lkf2__getClientByNameAndPwdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_lkf2__getClientByNameAndPwdResponse(soap, tag, this, type);
}

SOAP_FMAC3 lkf2__getClientByNameAndPwdResponse * SOAP_FMAC4 soap_in_lkf2__getClientByNameAndPwdResponse(struct soap *soap, const char *tag, lkf2__getClientByNameAndPwdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (lkf2__getClientByNameAndPwdResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_lkf2__getClientByNameAndPwdResponse, sizeof(lkf2__getClientByNameAndPwdResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_lkf2__getClientByNameAndPwdResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (lkf2__getClientByNameAndPwdResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_return_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTolkf2__client(soap, "return", &a->lkf2__getClientByNameAndPwdResponse::return_, "lkf2:client"))
				{	soap_flag_return_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (lkf2__getClientByNameAndPwdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_lkf2__getClientByNameAndPwdResponse, SOAP_TYPE_lkf2__getClientByNameAndPwdResponse, sizeof(lkf2__getClientByNameAndPwdResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 lkf2__getClientByNameAndPwdResponse * SOAP_FMAC2 soap_instantiate_lkf2__getClientByNameAndPwdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_lkf2__getClientByNameAndPwdResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	lkf2__getClientByNameAndPwdResponse *p;
	size_t k = sizeof(lkf2__getClientByNameAndPwdResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_lkf2__getClientByNameAndPwdResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, lkf2__getClientByNameAndPwdResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, lkf2__getClientByNameAndPwdResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated lkf2__getClientByNameAndPwdResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int lkf2__getClientByNameAndPwdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_lkf2__getClientByNameAndPwdResponse(soap, tag ? tag : "lkf2:getClientByNameAndPwdResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *lkf2__getClientByNameAndPwdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_lkf2__getClientByNameAndPwdResponse(soap, this, tag, type);
}

SOAP_FMAC3 lkf2__getClientByNameAndPwdResponse * SOAP_FMAC4 soap_get_lkf2__getClientByNameAndPwdResponse(struct soap *soap, lkf2__getClientByNameAndPwdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_lkf2__getClientByNameAndPwdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void lkf2__getClientByNameAndPwd::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->lkf2__getClientByNameAndPwd::arg0 = NULL;
	this->lkf2__getClientByNameAndPwd::arg1 = NULL;
}

void lkf2__getClientByNameAndPwd::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->lkf2__getClientByNameAndPwd::arg0);
	soap_serialize_PointerTostd__string(soap, &this->lkf2__getClientByNameAndPwd::arg1);
#endif
}

int lkf2__getClientByNameAndPwd::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_lkf2__getClientByNameAndPwd(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_lkf2__getClientByNameAndPwd(struct soap *soap, const char *tag, int id, const lkf2__getClientByNameAndPwd *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_lkf2__getClientByNameAndPwd), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &a->lkf2__getClientByNameAndPwd::arg0, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg1", -1, &a->lkf2__getClientByNameAndPwd::arg1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *lkf2__getClientByNameAndPwd::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_lkf2__getClientByNameAndPwd(soap, tag, this, type);
}

SOAP_FMAC3 lkf2__getClientByNameAndPwd * SOAP_FMAC4 soap_in_lkf2__getClientByNameAndPwd(struct soap *soap, const char *tag, lkf2__getClientByNameAndPwd *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (lkf2__getClientByNameAndPwd*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_lkf2__getClientByNameAndPwd, sizeof(lkf2__getClientByNameAndPwd), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_lkf2__getClientByNameAndPwd)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (lkf2__getClientByNameAndPwd *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg0", &a->lkf2__getClientByNameAndPwd::arg0, "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap_flag_arg11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg1", &a->lkf2__getClientByNameAndPwd::arg1, "xsd:string"))
				{	soap_flag_arg11--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (lkf2__getClientByNameAndPwd *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_lkf2__getClientByNameAndPwd, SOAP_TYPE_lkf2__getClientByNameAndPwd, sizeof(lkf2__getClientByNameAndPwd), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 lkf2__getClientByNameAndPwd * SOAP_FMAC2 soap_instantiate_lkf2__getClientByNameAndPwd(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_lkf2__getClientByNameAndPwd(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	lkf2__getClientByNameAndPwd *p;
	size_t k = sizeof(lkf2__getClientByNameAndPwd);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_lkf2__getClientByNameAndPwd, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, lkf2__getClientByNameAndPwd);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, lkf2__getClientByNameAndPwd, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated lkf2__getClientByNameAndPwd location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int lkf2__getClientByNameAndPwd::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_lkf2__getClientByNameAndPwd(soap, tag ? tag : "lkf2:getClientByNameAndPwd", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *lkf2__getClientByNameAndPwd::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_lkf2__getClientByNameAndPwd(soap, this, tag, type);
}

SOAP_FMAC3 lkf2__getClientByNameAndPwd * SOAP_FMAC4 soap_get_lkf2__getClientByNameAndPwd(struct soap *soap, lkf2__getClientByNameAndPwd *p, const char *tag, const char *type)
{
	if ((p = soap_in_lkf2__getClientByNameAndPwd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void lkf2__addOrderResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void lkf2__addOrderResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int lkf2__addOrderResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_lkf2__addOrderResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_lkf2__addOrderResponse(struct soap *soap, const char *tag, int id, const lkf2__addOrderResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_lkf2__addOrderResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *lkf2__addOrderResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_lkf2__addOrderResponse(soap, tag, this, type);
}

SOAP_FMAC3 lkf2__addOrderResponse * SOAP_FMAC4 soap_in_lkf2__addOrderResponse(struct soap *soap, const char *tag, lkf2__addOrderResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (lkf2__addOrderResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_lkf2__addOrderResponse, sizeof(lkf2__addOrderResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_lkf2__addOrderResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (lkf2__addOrderResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (lkf2__addOrderResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_lkf2__addOrderResponse, SOAP_TYPE_lkf2__addOrderResponse, sizeof(lkf2__addOrderResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 lkf2__addOrderResponse * SOAP_FMAC2 soap_instantiate_lkf2__addOrderResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_lkf2__addOrderResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	lkf2__addOrderResponse *p;
	size_t k = sizeof(lkf2__addOrderResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_lkf2__addOrderResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, lkf2__addOrderResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, lkf2__addOrderResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated lkf2__addOrderResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int lkf2__addOrderResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_lkf2__addOrderResponse(soap, tag ? tag : "lkf2:addOrderResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *lkf2__addOrderResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_lkf2__addOrderResponse(soap, this, tag, type);
}

SOAP_FMAC3 lkf2__addOrderResponse * SOAP_FMAC4 soap_get_lkf2__addOrderResponse(struct soap *soap, lkf2__addOrderResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_lkf2__addOrderResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void lkf2__addOrder::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->lkf2__addOrder::arg0 = NULL;
}

void lkf2__addOrder::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTolkf2__order(soap, &this->lkf2__addOrder::arg0);
#endif
}

int lkf2__addOrder::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_lkf2__addOrder(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_lkf2__addOrder(struct soap *soap, const char *tag, int id, const lkf2__addOrder *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_lkf2__addOrder), type))
		return soap->error;
	if (soap_out_PointerTolkf2__order(soap, "arg0", -1, &a->lkf2__addOrder::arg0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *lkf2__addOrder::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_lkf2__addOrder(soap, tag, this, type);
}

SOAP_FMAC3 lkf2__addOrder * SOAP_FMAC4 soap_in_lkf2__addOrder(struct soap *soap, const char *tag, lkf2__addOrder *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (lkf2__addOrder*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_lkf2__addOrder, sizeof(lkf2__addOrder), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_lkf2__addOrder)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (lkf2__addOrder *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTolkf2__order(soap, "arg0", &a->lkf2__addOrder::arg0, "lkf2:order"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (lkf2__addOrder *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_lkf2__addOrder, SOAP_TYPE_lkf2__addOrder, sizeof(lkf2__addOrder), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 lkf2__addOrder * SOAP_FMAC2 soap_instantiate_lkf2__addOrder(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_lkf2__addOrder(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	lkf2__addOrder *p;
	size_t k = sizeof(lkf2__addOrder);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_lkf2__addOrder, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, lkf2__addOrder);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, lkf2__addOrder, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated lkf2__addOrder location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int lkf2__addOrder::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_lkf2__addOrder(soap, tag ? tag : "lkf2:addOrder", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *lkf2__addOrder::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_lkf2__addOrder(soap, this, tag, type);
}

SOAP_FMAC3 lkf2__addOrder * SOAP_FMAC4 soap_get_lkf2__addOrder(struct soap *soap, lkf2__addOrder *p, const char *tag, const char *type)
{
	if ((p = soap_in_lkf2__addOrder(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void lkf2__getProductLikeListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTolkf2__product(soap, &this->lkf2__getProductLikeListResponse::return_);
}

void lkf2__getProductLikeListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTolkf2__product(soap, &this->lkf2__getProductLikeListResponse::return_);
#endif
}

int lkf2__getProductLikeListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_lkf2__getProductLikeListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_lkf2__getProductLikeListResponse(struct soap *soap, const char *tag, int id, const lkf2__getProductLikeListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_lkf2__getProductLikeListResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTolkf2__product(soap, "return", -1, &a->lkf2__getProductLikeListResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *lkf2__getProductLikeListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_lkf2__getProductLikeListResponse(soap, tag, this, type);
}

SOAP_FMAC3 lkf2__getProductLikeListResponse * SOAP_FMAC4 soap_in_lkf2__getProductLikeListResponse(struct soap *soap, const char *tag, lkf2__getProductLikeListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (lkf2__getProductLikeListResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_lkf2__getProductLikeListResponse, sizeof(lkf2__getProductLikeListResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_lkf2__getProductLikeListResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (lkf2__getProductLikeListResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTolkf2__product(soap, "return", &a->lkf2__getProductLikeListResponse::return_, "lkf2:product"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (lkf2__getProductLikeListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_lkf2__getProductLikeListResponse, SOAP_TYPE_lkf2__getProductLikeListResponse, sizeof(lkf2__getProductLikeListResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 lkf2__getProductLikeListResponse * SOAP_FMAC2 soap_instantiate_lkf2__getProductLikeListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_lkf2__getProductLikeListResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	lkf2__getProductLikeListResponse *p;
	size_t k = sizeof(lkf2__getProductLikeListResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_lkf2__getProductLikeListResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, lkf2__getProductLikeListResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, lkf2__getProductLikeListResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated lkf2__getProductLikeListResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int lkf2__getProductLikeListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_lkf2__getProductLikeListResponse(soap, tag ? tag : "lkf2:getProductLikeListResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *lkf2__getProductLikeListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_lkf2__getProductLikeListResponse(soap, this, tag, type);
}

SOAP_FMAC3 lkf2__getProductLikeListResponse * SOAP_FMAC4 soap_get_lkf2__getProductLikeListResponse(struct soap *soap, lkf2__getProductLikeListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_lkf2__getProductLikeListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void lkf2__getProductLikeList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->lkf2__getProductLikeList::arg0 = NULL;
}

void lkf2__getProductLikeList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->lkf2__getProductLikeList::arg0);
#endif
}

int lkf2__getProductLikeList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_lkf2__getProductLikeList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_lkf2__getProductLikeList(struct soap *soap, const char *tag, int id, const lkf2__getProductLikeList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_lkf2__getProductLikeList), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &a->lkf2__getProductLikeList::arg0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *lkf2__getProductLikeList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_lkf2__getProductLikeList(soap, tag, this, type);
}

SOAP_FMAC3 lkf2__getProductLikeList * SOAP_FMAC4 soap_in_lkf2__getProductLikeList(struct soap *soap, const char *tag, lkf2__getProductLikeList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (lkf2__getProductLikeList*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_lkf2__getProductLikeList, sizeof(lkf2__getProductLikeList), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_lkf2__getProductLikeList)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (lkf2__getProductLikeList *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg0", &a->lkf2__getProductLikeList::arg0, "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (lkf2__getProductLikeList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_lkf2__getProductLikeList, SOAP_TYPE_lkf2__getProductLikeList, sizeof(lkf2__getProductLikeList), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 lkf2__getProductLikeList * SOAP_FMAC2 soap_instantiate_lkf2__getProductLikeList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_lkf2__getProductLikeList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	lkf2__getProductLikeList *p;
	size_t k = sizeof(lkf2__getProductLikeList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_lkf2__getProductLikeList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, lkf2__getProductLikeList);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, lkf2__getProductLikeList, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated lkf2__getProductLikeList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int lkf2__getProductLikeList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_lkf2__getProductLikeList(soap, tag ? tag : "lkf2:getProductLikeList", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *lkf2__getProductLikeList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_lkf2__getProductLikeList(soap, this, tag, type);
}

SOAP_FMAC3 lkf2__getProductLikeList * SOAP_FMAC4 soap_get_lkf2__getProductLikeList(struct soap *soap, lkf2__getProductLikeList *p, const char *tag, const char *type)
{
	if ((p = soap_in_lkf2__getProductLikeList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void lkf2__updateProductByInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void lkf2__updateProductByInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int lkf2__updateProductByInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_lkf2__updateProductByInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_lkf2__updateProductByInfoResponse(struct soap *soap, const char *tag, int id, const lkf2__updateProductByInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_lkf2__updateProductByInfoResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *lkf2__updateProductByInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_lkf2__updateProductByInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 lkf2__updateProductByInfoResponse * SOAP_FMAC4 soap_in_lkf2__updateProductByInfoResponse(struct soap *soap, const char *tag, lkf2__updateProductByInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (lkf2__updateProductByInfoResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_lkf2__updateProductByInfoResponse, sizeof(lkf2__updateProductByInfoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_lkf2__updateProductByInfoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (lkf2__updateProductByInfoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (lkf2__updateProductByInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_lkf2__updateProductByInfoResponse, SOAP_TYPE_lkf2__updateProductByInfoResponse, sizeof(lkf2__updateProductByInfoResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 lkf2__updateProductByInfoResponse * SOAP_FMAC2 soap_instantiate_lkf2__updateProductByInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_lkf2__updateProductByInfoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	lkf2__updateProductByInfoResponse *p;
	size_t k = sizeof(lkf2__updateProductByInfoResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_lkf2__updateProductByInfoResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, lkf2__updateProductByInfoResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, lkf2__updateProductByInfoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated lkf2__updateProductByInfoResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int lkf2__updateProductByInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_lkf2__updateProductByInfoResponse(soap, tag ? tag : "lkf2:updateProductByInfoResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *lkf2__updateProductByInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_lkf2__updateProductByInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 lkf2__updateProductByInfoResponse * SOAP_FMAC4 soap_get_lkf2__updateProductByInfoResponse(struct soap *soap, lkf2__updateProductByInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_lkf2__updateProductByInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void lkf2__updateProductByInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->lkf2__updateProductByInfo::arg0 = NULL;
}

void lkf2__updateProductByInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTolkf2__product(soap, &this->lkf2__updateProductByInfo::arg0);
#endif
}

int lkf2__updateProductByInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_lkf2__updateProductByInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_lkf2__updateProductByInfo(struct soap *soap, const char *tag, int id, const lkf2__updateProductByInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_lkf2__updateProductByInfo), type))
		return soap->error;
	if (soap_out_PointerTolkf2__product(soap, "arg0", -1, &a->lkf2__updateProductByInfo::arg0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *lkf2__updateProductByInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_lkf2__updateProductByInfo(soap, tag, this, type);
}

SOAP_FMAC3 lkf2__updateProductByInfo * SOAP_FMAC4 soap_in_lkf2__updateProductByInfo(struct soap *soap, const char *tag, lkf2__updateProductByInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (lkf2__updateProductByInfo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_lkf2__updateProductByInfo, sizeof(lkf2__updateProductByInfo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_lkf2__updateProductByInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (lkf2__updateProductByInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTolkf2__product(soap, "arg0", &a->lkf2__updateProductByInfo::arg0, "lkf2:product"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (lkf2__updateProductByInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_lkf2__updateProductByInfo, SOAP_TYPE_lkf2__updateProductByInfo, sizeof(lkf2__updateProductByInfo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 lkf2__updateProductByInfo * SOAP_FMAC2 soap_instantiate_lkf2__updateProductByInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_lkf2__updateProductByInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	lkf2__updateProductByInfo *p;
	size_t k = sizeof(lkf2__updateProductByInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_lkf2__updateProductByInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, lkf2__updateProductByInfo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, lkf2__updateProductByInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated lkf2__updateProductByInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int lkf2__updateProductByInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_lkf2__updateProductByInfo(soap, tag ? tag : "lkf2:updateProductByInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *lkf2__updateProductByInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_lkf2__updateProductByInfo(soap, this, tag, type);
}

SOAP_FMAC3 lkf2__updateProductByInfo * SOAP_FMAC4 soap_get_lkf2__updateProductByInfo(struct soap *soap, lkf2__updateProductByInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_lkf2__updateProductByInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void lkf2__addProductTypeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void lkf2__addProductTypeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int lkf2__addProductTypeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_lkf2__addProductTypeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_lkf2__addProductTypeResponse(struct soap *soap, const char *tag, int id, const lkf2__addProductTypeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_lkf2__addProductTypeResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *lkf2__addProductTypeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_lkf2__addProductTypeResponse(soap, tag, this, type);
}

SOAP_FMAC3 lkf2__addProductTypeResponse * SOAP_FMAC4 soap_in_lkf2__addProductTypeResponse(struct soap *soap, const char *tag, lkf2__addProductTypeResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (lkf2__addProductTypeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_lkf2__addProductTypeResponse, sizeof(lkf2__addProductTypeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_lkf2__addProductTypeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (lkf2__addProductTypeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (lkf2__addProductTypeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_lkf2__addProductTypeResponse, SOAP_TYPE_lkf2__addProductTypeResponse, sizeof(lkf2__addProductTypeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 lkf2__addProductTypeResponse * SOAP_FMAC2 soap_instantiate_lkf2__addProductTypeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_lkf2__addProductTypeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	lkf2__addProductTypeResponse *p;
	size_t k = sizeof(lkf2__addProductTypeResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_lkf2__addProductTypeResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, lkf2__addProductTypeResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, lkf2__addProductTypeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated lkf2__addProductTypeResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int lkf2__addProductTypeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_lkf2__addProductTypeResponse(soap, tag ? tag : "lkf2:addProductTypeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *lkf2__addProductTypeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_lkf2__addProductTypeResponse(soap, this, tag, type);
}

SOAP_FMAC3 lkf2__addProductTypeResponse * SOAP_FMAC4 soap_get_lkf2__addProductTypeResponse(struct soap *soap, lkf2__addProductTypeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_lkf2__addProductTypeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void lkf2__addProductType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->lkf2__addProductType::arg0 = NULL;
}

void lkf2__addProductType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTolkf2__productType(soap, &this->lkf2__addProductType::arg0);
#endif
}

int lkf2__addProductType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_lkf2__addProductType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_lkf2__addProductType(struct soap *soap, const char *tag, int id, const lkf2__addProductType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_lkf2__addProductType), type))
		return soap->error;
	if (soap_out_PointerTolkf2__productType(soap, "arg0", -1, &a->lkf2__addProductType::arg0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *lkf2__addProductType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_lkf2__addProductType(soap, tag, this, type);
}

SOAP_FMAC3 lkf2__addProductType * SOAP_FMAC4 soap_in_lkf2__addProductType(struct soap *soap, const char *tag, lkf2__addProductType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (lkf2__addProductType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_lkf2__addProductType, sizeof(lkf2__addProductType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_lkf2__addProductType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (lkf2__addProductType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTolkf2__productType(soap, "arg0", &a->lkf2__addProductType::arg0, "lkf2:productType"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (lkf2__addProductType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_lkf2__addProductType, SOAP_TYPE_lkf2__addProductType, sizeof(lkf2__addProductType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 lkf2__addProductType * SOAP_FMAC2 soap_instantiate_lkf2__addProductType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_lkf2__addProductType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	lkf2__addProductType *p;
	size_t k = sizeof(lkf2__addProductType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_lkf2__addProductType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, lkf2__addProductType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, lkf2__addProductType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated lkf2__addProductType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int lkf2__addProductType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_lkf2__addProductType(soap, tag ? tag : "lkf2:addProductType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *lkf2__addProductType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_lkf2__addProductType(soap, this, tag, type);
}

SOAP_FMAC3 lkf2__addProductType * SOAP_FMAC4 soap_get_lkf2__addProductType(struct soap *soap, lkf2__addProductType *p, const char *tag, const char *type)
{
	if ((p = soap_in_lkf2__addProductType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void lkf2__getOrderListByInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTolkf2__order(soap, &this->lkf2__getOrderListByInfoResponse::return_);
}

void lkf2__getOrderListByInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTolkf2__order(soap, &this->lkf2__getOrderListByInfoResponse::return_);
#endif
}

int lkf2__getOrderListByInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_lkf2__getOrderListByInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_lkf2__getOrderListByInfoResponse(struct soap *soap, const char *tag, int id, const lkf2__getOrderListByInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_lkf2__getOrderListByInfoResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTolkf2__order(soap, "return", -1, &a->lkf2__getOrderListByInfoResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *lkf2__getOrderListByInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_lkf2__getOrderListByInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 lkf2__getOrderListByInfoResponse * SOAP_FMAC4 soap_in_lkf2__getOrderListByInfoResponse(struct soap *soap, const char *tag, lkf2__getOrderListByInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (lkf2__getOrderListByInfoResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_lkf2__getOrderListByInfoResponse, sizeof(lkf2__getOrderListByInfoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_lkf2__getOrderListByInfoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (lkf2__getOrderListByInfoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTolkf2__order(soap, "return", &a->lkf2__getOrderListByInfoResponse::return_, "lkf2:order"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (lkf2__getOrderListByInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_lkf2__getOrderListByInfoResponse, SOAP_TYPE_lkf2__getOrderListByInfoResponse, sizeof(lkf2__getOrderListByInfoResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 lkf2__getOrderListByInfoResponse * SOAP_FMAC2 soap_instantiate_lkf2__getOrderListByInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_lkf2__getOrderListByInfoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	lkf2__getOrderListByInfoResponse *p;
	size_t k = sizeof(lkf2__getOrderListByInfoResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_lkf2__getOrderListByInfoResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, lkf2__getOrderListByInfoResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, lkf2__getOrderListByInfoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated lkf2__getOrderListByInfoResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int lkf2__getOrderListByInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_lkf2__getOrderListByInfoResponse(soap, tag ? tag : "lkf2:getOrderListByInfoResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *lkf2__getOrderListByInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_lkf2__getOrderListByInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 lkf2__getOrderListByInfoResponse * SOAP_FMAC4 soap_get_lkf2__getOrderListByInfoResponse(struct soap *soap, lkf2__getOrderListByInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_lkf2__getOrderListByInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void lkf2__getOrderListByInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->lkf2__getOrderListByInfo::arg0 = NULL;
}

void lkf2__getOrderListByInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTolkf2__order(soap, &this->lkf2__getOrderListByInfo::arg0);
#endif
}

int lkf2__getOrderListByInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_lkf2__getOrderListByInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_lkf2__getOrderListByInfo(struct soap *soap, const char *tag, int id, const lkf2__getOrderListByInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_lkf2__getOrderListByInfo), type))
		return soap->error;
	if (soap_out_PointerTolkf2__order(soap, "arg0", -1, &a->lkf2__getOrderListByInfo::arg0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *lkf2__getOrderListByInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_lkf2__getOrderListByInfo(soap, tag, this, type);
}

SOAP_FMAC3 lkf2__getOrderListByInfo * SOAP_FMAC4 soap_in_lkf2__getOrderListByInfo(struct soap *soap, const char *tag, lkf2__getOrderListByInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (lkf2__getOrderListByInfo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_lkf2__getOrderListByInfo, sizeof(lkf2__getOrderListByInfo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_lkf2__getOrderListByInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (lkf2__getOrderListByInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTolkf2__order(soap, "arg0", &a->lkf2__getOrderListByInfo::arg0, "lkf2:order"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (lkf2__getOrderListByInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_lkf2__getOrderListByInfo, SOAP_TYPE_lkf2__getOrderListByInfo, sizeof(lkf2__getOrderListByInfo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 lkf2__getOrderListByInfo * SOAP_FMAC2 soap_instantiate_lkf2__getOrderListByInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_lkf2__getOrderListByInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	lkf2__getOrderListByInfo *p;
	size_t k = sizeof(lkf2__getOrderListByInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_lkf2__getOrderListByInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, lkf2__getOrderListByInfo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, lkf2__getOrderListByInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated lkf2__getOrderListByInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int lkf2__getOrderListByInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_lkf2__getOrderListByInfo(soap, tag ? tag : "lkf2:getOrderListByInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *lkf2__getOrderListByInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_lkf2__getOrderListByInfo(soap, this, tag, type);
}

SOAP_FMAC3 lkf2__getOrderListByInfo * SOAP_FMAC4 soap_get_lkf2__getOrderListByInfo(struct soap *soap, lkf2__getOrderListByInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_lkf2__getOrderListByInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void lkf2__getClientListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTolkf2__client(soap, &this->lkf2__getClientListResponse::return_);
}

void lkf2__getClientListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTolkf2__client(soap, &this->lkf2__getClientListResponse::return_);
#endif
}

int lkf2__getClientListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_lkf2__getClientListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_lkf2__getClientListResponse(struct soap *soap, const char *tag, int id, const lkf2__getClientListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_lkf2__getClientListResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTolkf2__client(soap, "return", -1, &a->lkf2__getClientListResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *lkf2__getClientListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_lkf2__getClientListResponse(soap, tag, this, type);
}

SOAP_FMAC3 lkf2__getClientListResponse * SOAP_FMAC4 soap_in_lkf2__getClientListResponse(struct soap *soap, const char *tag, lkf2__getClientListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (lkf2__getClientListResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_lkf2__getClientListResponse, sizeof(lkf2__getClientListResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_lkf2__getClientListResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (lkf2__getClientListResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTolkf2__client(soap, "return", &a->lkf2__getClientListResponse::return_, "lkf2:client"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (lkf2__getClientListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_lkf2__getClientListResponse, SOAP_TYPE_lkf2__getClientListResponse, sizeof(lkf2__getClientListResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 lkf2__getClientListResponse * SOAP_FMAC2 soap_instantiate_lkf2__getClientListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_lkf2__getClientListResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	lkf2__getClientListResponse *p;
	size_t k = sizeof(lkf2__getClientListResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_lkf2__getClientListResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, lkf2__getClientListResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, lkf2__getClientListResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated lkf2__getClientListResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int lkf2__getClientListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_lkf2__getClientListResponse(soap, tag ? tag : "lkf2:getClientListResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *lkf2__getClientListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_lkf2__getClientListResponse(soap, this, tag, type);
}

SOAP_FMAC3 lkf2__getClientListResponse * SOAP_FMAC4 soap_get_lkf2__getClientListResponse(struct soap *soap, lkf2__getClientListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_lkf2__getClientListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void lkf2__getClientList::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void lkf2__getClientList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int lkf2__getClientList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_lkf2__getClientList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_lkf2__getClientList(struct soap *soap, const char *tag, int id, const lkf2__getClientList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_lkf2__getClientList), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *lkf2__getClientList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_lkf2__getClientList(soap, tag, this, type);
}

SOAP_FMAC3 lkf2__getClientList * SOAP_FMAC4 soap_in_lkf2__getClientList(struct soap *soap, const char *tag, lkf2__getClientList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (lkf2__getClientList*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_lkf2__getClientList, sizeof(lkf2__getClientList), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_lkf2__getClientList)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (lkf2__getClientList *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (lkf2__getClientList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_lkf2__getClientList, SOAP_TYPE_lkf2__getClientList, sizeof(lkf2__getClientList), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 lkf2__getClientList * SOAP_FMAC2 soap_instantiate_lkf2__getClientList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_lkf2__getClientList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	lkf2__getClientList *p;
	size_t k = sizeof(lkf2__getClientList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_lkf2__getClientList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, lkf2__getClientList);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, lkf2__getClientList, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated lkf2__getClientList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int lkf2__getClientList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_lkf2__getClientList(soap, tag ? tag : "lkf2:getClientList", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *lkf2__getClientList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_lkf2__getClientList(soap, this, tag, type);
}

SOAP_FMAC3 lkf2__getClientList * SOAP_FMAC4 soap_get_lkf2__getClientList(struct soap *soap, lkf2__getClientList *p, const char *tag, const char *type)
{
	if ((p = soap_in_lkf2__getClientList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void lkf2__productType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->lkf2__productType::typeId);
	this->lkf2__productType::typeName = NULL;
	this->lkf2__productType::typeProduct = NULL;
	soap_default_int(soap, &this->lkf2__productType::typeProductId);
}

void lkf2__productType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->lkf2__productType::typeName);
	soap_serialize_PointerTostd__string(soap, &this->lkf2__productType::typeProduct);
#endif
}

int lkf2__productType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_lkf2__productType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_lkf2__productType(struct soap *soap, const char *tag, int id, const lkf2__productType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_lkf2__productType), type))
		return soap->error;
	if (soap_out_int(soap, "typeId", -1, &a->lkf2__productType::typeId, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "typeName", -1, &a->lkf2__productType::typeName, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "typeProduct", -1, &a->lkf2__productType::typeProduct, ""))
		return soap->error;
	if (soap_out_int(soap, "typeProductId", -1, &a->lkf2__productType::typeProductId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *lkf2__productType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_lkf2__productType(soap, tag, this, type);
}

SOAP_FMAC3 lkf2__productType * SOAP_FMAC4 soap_in_lkf2__productType(struct soap *soap, const char *tag, lkf2__productType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (lkf2__productType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_lkf2__productType, sizeof(lkf2__productType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_lkf2__productType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (lkf2__productType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_typeId1 = 1;
	size_t soap_flag_typeName1 = 1;
	size_t soap_flag_typeProduct1 = 1;
	size_t soap_flag_typeProductId1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_typeId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "typeId", &a->lkf2__productType::typeId, "xsd:int"))
				{	soap_flag_typeId1--;
					continue;
				}
			}
			if (soap_flag_typeName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "typeName", &a->lkf2__productType::typeName, "xsd:string"))
				{	soap_flag_typeName1--;
					continue;
				}
			}
			if (soap_flag_typeProduct1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "typeProduct", &a->lkf2__productType::typeProduct, "xsd:string"))
				{	soap_flag_typeProduct1--;
					continue;
				}
			}
			if (soap_flag_typeProductId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "typeProductId", &a->lkf2__productType::typeProductId, "xsd:int"))
				{	soap_flag_typeProductId1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_typeId1 > 0 || soap_flag_typeProductId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (lkf2__productType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_lkf2__productType, SOAP_TYPE_lkf2__productType, sizeof(lkf2__productType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 lkf2__productType * SOAP_FMAC2 soap_instantiate_lkf2__productType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_lkf2__productType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	lkf2__productType *p;
	size_t k = sizeof(lkf2__productType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_lkf2__productType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, lkf2__productType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, lkf2__productType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated lkf2__productType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int lkf2__productType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_lkf2__productType(soap, tag ? tag : "lkf2:productType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *lkf2__productType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_lkf2__productType(soap, this, tag, type);
}

SOAP_FMAC3 lkf2__productType * SOAP_FMAC4 soap_get_lkf2__productType(struct soap *soap, lkf2__productType *p, const char *tag, const char *type)
{
	if ((p = soap_in_lkf2__productType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void lkf2__getProductTypeByProNameResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTolkf2__productType(soap, &this->lkf2__getProductTypeByProNameResponse::return_);
}

void lkf2__getProductTypeByProNameResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTolkf2__productType(soap, &this->lkf2__getProductTypeByProNameResponse::return_);
#endif
}

int lkf2__getProductTypeByProNameResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_lkf2__getProductTypeByProNameResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_lkf2__getProductTypeByProNameResponse(struct soap *soap, const char *tag, int id, const lkf2__getProductTypeByProNameResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_lkf2__getProductTypeByProNameResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTolkf2__productType(soap, "return", -1, &a->lkf2__getProductTypeByProNameResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *lkf2__getProductTypeByProNameResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_lkf2__getProductTypeByProNameResponse(soap, tag, this, type);
}

SOAP_FMAC3 lkf2__getProductTypeByProNameResponse * SOAP_FMAC4 soap_in_lkf2__getProductTypeByProNameResponse(struct soap *soap, const char *tag, lkf2__getProductTypeByProNameResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (lkf2__getProductTypeByProNameResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_lkf2__getProductTypeByProNameResponse, sizeof(lkf2__getProductTypeByProNameResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_lkf2__getProductTypeByProNameResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (lkf2__getProductTypeByProNameResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTolkf2__productType(soap, "return", &a->lkf2__getProductTypeByProNameResponse::return_, "lkf2:productType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (lkf2__getProductTypeByProNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_lkf2__getProductTypeByProNameResponse, SOAP_TYPE_lkf2__getProductTypeByProNameResponse, sizeof(lkf2__getProductTypeByProNameResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 lkf2__getProductTypeByProNameResponse * SOAP_FMAC2 soap_instantiate_lkf2__getProductTypeByProNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_lkf2__getProductTypeByProNameResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	lkf2__getProductTypeByProNameResponse *p;
	size_t k = sizeof(lkf2__getProductTypeByProNameResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_lkf2__getProductTypeByProNameResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, lkf2__getProductTypeByProNameResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, lkf2__getProductTypeByProNameResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated lkf2__getProductTypeByProNameResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int lkf2__getProductTypeByProNameResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_lkf2__getProductTypeByProNameResponse(soap, tag ? tag : "lkf2:getProductTypeByProNameResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *lkf2__getProductTypeByProNameResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_lkf2__getProductTypeByProNameResponse(soap, this, tag, type);
}

SOAP_FMAC3 lkf2__getProductTypeByProNameResponse * SOAP_FMAC4 soap_get_lkf2__getProductTypeByProNameResponse(struct soap *soap, lkf2__getProductTypeByProNameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_lkf2__getProductTypeByProNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void lkf2__getProductTypeByProName::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->lkf2__getProductTypeByProName::arg0 = NULL;
}

void lkf2__getProductTypeByProName::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->lkf2__getProductTypeByProName::arg0);
#endif
}

int lkf2__getProductTypeByProName::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_lkf2__getProductTypeByProName(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_lkf2__getProductTypeByProName(struct soap *soap, const char *tag, int id, const lkf2__getProductTypeByProName *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_lkf2__getProductTypeByProName), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &a->lkf2__getProductTypeByProName::arg0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *lkf2__getProductTypeByProName::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_lkf2__getProductTypeByProName(soap, tag, this, type);
}

SOAP_FMAC3 lkf2__getProductTypeByProName * SOAP_FMAC4 soap_in_lkf2__getProductTypeByProName(struct soap *soap, const char *tag, lkf2__getProductTypeByProName *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (lkf2__getProductTypeByProName*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_lkf2__getProductTypeByProName, sizeof(lkf2__getProductTypeByProName), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_lkf2__getProductTypeByProName)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (lkf2__getProductTypeByProName *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg0", &a->lkf2__getProductTypeByProName::arg0, "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (lkf2__getProductTypeByProName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_lkf2__getProductTypeByProName, SOAP_TYPE_lkf2__getProductTypeByProName, sizeof(lkf2__getProductTypeByProName), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 lkf2__getProductTypeByProName * SOAP_FMAC2 soap_instantiate_lkf2__getProductTypeByProName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_lkf2__getProductTypeByProName(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	lkf2__getProductTypeByProName *p;
	size_t k = sizeof(lkf2__getProductTypeByProName);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_lkf2__getProductTypeByProName, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, lkf2__getProductTypeByProName);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, lkf2__getProductTypeByProName, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated lkf2__getProductTypeByProName location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int lkf2__getProductTypeByProName::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_lkf2__getProductTypeByProName(soap, tag ? tag : "lkf2:getProductTypeByProName", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *lkf2__getProductTypeByProName::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_lkf2__getProductTypeByProName(soap, this, tag, type);
}

SOAP_FMAC3 lkf2__getProductTypeByProName * SOAP_FMAC4 soap_get_lkf2__getProductTypeByProName(struct soap *soap, lkf2__getProductTypeByProName *p, const char *tag, const char *type)
{
	if ((p = soap_in_lkf2__getProductTypeByProName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void lkf2__getClientLikeListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTolkf2__client(soap, &this->lkf2__getClientLikeListResponse::return_);
}

void lkf2__getClientLikeListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTolkf2__client(soap, &this->lkf2__getClientLikeListResponse::return_);
#endif
}

int lkf2__getClientLikeListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_lkf2__getClientLikeListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_lkf2__getClientLikeListResponse(struct soap *soap, const char *tag, int id, const lkf2__getClientLikeListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_lkf2__getClientLikeListResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTolkf2__client(soap, "return", -1, &a->lkf2__getClientLikeListResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *lkf2__getClientLikeListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_lkf2__getClientLikeListResponse(soap, tag, this, type);
}

SOAP_FMAC3 lkf2__getClientLikeListResponse * SOAP_FMAC4 soap_in_lkf2__getClientLikeListResponse(struct soap *soap, const char *tag, lkf2__getClientLikeListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (lkf2__getClientLikeListResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_lkf2__getClientLikeListResponse, sizeof(lkf2__getClientLikeListResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_lkf2__getClientLikeListResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (lkf2__getClientLikeListResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTolkf2__client(soap, "return", &a->lkf2__getClientLikeListResponse::return_, "lkf2:client"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (lkf2__getClientLikeListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_lkf2__getClientLikeListResponse, SOAP_TYPE_lkf2__getClientLikeListResponse, sizeof(lkf2__getClientLikeListResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 lkf2__getClientLikeListResponse * SOAP_FMAC2 soap_instantiate_lkf2__getClientLikeListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_lkf2__getClientLikeListResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	lkf2__getClientLikeListResponse *p;
	size_t k = sizeof(lkf2__getClientLikeListResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_lkf2__getClientLikeListResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, lkf2__getClientLikeListResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, lkf2__getClientLikeListResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated lkf2__getClientLikeListResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int lkf2__getClientLikeListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_lkf2__getClientLikeListResponse(soap, tag ? tag : "lkf2:getClientLikeListResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *lkf2__getClientLikeListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_lkf2__getClientLikeListResponse(soap, this, tag, type);
}

SOAP_FMAC3 lkf2__getClientLikeListResponse * SOAP_FMAC4 soap_get_lkf2__getClientLikeListResponse(struct soap *soap, lkf2__getClientLikeListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_lkf2__getClientLikeListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void lkf2__getClientLikeList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->lkf2__getClientLikeList::arg0 = NULL;
}

void lkf2__getClientLikeList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->lkf2__getClientLikeList::arg0);
#endif
}

int lkf2__getClientLikeList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_lkf2__getClientLikeList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_lkf2__getClientLikeList(struct soap *soap, const char *tag, int id, const lkf2__getClientLikeList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_lkf2__getClientLikeList), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &a->lkf2__getClientLikeList::arg0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *lkf2__getClientLikeList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_lkf2__getClientLikeList(soap, tag, this, type);
}

SOAP_FMAC3 lkf2__getClientLikeList * SOAP_FMAC4 soap_in_lkf2__getClientLikeList(struct soap *soap, const char *tag, lkf2__getClientLikeList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (lkf2__getClientLikeList*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_lkf2__getClientLikeList, sizeof(lkf2__getClientLikeList), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_lkf2__getClientLikeList)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (lkf2__getClientLikeList *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg0", &a->lkf2__getClientLikeList::arg0, "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (lkf2__getClientLikeList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_lkf2__getClientLikeList, SOAP_TYPE_lkf2__getClientLikeList, sizeof(lkf2__getClientLikeList), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 lkf2__getClientLikeList * SOAP_FMAC2 soap_instantiate_lkf2__getClientLikeList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_lkf2__getClientLikeList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	lkf2__getClientLikeList *p;
	size_t k = sizeof(lkf2__getClientLikeList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_lkf2__getClientLikeList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, lkf2__getClientLikeList);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, lkf2__getClientLikeList, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated lkf2__getClientLikeList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int lkf2__getClientLikeList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_lkf2__getClientLikeList(soap, tag ? tag : "lkf2:getClientLikeList", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *lkf2__getClientLikeList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_lkf2__getClientLikeList(soap, this, tag, type);
}

SOAP_FMAC3 lkf2__getClientLikeList * SOAP_FMAC4 soap_get_lkf2__getClientLikeList(struct soap *soap, lkf2__getClientLikeList *p, const char *tag, const char *type)
{
	if ((p = soap_in_lkf2__getClientLikeList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void lkf2__getOrderLikeListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTolkf2__order(soap, &this->lkf2__getOrderLikeListResponse::return_);
}

void lkf2__getOrderLikeListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTolkf2__order(soap, &this->lkf2__getOrderLikeListResponse::return_);
#endif
}

int lkf2__getOrderLikeListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_lkf2__getOrderLikeListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_lkf2__getOrderLikeListResponse(struct soap *soap, const char *tag, int id, const lkf2__getOrderLikeListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_lkf2__getOrderLikeListResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTolkf2__order(soap, "return", -1, &a->lkf2__getOrderLikeListResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *lkf2__getOrderLikeListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_lkf2__getOrderLikeListResponse(soap, tag, this, type);
}

SOAP_FMAC3 lkf2__getOrderLikeListResponse * SOAP_FMAC4 soap_in_lkf2__getOrderLikeListResponse(struct soap *soap, const char *tag, lkf2__getOrderLikeListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (lkf2__getOrderLikeListResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_lkf2__getOrderLikeListResponse, sizeof(lkf2__getOrderLikeListResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_lkf2__getOrderLikeListResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (lkf2__getOrderLikeListResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTolkf2__order(soap, "return", &a->lkf2__getOrderLikeListResponse::return_, "lkf2:order"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (lkf2__getOrderLikeListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_lkf2__getOrderLikeListResponse, SOAP_TYPE_lkf2__getOrderLikeListResponse, sizeof(lkf2__getOrderLikeListResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 lkf2__getOrderLikeListResponse * SOAP_FMAC2 soap_instantiate_lkf2__getOrderLikeListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_lkf2__getOrderLikeListResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	lkf2__getOrderLikeListResponse *p;
	size_t k = sizeof(lkf2__getOrderLikeListResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_lkf2__getOrderLikeListResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, lkf2__getOrderLikeListResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, lkf2__getOrderLikeListResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated lkf2__getOrderLikeListResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int lkf2__getOrderLikeListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_lkf2__getOrderLikeListResponse(soap, tag ? tag : "lkf2:getOrderLikeListResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *lkf2__getOrderLikeListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_lkf2__getOrderLikeListResponse(soap, this, tag, type);
}

SOAP_FMAC3 lkf2__getOrderLikeListResponse * SOAP_FMAC4 soap_get_lkf2__getOrderLikeListResponse(struct soap *soap, lkf2__getOrderLikeListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_lkf2__getOrderLikeListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void lkf2__getOrderLikeList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->lkf2__getOrderLikeList::arg0 = NULL;
}

void lkf2__getOrderLikeList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->lkf2__getOrderLikeList::arg0);
#endif
}

int lkf2__getOrderLikeList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_lkf2__getOrderLikeList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_lkf2__getOrderLikeList(struct soap *soap, const char *tag, int id, const lkf2__getOrderLikeList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_lkf2__getOrderLikeList), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &a->lkf2__getOrderLikeList::arg0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *lkf2__getOrderLikeList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_lkf2__getOrderLikeList(soap, tag, this, type);
}

SOAP_FMAC3 lkf2__getOrderLikeList * SOAP_FMAC4 soap_in_lkf2__getOrderLikeList(struct soap *soap, const char *tag, lkf2__getOrderLikeList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (lkf2__getOrderLikeList*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_lkf2__getOrderLikeList, sizeof(lkf2__getOrderLikeList), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_lkf2__getOrderLikeList)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (lkf2__getOrderLikeList *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg0", &a->lkf2__getOrderLikeList::arg0, "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (lkf2__getOrderLikeList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_lkf2__getOrderLikeList, SOAP_TYPE_lkf2__getOrderLikeList, sizeof(lkf2__getOrderLikeList), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 lkf2__getOrderLikeList * SOAP_FMAC2 soap_instantiate_lkf2__getOrderLikeList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_lkf2__getOrderLikeList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	lkf2__getOrderLikeList *p;
	size_t k = sizeof(lkf2__getOrderLikeList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_lkf2__getOrderLikeList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, lkf2__getOrderLikeList);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, lkf2__getOrderLikeList, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated lkf2__getOrderLikeList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int lkf2__getOrderLikeList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_lkf2__getOrderLikeList(soap, tag ? tag : "lkf2:getOrderLikeList", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *lkf2__getOrderLikeList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_lkf2__getOrderLikeList(soap, this, tag, type);
}

SOAP_FMAC3 lkf2__getOrderLikeList * SOAP_FMAC4 soap_get_lkf2__getOrderLikeList(struct soap *soap, lkf2__getOrderLikeList *p, const char *tag, const char *type)
{
	if ((p = soap_in_lkf2__getOrderLikeList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void lkf2__deleteProductByInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void lkf2__deleteProductByInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int lkf2__deleteProductByInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_lkf2__deleteProductByInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_lkf2__deleteProductByInfoResponse(struct soap *soap, const char *tag, int id, const lkf2__deleteProductByInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_lkf2__deleteProductByInfoResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *lkf2__deleteProductByInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_lkf2__deleteProductByInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 lkf2__deleteProductByInfoResponse * SOAP_FMAC4 soap_in_lkf2__deleteProductByInfoResponse(struct soap *soap, const char *tag, lkf2__deleteProductByInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (lkf2__deleteProductByInfoResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_lkf2__deleteProductByInfoResponse, sizeof(lkf2__deleteProductByInfoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_lkf2__deleteProductByInfoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (lkf2__deleteProductByInfoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (lkf2__deleteProductByInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_lkf2__deleteProductByInfoResponse, SOAP_TYPE_lkf2__deleteProductByInfoResponse, sizeof(lkf2__deleteProductByInfoResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 lkf2__deleteProductByInfoResponse * SOAP_FMAC2 soap_instantiate_lkf2__deleteProductByInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_lkf2__deleteProductByInfoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	lkf2__deleteProductByInfoResponse *p;
	size_t k = sizeof(lkf2__deleteProductByInfoResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_lkf2__deleteProductByInfoResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, lkf2__deleteProductByInfoResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, lkf2__deleteProductByInfoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated lkf2__deleteProductByInfoResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int lkf2__deleteProductByInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_lkf2__deleteProductByInfoResponse(soap, tag ? tag : "lkf2:deleteProductByInfoResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *lkf2__deleteProductByInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_lkf2__deleteProductByInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 lkf2__deleteProductByInfoResponse * SOAP_FMAC4 soap_get_lkf2__deleteProductByInfoResponse(struct soap *soap, lkf2__deleteProductByInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_lkf2__deleteProductByInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void lkf2__deleteProductByInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->lkf2__deleteProductByInfo::arg0 = NULL;
}

void lkf2__deleteProductByInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTolkf2__product(soap, &this->lkf2__deleteProductByInfo::arg0);
#endif
}

int lkf2__deleteProductByInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_lkf2__deleteProductByInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_lkf2__deleteProductByInfo(struct soap *soap, const char *tag, int id, const lkf2__deleteProductByInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_lkf2__deleteProductByInfo), type))
		return soap->error;
	if (soap_out_PointerTolkf2__product(soap, "arg0", -1, &a->lkf2__deleteProductByInfo::arg0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *lkf2__deleteProductByInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_lkf2__deleteProductByInfo(soap, tag, this, type);
}

SOAP_FMAC3 lkf2__deleteProductByInfo * SOAP_FMAC4 soap_in_lkf2__deleteProductByInfo(struct soap *soap, const char *tag, lkf2__deleteProductByInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (lkf2__deleteProductByInfo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_lkf2__deleteProductByInfo, sizeof(lkf2__deleteProductByInfo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_lkf2__deleteProductByInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (lkf2__deleteProductByInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTolkf2__product(soap, "arg0", &a->lkf2__deleteProductByInfo::arg0, "lkf2:product"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (lkf2__deleteProductByInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_lkf2__deleteProductByInfo, SOAP_TYPE_lkf2__deleteProductByInfo, sizeof(lkf2__deleteProductByInfo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 lkf2__deleteProductByInfo * SOAP_FMAC2 soap_instantiate_lkf2__deleteProductByInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_lkf2__deleteProductByInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	lkf2__deleteProductByInfo *p;
	size_t k = sizeof(lkf2__deleteProductByInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_lkf2__deleteProductByInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, lkf2__deleteProductByInfo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, lkf2__deleteProductByInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated lkf2__deleteProductByInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int lkf2__deleteProductByInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_lkf2__deleteProductByInfo(soap, tag ? tag : "lkf2:deleteProductByInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *lkf2__deleteProductByInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_lkf2__deleteProductByInfo(soap, this, tag, type);
}

SOAP_FMAC3 lkf2__deleteProductByInfo * SOAP_FMAC4 soap_get_lkf2__deleteProductByInfo(struct soap *soap, lkf2__deleteProductByInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_lkf2__deleteProductByInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void lkf2__deleteClientByNameAndPwdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void lkf2__deleteClientByNameAndPwdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int lkf2__deleteClientByNameAndPwdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_lkf2__deleteClientByNameAndPwdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_lkf2__deleteClientByNameAndPwdResponse(struct soap *soap, const char *tag, int id, const lkf2__deleteClientByNameAndPwdResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_lkf2__deleteClientByNameAndPwdResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *lkf2__deleteClientByNameAndPwdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_lkf2__deleteClientByNameAndPwdResponse(soap, tag, this, type);
}

SOAP_FMAC3 lkf2__deleteClientByNameAndPwdResponse * SOAP_FMAC4 soap_in_lkf2__deleteClientByNameAndPwdResponse(struct soap *soap, const char *tag, lkf2__deleteClientByNameAndPwdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (lkf2__deleteClientByNameAndPwdResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_lkf2__deleteClientByNameAndPwdResponse, sizeof(lkf2__deleteClientByNameAndPwdResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_lkf2__deleteClientByNameAndPwdResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (lkf2__deleteClientByNameAndPwdResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (lkf2__deleteClientByNameAndPwdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_lkf2__deleteClientByNameAndPwdResponse, SOAP_TYPE_lkf2__deleteClientByNameAndPwdResponse, sizeof(lkf2__deleteClientByNameAndPwdResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 lkf2__deleteClientByNameAndPwdResponse * SOAP_FMAC2 soap_instantiate_lkf2__deleteClientByNameAndPwdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_lkf2__deleteClientByNameAndPwdResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	lkf2__deleteClientByNameAndPwdResponse *p;
	size_t k = sizeof(lkf2__deleteClientByNameAndPwdResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_lkf2__deleteClientByNameAndPwdResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, lkf2__deleteClientByNameAndPwdResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, lkf2__deleteClientByNameAndPwdResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated lkf2__deleteClientByNameAndPwdResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int lkf2__deleteClientByNameAndPwdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_lkf2__deleteClientByNameAndPwdResponse(soap, tag ? tag : "lkf2:deleteClientByNameAndPwdResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *lkf2__deleteClientByNameAndPwdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_lkf2__deleteClientByNameAndPwdResponse(soap, this, tag, type);
}

SOAP_FMAC3 lkf2__deleteClientByNameAndPwdResponse * SOAP_FMAC4 soap_get_lkf2__deleteClientByNameAndPwdResponse(struct soap *soap, lkf2__deleteClientByNameAndPwdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_lkf2__deleteClientByNameAndPwdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void lkf2__deleteClientByNameAndPwd::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->lkf2__deleteClientByNameAndPwd::arg0 = NULL;
	this->lkf2__deleteClientByNameAndPwd::arg1 = NULL;
}

void lkf2__deleteClientByNameAndPwd::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->lkf2__deleteClientByNameAndPwd::arg0);
	soap_serialize_PointerTostd__string(soap, &this->lkf2__deleteClientByNameAndPwd::arg1);
#endif
}

int lkf2__deleteClientByNameAndPwd::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_lkf2__deleteClientByNameAndPwd(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_lkf2__deleteClientByNameAndPwd(struct soap *soap, const char *tag, int id, const lkf2__deleteClientByNameAndPwd *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_lkf2__deleteClientByNameAndPwd), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &a->lkf2__deleteClientByNameAndPwd::arg0, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg1", -1, &a->lkf2__deleteClientByNameAndPwd::arg1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *lkf2__deleteClientByNameAndPwd::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_lkf2__deleteClientByNameAndPwd(soap, tag, this, type);
}

SOAP_FMAC3 lkf2__deleteClientByNameAndPwd * SOAP_FMAC4 soap_in_lkf2__deleteClientByNameAndPwd(struct soap *soap, const char *tag, lkf2__deleteClientByNameAndPwd *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (lkf2__deleteClientByNameAndPwd*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_lkf2__deleteClientByNameAndPwd, sizeof(lkf2__deleteClientByNameAndPwd), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_lkf2__deleteClientByNameAndPwd)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (lkf2__deleteClientByNameAndPwd *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg0", &a->lkf2__deleteClientByNameAndPwd::arg0, "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap_flag_arg11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg1", &a->lkf2__deleteClientByNameAndPwd::arg1, "xsd:string"))
				{	soap_flag_arg11--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (lkf2__deleteClientByNameAndPwd *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_lkf2__deleteClientByNameAndPwd, SOAP_TYPE_lkf2__deleteClientByNameAndPwd, sizeof(lkf2__deleteClientByNameAndPwd), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 lkf2__deleteClientByNameAndPwd * SOAP_FMAC2 soap_instantiate_lkf2__deleteClientByNameAndPwd(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_lkf2__deleteClientByNameAndPwd(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	lkf2__deleteClientByNameAndPwd *p;
	size_t k = sizeof(lkf2__deleteClientByNameAndPwd);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_lkf2__deleteClientByNameAndPwd, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, lkf2__deleteClientByNameAndPwd);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, lkf2__deleteClientByNameAndPwd, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated lkf2__deleteClientByNameAndPwd location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int lkf2__deleteClientByNameAndPwd::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_lkf2__deleteClientByNameAndPwd(soap, tag ? tag : "lkf2:deleteClientByNameAndPwd", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *lkf2__deleteClientByNameAndPwd::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_lkf2__deleteClientByNameAndPwd(soap, this, tag, type);
}

SOAP_FMAC3 lkf2__deleteClientByNameAndPwd * SOAP_FMAC4 soap_get_lkf2__deleteClientByNameAndPwd(struct soap *soap, lkf2__deleteClientByNameAndPwd *p, const char *tag, const char *type)
{
	if ((p = soap_in_lkf2__deleteClientByNameAndPwd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void lkf2__updateClientResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void lkf2__updateClientResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int lkf2__updateClientResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_lkf2__updateClientResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_lkf2__updateClientResponse(struct soap *soap, const char *tag, int id, const lkf2__updateClientResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_lkf2__updateClientResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *lkf2__updateClientResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_lkf2__updateClientResponse(soap, tag, this, type);
}

SOAP_FMAC3 lkf2__updateClientResponse * SOAP_FMAC4 soap_in_lkf2__updateClientResponse(struct soap *soap, const char *tag, lkf2__updateClientResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (lkf2__updateClientResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_lkf2__updateClientResponse, sizeof(lkf2__updateClientResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_lkf2__updateClientResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (lkf2__updateClientResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (lkf2__updateClientResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_lkf2__updateClientResponse, SOAP_TYPE_lkf2__updateClientResponse, sizeof(lkf2__updateClientResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 lkf2__updateClientResponse * SOAP_FMAC2 soap_instantiate_lkf2__updateClientResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_lkf2__updateClientResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	lkf2__updateClientResponse *p;
	size_t k = sizeof(lkf2__updateClientResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_lkf2__updateClientResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, lkf2__updateClientResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, lkf2__updateClientResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated lkf2__updateClientResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int lkf2__updateClientResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_lkf2__updateClientResponse(soap, tag ? tag : "lkf2:updateClientResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *lkf2__updateClientResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_lkf2__updateClientResponse(soap, this, tag, type);
}

SOAP_FMAC3 lkf2__updateClientResponse * SOAP_FMAC4 soap_get_lkf2__updateClientResponse(struct soap *soap, lkf2__updateClientResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_lkf2__updateClientResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void lkf2__client::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->lkf2__client::clientBought);
	this->lkf2__client::clientEmail = NULL;
	soap_default_int(soap, &this->lkf2__client::clientId);
	this->lkf2__client::clientImage = NULL;
	this->lkf2__client::clientName = NULL;
	this->lkf2__client::clientPhone = NULL;
	this->lkf2__client::clientPwd = NULL;
	this->lkf2__client::clientSignTime = NULL;
}

void lkf2__client::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->lkf2__client::clientEmail);
	soap_serialize_PointerTostd__string(soap, &this->lkf2__client::clientImage);
	soap_serialize_PointerTostd__string(soap, &this->lkf2__client::clientName);
	soap_serialize_PointerTostd__string(soap, &this->lkf2__client::clientPhone);
	soap_serialize_PointerTostd__string(soap, &this->lkf2__client::clientPwd);
	soap_serialize_PointerTodateTime(soap, &this->lkf2__client::clientSignTime);
#endif
}

int lkf2__client::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_lkf2__client(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_lkf2__client(struct soap *soap, const char *tag, int id, const lkf2__client *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_lkf2__client), type))
		return soap->error;
	if (soap_out_int(soap, "clientBought", -1, &a->lkf2__client::clientBought, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "clientEmail", -1, &a->lkf2__client::clientEmail, ""))
		return soap->error;
	if (soap_out_int(soap, "clientId", -1, &a->lkf2__client::clientId, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "clientImage", -1, &a->lkf2__client::clientImage, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "clientName", -1, &a->lkf2__client::clientName, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "clientPhone", -1, &a->lkf2__client::clientPhone, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "clientPwd", -1, &a->lkf2__client::clientPwd, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "clientSignTime", -1, &a->lkf2__client::clientSignTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *lkf2__client::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_lkf2__client(soap, tag, this, type);
}

SOAP_FMAC3 lkf2__client * SOAP_FMAC4 soap_in_lkf2__client(struct soap *soap, const char *tag, lkf2__client *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (lkf2__client*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_lkf2__client, sizeof(lkf2__client), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_lkf2__client)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (lkf2__client *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_clientBought1 = 1;
	size_t soap_flag_clientEmail1 = 1;
	size_t soap_flag_clientId1 = 1;
	size_t soap_flag_clientImage1 = 1;
	size_t soap_flag_clientName1 = 1;
	size_t soap_flag_clientPhone1 = 1;
	size_t soap_flag_clientPwd1 = 1;
	size_t soap_flag_clientSignTime1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_clientBought1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "clientBought", &a->lkf2__client::clientBought, "xsd:int"))
				{	soap_flag_clientBought1--;
					continue;
				}
			}
			if (soap_flag_clientEmail1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "clientEmail", &a->lkf2__client::clientEmail, "xsd:string"))
				{	soap_flag_clientEmail1--;
					continue;
				}
			}
			if (soap_flag_clientId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "clientId", &a->lkf2__client::clientId, "xsd:int"))
				{	soap_flag_clientId1--;
					continue;
				}
			}
			if (soap_flag_clientImage1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "clientImage", &a->lkf2__client::clientImage, "xsd:string"))
				{	soap_flag_clientImage1--;
					continue;
				}
			}
			if (soap_flag_clientName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "clientName", &a->lkf2__client::clientName, "xsd:string"))
				{	soap_flag_clientName1--;
					continue;
				}
			}
			if (soap_flag_clientPhone1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "clientPhone", &a->lkf2__client::clientPhone, "xsd:string"))
				{	soap_flag_clientPhone1--;
					continue;
				}
			}
			if (soap_flag_clientPwd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "clientPwd", &a->lkf2__client::clientPwd, "xsd:string"))
				{	soap_flag_clientPwd1--;
					continue;
				}
			}
			if (soap_flag_clientSignTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "clientSignTime", &a->lkf2__client::clientSignTime, "xsd:dateTime"))
				{	soap_flag_clientSignTime1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_clientBought1 > 0 || soap_flag_clientId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (lkf2__client *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_lkf2__client, SOAP_TYPE_lkf2__client, sizeof(lkf2__client), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 lkf2__client * SOAP_FMAC2 soap_instantiate_lkf2__client(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_lkf2__client(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	lkf2__client *p;
	size_t k = sizeof(lkf2__client);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_lkf2__client, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, lkf2__client);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, lkf2__client, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated lkf2__client location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int lkf2__client::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_lkf2__client(soap, tag ? tag : "lkf2:client", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *lkf2__client::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_lkf2__client(soap, this, tag, type);
}

SOAP_FMAC3 lkf2__client * SOAP_FMAC4 soap_get_lkf2__client(struct soap *soap, lkf2__client *p, const char *tag, const char *type)
{
	if ((p = soap_in_lkf2__client(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void lkf2__updateClient::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->lkf2__updateClient::arg0 = NULL;
}

void lkf2__updateClient::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTolkf2__client(soap, &this->lkf2__updateClient::arg0);
#endif
}

int lkf2__updateClient::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_lkf2__updateClient(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_lkf2__updateClient(struct soap *soap, const char *tag, int id, const lkf2__updateClient *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_lkf2__updateClient), type))
		return soap->error;
	if (soap_out_PointerTolkf2__client(soap, "arg0", -1, &a->lkf2__updateClient::arg0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *lkf2__updateClient::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_lkf2__updateClient(soap, tag, this, type);
}

SOAP_FMAC3 lkf2__updateClient * SOAP_FMAC4 soap_in_lkf2__updateClient(struct soap *soap, const char *tag, lkf2__updateClient *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (lkf2__updateClient*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_lkf2__updateClient, sizeof(lkf2__updateClient), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_lkf2__updateClient)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (lkf2__updateClient *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTolkf2__client(soap, "arg0", &a->lkf2__updateClient::arg0, "lkf2:client"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (lkf2__updateClient *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_lkf2__updateClient, SOAP_TYPE_lkf2__updateClient, sizeof(lkf2__updateClient), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 lkf2__updateClient * SOAP_FMAC2 soap_instantiate_lkf2__updateClient(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_lkf2__updateClient(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	lkf2__updateClient *p;
	size_t k = sizeof(lkf2__updateClient);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_lkf2__updateClient, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, lkf2__updateClient);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, lkf2__updateClient, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated lkf2__updateClient location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int lkf2__updateClient::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_lkf2__updateClient(soap, tag ? tag : "lkf2:updateClient", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *lkf2__updateClient::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_lkf2__updateClient(soap, this, tag, type);
}

SOAP_FMAC3 lkf2__updateClient * SOAP_FMAC4 soap_get_lkf2__updateClient(struct soap *soap, lkf2__updateClient *p, const char *tag, const char *type)
{
	if ((p = soap_in_lkf2__updateClient(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void lkf2__getProductListByInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTolkf2__product(soap, &this->lkf2__getProductListByInfoResponse::return_);
}

void lkf2__getProductListByInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTolkf2__product(soap, &this->lkf2__getProductListByInfoResponse::return_);
#endif
}

int lkf2__getProductListByInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_lkf2__getProductListByInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_lkf2__getProductListByInfoResponse(struct soap *soap, const char *tag, int id, const lkf2__getProductListByInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_lkf2__getProductListByInfoResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTolkf2__product(soap, "return", -1, &a->lkf2__getProductListByInfoResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *lkf2__getProductListByInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_lkf2__getProductListByInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 lkf2__getProductListByInfoResponse * SOAP_FMAC4 soap_in_lkf2__getProductListByInfoResponse(struct soap *soap, const char *tag, lkf2__getProductListByInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (lkf2__getProductListByInfoResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_lkf2__getProductListByInfoResponse, sizeof(lkf2__getProductListByInfoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_lkf2__getProductListByInfoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (lkf2__getProductListByInfoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTolkf2__product(soap, "return", &a->lkf2__getProductListByInfoResponse::return_, "lkf2:product"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (lkf2__getProductListByInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_lkf2__getProductListByInfoResponse, SOAP_TYPE_lkf2__getProductListByInfoResponse, sizeof(lkf2__getProductListByInfoResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 lkf2__getProductListByInfoResponse * SOAP_FMAC2 soap_instantiate_lkf2__getProductListByInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_lkf2__getProductListByInfoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	lkf2__getProductListByInfoResponse *p;
	size_t k = sizeof(lkf2__getProductListByInfoResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_lkf2__getProductListByInfoResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, lkf2__getProductListByInfoResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, lkf2__getProductListByInfoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated lkf2__getProductListByInfoResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int lkf2__getProductListByInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_lkf2__getProductListByInfoResponse(soap, tag ? tag : "lkf2:getProductListByInfoResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *lkf2__getProductListByInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_lkf2__getProductListByInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 lkf2__getProductListByInfoResponse * SOAP_FMAC4 soap_get_lkf2__getProductListByInfoResponse(struct soap *soap, lkf2__getProductListByInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_lkf2__getProductListByInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void lkf2__getProductListByInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->lkf2__getProductListByInfo::arg0 = NULL;
}

void lkf2__getProductListByInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTolkf2__product(soap, &this->lkf2__getProductListByInfo::arg0);
#endif
}

int lkf2__getProductListByInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_lkf2__getProductListByInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_lkf2__getProductListByInfo(struct soap *soap, const char *tag, int id, const lkf2__getProductListByInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_lkf2__getProductListByInfo), type))
		return soap->error;
	if (soap_out_PointerTolkf2__product(soap, "arg0", -1, &a->lkf2__getProductListByInfo::arg0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *lkf2__getProductListByInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_lkf2__getProductListByInfo(soap, tag, this, type);
}

SOAP_FMAC3 lkf2__getProductListByInfo * SOAP_FMAC4 soap_in_lkf2__getProductListByInfo(struct soap *soap, const char *tag, lkf2__getProductListByInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (lkf2__getProductListByInfo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_lkf2__getProductListByInfo, sizeof(lkf2__getProductListByInfo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_lkf2__getProductListByInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (lkf2__getProductListByInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTolkf2__product(soap, "arg0", &a->lkf2__getProductListByInfo::arg0, "lkf2:product"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (lkf2__getProductListByInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_lkf2__getProductListByInfo, SOAP_TYPE_lkf2__getProductListByInfo, sizeof(lkf2__getProductListByInfo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 lkf2__getProductListByInfo * SOAP_FMAC2 soap_instantiate_lkf2__getProductListByInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_lkf2__getProductListByInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	lkf2__getProductListByInfo *p;
	size_t k = sizeof(lkf2__getProductListByInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_lkf2__getProductListByInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, lkf2__getProductListByInfo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, lkf2__getProductListByInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated lkf2__getProductListByInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int lkf2__getProductListByInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_lkf2__getProductListByInfo(soap, tag ? tag : "lkf2:getProductListByInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *lkf2__getProductListByInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_lkf2__getProductListByInfo(soap, this, tag, type);
}

SOAP_FMAC3 lkf2__getProductListByInfo * SOAP_FMAC4 soap_get_lkf2__getProductListByInfo(struct soap *soap, lkf2__getProductListByInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_lkf2__getProductListByInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void lkf2__order::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->lkf2__order::orderCheck);
	this->lkf2__order::orderClient = NULL;
	soap_default_int(soap, &this->lkf2__order::orderClientId);
	this->lkf2__order::orderCost = NULL;
	soap_default_int(soap, &this->lkf2__order::orderHide);
	soap_default_int(soap, &this->lkf2__order::orderId);
	soap_default_int(soap, &this->lkf2__order::orderProductId);
	this->lkf2__order::orderProductName = NULL;
	soap_default_int(soap, &this->lkf2__order::orderProductNum);
	this->lkf2__order::orderProductStyle = NULL;
	this->lkf2__order::orderTime = NULL;
}

void lkf2__order::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->lkf2__order::orderClient);
	soap_serialize_PointerToxsd__decimal(soap, &this->lkf2__order::orderCost);
	soap_serialize_PointerTostd__string(soap, &this->lkf2__order::orderProductName);
	soap_serialize_PointerTostd__string(soap, &this->lkf2__order::orderProductStyle);
	soap_serialize_PointerTodateTime(soap, &this->lkf2__order::orderTime);
#endif
}

int lkf2__order::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_lkf2__order(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_lkf2__order(struct soap *soap, const char *tag, int id, const lkf2__order *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_lkf2__order), type))
		return soap->error;
	if (soap_out_int(soap, "orderCheck", -1, &a->lkf2__order::orderCheck, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "orderClient", -1, &a->lkf2__order::orderClient, ""))
		return soap->error;
	if (soap_out_int(soap, "orderClientId", -1, &a->lkf2__order::orderClientId, ""))
		return soap->error;
	if (soap_out_PointerToxsd__decimal(soap, "orderCost", -1, &a->lkf2__order::orderCost, ""))
		return soap->error;
	if (soap_out_int(soap, "orderHide", -1, &a->lkf2__order::orderHide, ""))
		return soap->error;
	if (soap_out_int(soap, "orderId", -1, &a->lkf2__order::orderId, ""))
		return soap->error;
	if (soap_out_int(soap, "orderProductId", -1, &a->lkf2__order::orderProductId, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "orderProductName", -1, &a->lkf2__order::orderProductName, ""))
		return soap->error;
	if (soap_out_int(soap, "orderProductNum", -1, &a->lkf2__order::orderProductNum, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "orderProductStyle", -1, &a->lkf2__order::orderProductStyle, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "orderTime", -1, &a->lkf2__order::orderTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *lkf2__order::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_lkf2__order(soap, tag, this, type);
}

SOAP_FMAC3 lkf2__order * SOAP_FMAC4 soap_in_lkf2__order(struct soap *soap, const char *tag, lkf2__order *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (lkf2__order*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_lkf2__order, sizeof(lkf2__order), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_lkf2__order)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (lkf2__order *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_orderCheck1 = 1;
	size_t soap_flag_orderClient1 = 1;
	size_t soap_flag_orderClientId1 = 1;
	size_t soap_flag_orderCost1 = 1;
	size_t soap_flag_orderHide1 = 1;
	size_t soap_flag_orderId1 = 1;
	size_t soap_flag_orderProductId1 = 1;
	size_t soap_flag_orderProductName1 = 1;
	size_t soap_flag_orderProductNum1 = 1;
	size_t soap_flag_orderProductStyle1 = 1;
	size_t soap_flag_orderTime1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_orderCheck1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "orderCheck", &a->lkf2__order::orderCheck, "xsd:int"))
				{	soap_flag_orderCheck1--;
					continue;
				}
			}
			if (soap_flag_orderClient1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "orderClient", &a->lkf2__order::orderClient, "xsd:string"))
				{	soap_flag_orderClient1--;
					continue;
				}
			}
			if (soap_flag_orderClientId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "orderClientId", &a->lkf2__order::orderClientId, "xsd:int"))
				{	soap_flag_orderClientId1--;
					continue;
				}
			}
			if (soap_flag_orderCost1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__decimal(soap, "orderCost", &a->lkf2__order::orderCost, "xsd:decimal"))
				{	soap_flag_orderCost1--;
					continue;
				}
			}
			if (soap_flag_orderHide1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "orderHide", &a->lkf2__order::orderHide, "xsd:int"))
				{	soap_flag_orderHide1--;
					continue;
				}
			}
			if (soap_flag_orderId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "orderId", &a->lkf2__order::orderId, "xsd:int"))
				{	soap_flag_orderId1--;
					continue;
				}
			}
			if (soap_flag_orderProductId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "orderProductId", &a->lkf2__order::orderProductId, "xsd:int"))
				{	soap_flag_orderProductId1--;
					continue;
				}
			}
			if (soap_flag_orderProductName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "orderProductName", &a->lkf2__order::orderProductName, "xsd:string"))
				{	soap_flag_orderProductName1--;
					continue;
				}
			}
			if (soap_flag_orderProductNum1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "orderProductNum", &a->lkf2__order::orderProductNum, "xsd:int"))
				{	soap_flag_orderProductNum1--;
					continue;
				}
			}
			if (soap_flag_orderProductStyle1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "orderProductStyle", &a->lkf2__order::orderProductStyle, "xsd:string"))
				{	soap_flag_orderProductStyle1--;
					continue;
				}
			}
			if (soap_flag_orderTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "orderTime", &a->lkf2__order::orderTime, "xsd:dateTime"))
				{	soap_flag_orderTime1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_orderCheck1 > 0 || soap_flag_orderClientId1 > 0 || soap_flag_orderHide1 > 0 || soap_flag_orderId1 > 0 || soap_flag_orderProductId1 > 0 || soap_flag_orderProductNum1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (lkf2__order *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_lkf2__order, SOAP_TYPE_lkf2__order, sizeof(lkf2__order), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 lkf2__order * SOAP_FMAC2 soap_instantiate_lkf2__order(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_lkf2__order(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	lkf2__order *p;
	size_t k = sizeof(lkf2__order);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_lkf2__order, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, lkf2__order);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, lkf2__order, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated lkf2__order location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int lkf2__order::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_lkf2__order(soap, tag ? tag : "lkf2:order", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *lkf2__order::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_lkf2__order(soap, this, tag, type);
}

SOAP_FMAC3 lkf2__order * SOAP_FMAC4 soap_get_lkf2__order(struct soap *soap, lkf2__order *p, const char *tag, const char *type)
{
	if ((p = soap_in_lkf2__order(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void lkf2__getOrderListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTolkf2__order(soap, &this->lkf2__getOrderListResponse::return_);
}

void lkf2__getOrderListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTolkf2__order(soap, &this->lkf2__getOrderListResponse::return_);
#endif
}

int lkf2__getOrderListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_lkf2__getOrderListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_lkf2__getOrderListResponse(struct soap *soap, const char *tag, int id, const lkf2__getOrderListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_lkf2__getOrderListResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTolkf2__order(soap, "return", -1, &a->lkf2__getOrderListResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *lkf2__getOrderListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_lkf2__getOrderListResponse(soap, tag, this, type);
}

SOAP_FMAC3 lkf2__getOrderListResponse * SOAP_FMAC4 soap_in_lkf2__getOrderListResponse(struct soap *soap, const char *tag, lkf2__getOrderListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (lkf2__getOrderListResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_lkf2__getOrderListResponse, sizeof(lkf2__getOrderListResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_lkf2__getOrderListResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (lkf2__getOrderListResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTolkf2__order(soap, "return", &a->lkf2__getOrderListResponse::return_, "lkf2:order"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (lkf2__getOrderListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_lkf2__getOrderListResponse, SOAP_TYPE_lkf2__getOrderListResponse, sizeof(lkf2__getOrderListResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 lkf2__getOrderListResponse * SOAP_FMAC2 soap_instantiate_lkf2__getOrderListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_lkf2__getOrderListResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	lkf2__getOrderListResponse *p;
	size_t k = sizeof(lkf2__getOrderListResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_lkf2__getOrderListResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, lkf2__getOrderListResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, lkf2__getOrderListResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated lkf2__getOrderListResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int lkf2__getOrderListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_lkf2__getOrderListResponse(soap, tag ? tag : "lkf2:getOrderListResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *lkf2__getOrderListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_lkf2__getOrderListResponse(soap, this, tag, type);
}

SOAP_FMAC3 lkf2__getOrderListResponse * SOAP_FMAC4 soap_get_lkf2__getOrderListResponse(struct soap *soap, lkf2__getOrderListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_lkf2__getOrderListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void lkf2__getOrderList::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void lkf2__getOrderList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int lkf2__getOrderList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_lkf2__getOrderList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_lkf2__getOrderList(struct soap *soap, const char *tag, int id, const lkf2__getOrderList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_lkf2__getOrderList), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *lkf2__getOrderList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_lkf2__getOrderList(soap, tag, this, type);
}

SOAP_FMAC3 lkf2__getOrderList * SOAP_FMAC4 soap_in_lkf2__getOrderList(struct soap *soap, const char *tag, lkf2__getOrderList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (lkf2__getOrderList*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_lkf2__getOrderList, sizeof(lkf2__getOrderList), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_lkf2__getOrderList)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (lkf2__getOrderList *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (lkf2__getOrderList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_lkf2__getOrderList, SOAP_TYPE_lkf2__getOrderList, sizeof(lkf2__getOrderList), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 lkf2__getOrderList * SOAP_FMAC2 soap_instantiate_lkf2__getOrderList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_lkf2__getOrderList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	lkf2__getOrderList *p;
	size_t k = sizeof(lkf2__getOrderList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_lkf2__getOrderList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, lkf2__getOrderList);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, lkf2__getOrderList, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated lkf2__getOrderList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int lkf2__getOrderList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_lkf2__getOrderList(soap, tag ? tag : "lkf2:getOrderList", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *lkf2__getOrderList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_lkf2__getOrderList(soap, this, tag, type);
}

SOAP_FMAC3 lkf2__getOrderList * SOAP_FMAC4 soap_get_lkf2__getOrderList(struct soap *soap, lkf2__getOrderList *p, const char *tag, const char *type)
{
	if ((p = soap_in_lkf2__getOrderList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void lkf2__deleteProductTypeByNameResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void lkf2__deleteProductTypeByNameResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int lkf2__deleteProductTypeByNameResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_lkf2__deleteProductTypeByNameResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_lkf2__deleteProductTypeByNameResponse(struct soap *soap, const char *tag, int id, const lkf2__deleteProductTypeByNameResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_lkf2__deleteProductTypeByNameResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *lkf2__deleteProductTypeByNameResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_lkf2__deleteProductTypeByNameResponse(soap, tag, this, type);
}

SOAP_FMAC3 lkf2__deleteProductTypeByNameResponse * SOAP_FMAC4 soap_in_lkf2__deleteProductTypeByNameResponse(struct soap *soap, const char *tag, lkf2__deleteProductTypeByNameResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (lkf2__deleteProductTypeByNameResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_lkf2__deleteProductTypeByNameResponse, sizeof(lkf2__deleteProductTypeByNameResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_lkf2__deleteProductTypeByNameResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (lkf2__deleteProductTypeByNameResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (lkf2__deleteProductTypeByNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_lkf2__deleteProductTypeByNameResponse, SOAP_TYPE_lkf2__deleteProductTypeByNameResponse, sizeof(lkf2__deleteProductTypeByNameResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 lkf2__deleteProductTypeByNameResponse * SOAP_FMAC2 soap_instantiate_lkf2__deleteProductTypeByNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_lkf2__deleteProductTypeByNameResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	lkf2__deleteProductTypeByNameResponse *p;
	size_t k = sizeof(lkf2__deleteProductTypeByNameResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_lkf2__deleteProductTypeByNameResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, lkf2__deleteProductTypeByNameResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, lkf2__deleteProductTypeByNameResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated lkf2__deleteProductTypeByNameResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int lkf2__deleteProductTypeByNameResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_lkf2__deleteProductTypeByNameResponse(soap, tag ? tag : "lkf2:deleteProductTypeByNameResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *lkf2__deleteProductTypeByNameResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_lkf2__deleteProductTypeByNameResponse(soap, this, tag, type);
}

SOAP_FMAC3 lkf2__deleteProductTypeByNameResponse * SOAP_FMAC4 soap_get_lkf2__deleteProductTypeByNameResponse(struct soap *soap, lkf2__deleteProductTypeByNameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_lkf2__deleteProductTypeByNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void lkf2__deleteProductTypeByName::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->lkf2__deleteProductTypeByName::arg0 = NULL;
}

void lkf2__deleteProductTypeByName::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->lkf2__deleteProductTypeByName::arg0);
#endif
}

int lkf2__deleteProductTypeByName::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_lkf2__deleteProductTypeByName(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_lkf2__deleteProductTypeByName(struct soap *soap, const char *tag, int id, const lkf2__deleteProductTypeByName *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_lkf2__deleteProductTypeByName), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &a->lkf2__deleteProductTypeByName::arg0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *lkf2__deleteProductTypeByName::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_lkf2__deleteProductTypeByName(soap, tag, this, type);
}

SOAP_FMAC3 lkf2__deleteProductTypeByName * SOAP_FMAC4 soap_in_lkf2__deleteProductTypeByName(struct soap *soap, const char *tag, lkf2__deleteProductTypeByName *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (lkf2__deleteProductTypeByName*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_lkf2__deleteProductTypeByName, sizeof(lkf2__deleteProductTypeByName), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_lkf2__deleteProductTypeByName)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (lkf2__deleteProductTypeByName *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg0", &a->lkf2__deleteProductTypeByName::arg0, "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (lkf2__deleteProductTypeByName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_lkf2__deleteProductTypeByName, SOAP_TYPE_lkf2__deleteProductTypeByName, sizeof(lkf2__deleteProductTypeByName), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 lkf2__deleteProductTypeByName * SOAP_FMAC2 soap_instantiate_lkf2__deleteProductTypeByName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_lkf2__deleteProductTypeByName(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	lkf2__deleteProductTypeByName *p;
	size_t k = sizeof(lkf2__deleteProductTypeByName);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_lkf2__deleteProductTypeByName, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, lkf2__deleteProductTypeByName);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, lkf2__deleteProductTypeByName, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated lkf2__deleteProductTypeByName location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int lkf2__deleteProductTypeByName::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_lkf2__deleteProductTypeByName(soap, tag ? tag : "lkf2:deleteProductTypeByName", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *lkf2__deleteProductTypeByName::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_lkf2__deleteProductTypeByName(soap, this, tag, type);
}

SOAP_FMAC3 lkf2__deleteProductTypeByName * SOAP_FMAC4 soap_get_lkf2__deleteProductTypeByName(struct soap *soap, lkf2__deleteProductTypeByName *p, const char *tag, const char *type)
{
	if ((p = soap_in_lkf2__deleteProductTypeByName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void lkf2__addProductResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void lkf2__addProductResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int lkf2__addProductResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_lkf2__addProductResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_lkf2__addProductResponse(struct soap *soap, const char *tag, int id, const lkf2__addProductResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_lkf2__addProductResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *lkf2__addProductResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_lkf2__addProductResponse(soap, tag, this, type);
}

SOAP_FMAC3 lkf2__addProductResponse * SOAP_FMAC4 soap_in_lkf2__addProductResponse(struct soap *soap, const char *tag, lkf2__addProductResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (lkf2__addProductResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_lkf2__addProductResponse, sizeof(lkf2__addProductResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_lkf2__addProductResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (lkf2__addProductResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (lkf2__addProductResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_lkf2__addProductResponse, SOAP_TYPE_lkf2__addProductResponse, sizeof(lkf2__addProductResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 lkf2__addProductResponse * SOAP_FMAC2 soap_instantiate_lkf2__addProductResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_lkf2__addProductResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	lkf2__addProductResponse *p;
	size_t k = sizeof(lkf2__addProductResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_lkf2__addProductResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, lkf2__addProductResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, lkf2__addProductResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated lkf2__addProductResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int lkf2__addProductResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_lkf2__addProductResponse(soap, tag ? tag : "lkf2:addProductResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *lkf2__addProductResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_lkf2__addProductResponse(soap, this, tag, type);
}

SOAP_FMAC3 lkf2__addProductResponse * SOAP_FMAC4 soap_get_lkf2__addProductResponse(struct soap *soap, lkf2__addProductResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_lkf2__addProductResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void lkf2__product::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->lkf2__product::productBuyNum);
	soap_default_float(soap, &this->lkf2__product::productDiscount);
	soap_default_int(soap, &this->lkf2__product::productId);
	this->lkf2__product::productImage = NULL;
	this->lkf2__product::productName = NULL;
	soap_default_int(soap, &this->lkf2__product::productNum);
	soap_default_int(soap, &this->lkf2__product::productPrice);
}

void lkf2__product::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->lkf2__product::productImage);
	soap_serialize_PointerTostd__string(soap, &this->lkf2__product::productName);
#endif
}

int lkf2__product::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_lkf2__product(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_lkf2__product(struct soap *soap, const char *tag, int id, const lkf2__product *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_lkf2__product), type))
		return soap->error;
	if (soap_out_int(soap, "productBuyNum", -1, &a->lkf2__product::productBuyNum, ""))
		return soap->error;
	if (soap_out_float(soap, "productDiscount", -1, &a->lkf2__product::productDiscount, ""))
		return soap->error;
	if (soap_out_int(soap, "productId", -1, &a->lkf2__product::productId, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "productImage", -1, &a->lkf2__product::productImage, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "productName", -1, &a->lkf2__product::productName, ""))
		return soap->error;
	if (soap_out_int(soap, "productNum", -1, &a->lkf2__product::productNum, ""))
		return soap->error;
	if (soap_out_int(soap, "productPrice", -1, &a->lkf2__product::productPrice, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *lkf2__product::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_lkf2__product(soap, tag, this, type);
}

SOAP_FMAC3 lkf2__product * SOAP_FMAC4 soap_in_lkf2__product(struct soap *soap, const char *tag, lkf2__product *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (lkf2__product*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_lkf2__product, sizeof(lkf2__product), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_lkf2__product)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (lkf2__product *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_productBuyNum1 = 1;
	size_t soap_flag_productDiscount1 = 1;
	size_t soap_flag_productId1 = 1;
	size_t soap_flag_productImage1 = 1;
	size_t soap_flag_productName1 = 1;
	size_t soap_flag_productNum1 = 1;
	size_t soap_flag_productPrice1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_productBuyNum1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "productBuyNum", &a->lkf2__product::productBuyNum, "xsd:int"))
				{	soap_flag_productBuyNum1--;
					continue;
				}
			}
			if (soap_flag_productDiscount1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "productDiscount", &a->lkf2__product::productDiscount, "xsd:float"))
				{	soap_flag_productDiscount1--;
					continue;
				}
			}
			if (soap_flag_productId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "productId", &a->lkf2__product::productId, "xsd:int"))
				{	soap_flag_productId1--;
					continue;
				}
			}
			if (soap_flag_productImage1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "productImage", &a->lkf2__product::productImage, "xsd:string"))
				{	soap_flag_productImage1--;
					continue;
				}
			}
			if (soap_flag_productName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "productName", &a->lkf2__product::productName, "xsd:string"))
				{	soap_flag_productName1--;
					continue;
				}
			}
			if (soap_flag_productNum1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "productNum", &a->lkf2__product::productNum, "xsd:int"))
				{	soap_flag_productNum1--;
					continue;
				}
			}
			if (soap_flag_productPrice1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "productPrice", &a->lkf2__product::productPrice, "xsd:int"))
				{	soap_flag_productPrice1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_productBuyNum1 > 0 || soap_flag_productDiscount1 > 0 || soap_flag_productId1 > 0 || soap_flag_productNum1 > 0 || soap_flag_productPrice1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (lkf2__product *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_lkf2__product, SOAP_TYPE_lkf2__product, sizeof(lkf2__product), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 lkf2__product * SOAP_FMAC2 soap_instantiate_lkf2__product(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_lkf2__product(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	lkf2__product *p;
	size_t k = sizeof(lkf2__product);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_lkf2__product, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, lkf2__product);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, lkf2__product, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated lkf2__product location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int lkf2__product::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_lkf2__product(soap, tag ? tag : "lkf2:product", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *lkf2__product::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_lkf2__product(soap, this, tag, type);
}

SOAP_FMAC3 lkf2__product * SOAP_FMAC4 soap_get_lkf2__product(struct soap *soap, lkf2__product *p, const char *tag, const char *type)
{
	if ((p = soap_in_lkf2__product(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void lkf2__addProduct::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->lkf2__addProduct::arg0 = NULL;
}

void lkf2__addProduct::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTolkf2__product(soap, &this->lkf2__addProduct::arg0);
#endif
}

int lkf2__addProduct::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_lkf2__addProduct(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_lkf2__addProduct(struct soap *soap, const char *tag, int id, const lkf2__addProduct *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_lkf2__addProduct), type))
		return soap->error;
	if (soap_out_PointerTolkf2__product(soap, "arg0", -1, &a->lkf2__addProduct::arg0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *lkf2__addProduct::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_lkf2__addProduct(soap, tag, this, type);
}

SOAP_FMAC3 lkf2__addProduct * SOAP_FMAC4 soap_in_lkf2__addProduct(struct soap *soap, const char *tag, lkf2__addProduct *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (lkf2__addProduct*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_lkf2__addProduct, sizeof(lkf2__addProduct), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_lkf2__addProduct)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (lkf2__addProduct *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTolkf2__product(soap, "arg0", &a->lkf2__addProduct::arg0, "lkf2:product"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (lkf2__addProduct *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_lkf2__addProduct, SOAP_TYPE_lkf2__addProduct, sizeof(lkf2__addProduct), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 lkf2__addProduct * SOAP_FMAC2 soap_instantiate_lkf2__addProduct(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_lkf2__addProduct(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	lkf2__addProduct *p;
	size_t k = sizeof(lkf2__addProduct);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_lkf2__addProduct, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, lkf2__addProduct);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, lkf2__addProduct, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated lkf2__addProduct location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int lkf2__addProduct::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_lkf2__addProduct(soap, tag ? tag : "lkf2:addProduct", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *lkf2__addProduct::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_lkf2__addProduct(soap, this, tag, type);
}

SOAP_FMAC3 lkf2__addProduct * SOAP_FMAC4 soap_get_lkf2__addProduct(struct soap *soap, lkf2__addProduct *p, const char *tag, const char *type)
{
	if ((p = soap_in_lkf2__addProduct(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__decimal(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__decimal(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__decimal), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__decimal(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__decimal, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 5, 0, -1, "[-+]?(\\d+|\\d*\\.\\d*)")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__decimal, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__decimal, SOAP_TYPE_xsd__decimal, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__decimal(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__decimal(soap, tag ? tag : "xsd:decimal", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__decimal(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__decimal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_std__string, SOAP_TYPE_std__string, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::string *p;
	size_t k = sizeof(std::string);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::string);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::string, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::string location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_std__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode;
	soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Fault*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, "xsd:QName"))
				{	soap_flag_faultcode--;
					continue;
				}
			}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Fault *p;
	size_t k = sizeof(struct SOAP_ENV__Fault);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Fault);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Fault, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Fault location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault(soap, tag ? tag : "SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, (char*const*)&a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Reason*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Text", (char**)&a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Reason *p;
	size_t k = sizeof(struct SOAP_ENV__Reason);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Reason);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Reason, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Reason location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Detail*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->fault = soap_getelement(soap, "fault", &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Detail *p;
	size_t k = sizeof(struct SOAP_ENV__Detail);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Detail);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Detail, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Detail location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value;
	soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Code*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "SOAP-ENV:Value", (char**)&a->SOAP_ENV__Value, "xsd:QName"))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Code *p;
	size_t k = sizeof(struct SOAP_ENV__Code);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Code);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Code, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Code location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Header*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Header *p;
	size_t k = sizeof(struct SOAP_ENV__Header);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Header);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Header, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Header location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___lkf1__updateHistory(struct soap *soap, struct __lkf1__updateHistory *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->lkf2__updateHistory_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___lkf1__updateHistory(struct soap *soap, const struct __lkf1__updateHistory *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTolkf2__updateHistory(soap, &a->lkf2__updateHistory_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___lkf1__updateHistory(struct soap *soap, const char *tag, int id, const struct __lkf1__updateHistory *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTolkf2__updateHistory(soap, "lkf2:updateHistory", -1, &a->lkf2__updateHistory_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __lkf1__updateHistory * SOAP_FMAC4 soap_in___lkf1__updateHistory(struct soap *soap, const char *tag, struct __lkf1__updateHistory *a, const char *type)
{
	size_t soap_flag_lkf2__updateHistory_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __lkf1__updateHistory*)soap_id_enter(soap, "", a, SOAP_TYPE___lkf1__updateHistory, sizeof(struct __lkf1__updateHistory), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___lkf1__updateHistory(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lkf2__updateHistory_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTolkf2__updateHistory(soap, "lkf2:updateHistory", &a->lkf2__updateHistory_, "lkf2:updateHistory"))
				{	soap_flag_lkf2__updateHistory_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __lkf1__updateHistory * SOAP_FMAC2 soap_instantiate___lkf1__updateHistory(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___lkf1__updateHistory(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __lkf1__updateHistory *p;
	size_t k = sizeof(struct __lkf1__updateHistory);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___lkf1__updateHistory, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __lkf1__updateHistory);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __lkf1__updateHistory, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __lkf1__updateHistory location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___lkf1__updateHistory(struct soap *soap, const struct __lkf1__updateHistory *a, const char *tag, const char *type)
{
	if (soap_out___lkf1__updateHistory(soap, tag ? tag : "-lkf1:updateHistory", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __lkf1__updateHistory * SOAP_FMAC4 soap_get___lkf1__updateHistory(struct soap *soap, struct __lkf1__updateHistory *p, const char *tag, const char *type)
{
	if ((p = soap_in___lkf1__updateHistory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___lkf1__getOrderListHistory(struct soap *soap, struct __lkf1__getOrderListHistory *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->lkf2__getOrderListHistory_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___lkf1__getOrderListHistory(struct soap *soap, const struct __lkf1__getOrderListHistory *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTolkf2__getOrderListHistory(soap, &a->lkf2__getOrderListHistory_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___lkf1__getOrderListHistory(struct soap *soap, const char *tag, int id, const struct __lkf1__getOrderListHistory *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTolkf2__getOrderListHistory(soap, "lkf2:getOrderListHistory", -1, &a->lkf2__getOrderListHistory_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __lkf1__getOrderListHistory * SOAP_FMAC4 soap_in___lkf1__getOrderListHistory(struct soap *soap, const char *tag, struct __lkf1__getOrderListHistory *a, const char *type)
{
	size_t soap_flag_lkf2__getOrderListHistory_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __lkf1__getOrderListHistory*)soap_id_enter(soap, "", a, SOAP_TYPE___lkf1__getOrderListHistory, sizeof(struct __lkf1__getOrderListHistory), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___lkf1__getOrderListHistory(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lkf2__getOrderListHistory_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTolkf2__getOrderListHistory(soap, "lkf2:getOrderListHistory", &a->lkf2__getOrderListHistory_, "lkf2:getOrderListHistory"))
				{	soap_flag_lkf2__getOrderListHistory_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __lkf1__getOrderListHistory * SOAP_FMAC2 soap_instantiate___lkf1__getOrderListHistory(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___lkf1__getOrderListHistory(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __lkf1__getOrderListHistory *p;
	size_t k = sizeof(struct __lkf1__getOrderListHistory);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___lkf1__getOrderListHistory, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __lkf1__getOrderListHistory);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __lkf1__getOrderListHistory, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __lkf1__getOrderListHistory location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___lkf1__getOrderListHistory(struct soap *soap, const struct __lkf1__getOrderListHistory *a, const char *tag, const char *type)
{
	if (soap_out___lkf1__getOrderListHistory(soap, tag ? tag : "-lkf1:getOrderListHistory", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __lkf1__getOrderListHistory * SOAP_FMAC4 soap_get___lkf1__getOrderListHistory(struct soap *soap, struct __lkf1__getOrderListHistory *p, const char *tag, const char *type)
{
	if ((p = soap_in___lkf1__getOrderListHistory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___lkf1__InsertClient(struct soap *soap, struct __lkf1__InsertClient *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->lkf2__InsertClient_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___lkf1__InsertClient(struct soap *soap, const struct __lkf1__InsertClient *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTolkf2__InsertClient(soap, &a->lkf2__InsertClient_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___lkf1__InsertClient(struct soap *soap, const char *tag, int id, const struct __lkf1__InsertClient *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTolkf2__InsertClient(soap, "lkf2:InsertClient", -1, &a->lkf2__InsertClient_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __lkf1__InsertClient * SOAP_FMAC4 soap_in___lkf1__InsertClient(struct soap *soap, const char *tag, struct __lkf1__InsertClient *a, const char *type)
{
	size_t soap_flag_lkf2__InsertClient_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __lkf1__InsertClient*)soap_id_enter(soap, "", a, SOAP_TYPE___lkf1__InsertClient, sizeof(struct __lkf1__InsertClient), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___lkf1__InsertClient(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lkf2__InsertClient_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTolkf2__InsertClient(soap, "lkf2:InsertClient", &a->lkf2__InsertClient_, "lkf2:InsertClient"))
				{	soap_flag_lkf2__InsertClient_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __lkf1__InsertClient * SOAP_FMAC2 soap_instantiate___lkf1__InsertClient(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___lkf1__InsertClient(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __lkf1__InsertClient *p;
	size_t k = sizeof(struct __lkf1__InsertClient);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___lkf1__InsertClient, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __lkf1__InsertClient);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __lkf1__InsertClient, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __lkf1__InsertClient location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___lkf1__InsertClient(struct soap *soap, const struct __lkf1__InsertClient *a, const char *tag, const char *type)
{
	if (soap_out___lkf1__InsertClient(soap, tag ? tag : "-lkf1:InsertClient", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __lkf1__InsertClient * SOAP_FMAC4 soap_get___lkf1__InsertClient(struct soap *soap, struct __lkf1__InsertClient *p, const char *tag, const char *type)
{
	if ((p = soap_in___lkf1__InsertClient(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___lkf1__getProductList(struct soap *soap, struct __lkf1__getProductList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->lkf2__getProductList_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___lkf1__getProductList(struct soap *soap, const struct __lkf1__getProductList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTolkf2__getProductList(soap, &a->lkf2__getProductList_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___lkf1__getProductList(struct soap *soap, const char *tag, int id, const struct __lkf1__getProductList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTolkf2__getProductList(soap, "lkf2:getProductList", -1, &a->lkf2__getProductList_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __lkf1__getProductList * SOAP_FMAC4 soap_in___lkf1__getProductList(struct soap *soap, const char *tag, struct __lkf1__getProductList *a, const char *type)
{
	size_t soap_flag_lkf2__getProductList_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __lkf1__getProductList*)soap_id_enter(soap, "", a, SOAP_TYPE___lkf1__getProductList, sizeof(struct __lkf1__getProductList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___lkf1__getProductList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lkf2__getProductList_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTolkf2__getProductList(soap, "lkf2:getProductList", &a->lkf2__getProductList_, "lkf2:getProductList"))
				{	soap_flag_lkf2__getProductList_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __lkf1__getProductList * SOAP_FMAC2 soap_instantiate___lkf1__getProductList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___lkf1__getProductList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __lkf1__getProductList *p;
	size_t k = sizeof(struct __lkf1__getProductList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___lkf1__getProductList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __lkf1__getProductList);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __lkf1__getProductList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __lkf1__getProductList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___lkf1__getProductList(struct soap *soap, const struct __lkf1__getProductList *a, const char *tag, const char *type)
{
	if (soap_out___lkf1__getProductList(soap, tag ? tag : "-lkf1:getProductList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __lkf1__getProductList * SOAP_FMAC4 soap_get___lkf1__getProductList(struct soap *soap, struct __lkf1__getProductList *p, const char *tag, const char *type)
{
	if ((p = soap_in___lkf1__getProductList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___lkf1__deleteShoppingCart(struct soap *soap, struct __lkf1__deleteShoppingCart *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->lkf2__deleteShoppingCart_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___lkf1__deleteShoppingCart(struct soap *soap, const struct __lkf1__deleteShoppingCart *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTolkf2__deleteShoppingCart(soap, &a->lkf2__deleteShoppingCart_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___lkf1__deleteShoppingCart(struct soap *soap, const char *tag, int id, const struct __lkf1__deleteShoppingCart *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTolkf2__deleteShoppingCart(soap, "lkf2:deleteShoppingCart", -1, &a->lkf2__deleteShoppingCart_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __lkf1__deleteShoppingCart * SOAP_FMAC4 soap_in___lkf1__deleteShoppingCart(struct soap *soap, const char *tag, struct __lkf1__deleteShoppingCart *a, const char *type)
{
	size_t soap_flag_lkf2__deleteShoppingCart_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __lkf1__deleteShoppingCart*)soap_id_enter(soap, "", a, SOAP_TYPE___lkf1__deleteShoppingCart, sizeof(struct __lkf1__deleteShoppingCart), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___lkf1__deleteShoppingCart(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lkf2__deleteShoppingCart_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTolkf2__deleteShoppingCart(soap, "lkf2:deleteShoppingCart", &a->lkf2__deleteShoppingCart_, "lkf2:deleteShoppingCart"))
				{	soap_flag_lkf2__deleteShoppingCart_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __lkf1__deleteShoppingCart * SOAP_FMAC2 soap_instantiate___lkf1__deleteShoppingCart(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___lkf1__deleteShoppingCart(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __lkf1__deleteShoppingCart *p;
	size_t k = sizeof(struct __lkf1__deleteShoppingCart);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___lkf1__deleteShoppingCart, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __lkf1__deleteShoppingCart);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __lkf1__deleteShoppingCart, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __lkf1__deleteShoppingCart location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___lkf1__deleteShoppingCart(struct soap *soap, const struct __lkf1__deleteShoppingCart *a, const char *tag, const char *type)
{
	if (soap_out___lkf1__deleteShoppingCart(soap, tag ? tag : "-lkf1:deleteShoppingCart", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __lkf1__deleteShoppingCart * SOAP_FMAC4 soap_get___lkf1__deleteShoppingCart(struct soap *soap, struct __lkf1__deleteShoppingCart *p, const char *tag, const char *type)
{
	if ((p = soap_in___lkf1__deleteShoppingCart(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___lkf1__getClientByNameAndPwd(struct soap *soap, struct __lkf1__getClientByNameAndPwd *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->lkf2__getClientByNameAndPwd_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___lkf1__getClientByNameAndPwd(struct soap *soap, const struct __lkf1__getClientByNameAndPwd *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTolkf2__getClientByNameAndPwd(soap, &a->lkf2__getClientByNameAndPwd_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___lkf1__getClientByNameAndPwd(struct soap *soap, const char *tag, int id, const struct __lkf1__getClientByNameAndPwd *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTolkf2__getClientByNameAndPwd(soap, "lkf2:getClientByNameAndPwd", -1, &a->lkf2__getClientByNameAndPwd_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __lkf1__getClientByNameAndPwd * SOAP_FMAC4 soap_in___lkf1__getClientByNameAndPwd(struct soap *soap, const char *tag, struct __lkf1__getClientByNameAndPwd *a, const char *type)
{
	size_t soap_flag_lkf2__getClientByNameAndPwd_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __lkf1__getClientByNameAndPwd*)soap_id_enter(soap, "", a, SOAP_TYPE___lkf1__getClientByNameAndPwd, sizeof(struct __lkf1__getClientByNameAndPwd), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___lkf1__getClientByNameAndPwd(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lkf2__getClientByNameAndPwd_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTolkf2__getClientByNameAndPwd(soap, "lkf2:getClientByNameAndPwd", &a->lkf2__getClientByNameAndPwd_, "lkf2:getClientByNameAndPwd"))
				{	soap_flag_lkf2__getClientByNameAndPwd_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __lkf1__getClientByNameAndPwd * SOAP_FMAC2 soap_instantiate___lkf1__getClientByNameAndPwd(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___lkf1__getClientByNameAndPwd(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __lkf1__getClientByNameAndPwd *p;
	size_t k = sizeof(struct __lkf1__getClientByNameAndPwd);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___lkf1__getClientByNameAndPwd, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __lkf1__getClientByNameAndPwd);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __lkf1__getClientByNameAndPwd, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __lkf1__getClientByNameAndPwd location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___lkf1__getClientByNameAndPwd(struct soap *soap, const struct __lkf1__getClientByNameAndPwd *a, const char *tag, const char *type)
{
	if (soap_out___lkf1__getClientByNameAndPwd(soap, tag ? tag : "-lkf1:getClientByNameAndPwd", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __lkf1__getClientByNameAndPwd * SOAP_FMAC4 soap_get___lkf1__getClientByNameAndPwd(struct soap *soap, struct __lkf1__getClientByNameAndPwd *p, const char *tag, const char *type)
{
	if ((p = soap_in___lkf1__getClientByNameAndPwd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___lkf1__addOrder(struct soap *soap, struct __lkf1__addOrder *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->lkf2__addOrder_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___lkf1__addOrder(struct soap *soap, const struct __lkf1__addOrder *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTolkf2__addOrder(soap, &a->lkf2__addOrder_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___lkf1__addOrder(struct soap *soap, const char *tag, int id, const struct __lkf1__addOrder *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTolkf2__addOrder(soap, "lkf2:addOrder", -1, &a->lkf2__addOrder_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __lkf1__addOrder * SOAP_FMAC4 soap_in___lkf1__addOrder(struct soap *soap, const char *tag, struct __lkf1__addOrder *a, const char *type)
{
	size_t soap_flag_lkf2__addOrder_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __lkf1__addOrder*)soap_id_enter(soap, "", a, SOAP_TYPE___lkf1__addOrder, sizeof(struct __lkf1__addOrder), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___lkf1__addOrder(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lkf2__addOrder_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTolkf2__addOrder(soap, "lkf2:addOrder", &a->lkf2__addOrder_, "lkf2:addOrder"))
				{	soap_flag_lkf2__addOrder_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __lkf1__addOrder * SOAP_FMAC2 soap_instantiate___lkf1__addOrder(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___lkf1__addOrder(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __lkf1__addOrder *p;
	size_t k = sizeof(struct __lkf1__addOrder);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___lkf1__addOrder, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __lkf1__addOrder);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __lkf1__addOrder, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __lkf1__addOrder location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___lkf1__addOrder(struct soap *soap, const struct __lkf1__addOrder *a, const char *tag, const char *type)
{
	if (soap_out___lkf1__addOrder(soap, tag ? tag : "-lkf1:addOrder", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __lkf1__addOrder * SOAP_FMAC4 soap_get___lkf1__addOrder(struct soap *soap, struct __lkf1__addOrder *p, const char *tag, const char *type)
{
	if ((p = soap_in___lkf1__addOrder(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___lkf1__getProductLikeList(struct soap *soap, struct __lkf1__getProductLikeList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->lkf2__getProductLikeList_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___lkf1__getProductLikeList(struct soap *soap, const struct __lkf1__getProductLikeList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTolkf2__getProductLikeList(soap, &a->lkf2__getProductLikeList_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___lkf1__getProductLikeList(struct soap *soap, const char *tag, int id, const struct __lkf1__getProductLikeList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTolkf2__getProductLikeList(soap, "lkf2:getProductLikeList", -1, &a->lkf2__getProductLikeList_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __lkf1__getProductLikeList * SOAP_FMAC4 soap_in___lkf1__getProductLikeList(struct soap *soap, const char *tag, struct __lkf1__getProductLikeList *a, const char *type)
{
	size_t soap_flag_lkf2__getProductLikeList_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __lkf1__getProductLikeList*)soap_id_enter(soap, "", a, SOAP_TYPE___lkf1__getProductLikeList, sizeof(struct __lkf1__getProductLikeList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___lkf1__getProductLikeList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lkf2__getProductLikeList_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTolkf2__getProductLikeList(soap, "lkf2:getProductLikeList", &a->lkf2__getProductLikeList_, "lkf2:getProductLikeList"))
				{	soap_flag_lkf2__getProductLikeList_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __lkf1__getProductLikeList * SOAP_FMAC2 soap_instantiate___lkf1__getProductLikeList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___lkf1__getProductLikeList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __lkf1__getProductLikeList *p;
	size_t k = sizeof(struct __lkf1__getProductLikeList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___lkf1__getProductLikeList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __lkf1__getProductLikeList);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __lkf1__getProductLikeList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __lkf1__getProductLikeList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___lkf1__getProductLikeList(struct soap *soap, const struct __lkf1__getProductLikeList *a, const char *tag, const char *type)
{
	if (soap_out___lkf1__getProductLikeList(soap, tag ? tag : "-lkf1:getProductLikeList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __lkf1__getProductLikeList * SOAP_FMAC4 soap_get___lkf1__getProductLikeList(struct soap *soap, struct __lkf1__getProductLikeList *p, const char *tag, const char *type)
{
	if ((p = soap_in___lkf1__getProductLikeList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___lkf1__updateProductByInfo(struct soap *soap, struct __lkf1__updateProductByInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->lkf2__updateProductByInfo_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___lkf1__updateProductByInfo(struct soap *soap, const struct __lkf1__updateProductByInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTolkf2__updateProductByInfo(soap, &a->lkf2__updateProductByInfo_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___lkf1__updateProductByInfo(struct soap *soap, const char *tag, int id, const struct __lkf1__updateProductByInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTolkf2__updateProductByInfo(soap, "lkf2:updateProductByInfo", -1, &a->lkf2__updateProductByInfo_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __lkf1__updateProductByInfo * SOAP_FMAC4 soap_in___lkf1__updateProductByInfo(struct soap *soap, const char *tag, struct __lkf1__updateProductByInfo *a, const char *type)
{
	size_t soap_flag_lkf2__updateProductByInfo_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __lkf1__updateProductByInfo*)soap_id_enter(soap, "", a, SOAP_TYPE___lkf1__updateProductByInfo, sizeof(struct __lkf1__updateProductByInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___lkf1__updateProductByInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lkf2__updateProductByInfo_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTolkf2__updateProductByInfo(soap, "lkf2:updateProductByInfo", &a->lkf2__updateProductByInfo_, "lkf2:updateProductByInfo"))
				{	soap_flag_lkf2__updateProductByInfo_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __lkf1__updateProductByInfo * SOAP_FMAC2 soap_instantiate___lkf1__updateProductByInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___lkf1__updateProductByInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __lkf1__updateProductByInfo *p;
	size_t k = sizeof(struct __lkf1__updateProductByInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___lkf1__updateProductByInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __lkf1__updateProductByInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __lkf1__updateProductByInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __lkf1__updateProductByInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___lkf1__updateProductByInfo(struct soap *soap, const struct __lkf1__updateProductByInfo *a, const char *tag, const char *type)
{
	if (soap_out___lkf1__updateProductByInfo(soap, tag ? tag : "-lkf1:updateProductByInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __lkf1__updateProductByInfo * SOAP_FMAC4 soap_get___lkf1__updateProductByInfo(struct soap *soap, struct __lkf1__updateProductByInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___lkf1__updateProductByInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___lkf1__addProductType(struct soap *soap, struct __lkf1__addProductType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->lkf2__addProductType_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___lkf1__addProductType(struct soap *soap, const struct __lkf1__addProductType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTolkf2__addProductType(soap, &a->lkf2__addProductType_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___lkf1__addProductType(struct soap *soap, const char *tag, int id, const struct __lkf1__addProductType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTolkf2__addProductType(soap, "lkf2:addProductType", -1, &a->lkf2__addProductType_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __lkf1__addProductType * SOAP_FMAC4 soap_in___lkf1__addProductType(struct soap *soap, const char *tag, struct __lkf1__addProductType *a, const char *type)
{
	size_t soap_flag_lkf2__addProductType_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __lkf1__addProductType*)soap_id_enter(soap, "", a, SOAP_TYPE___lkf1__addProductType, sizeof(struct __lkf1__addProductType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___lkf1__addProductType(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lkf2__addProductType_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTolkf2__addProductType(soap, "lkf2:addProductType", &a->lkf2__addProductType_, "lkf2:addProductType"))
				{	soap_flag_lkf2__addProductType_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __lkf1__addProductType * SOAP_FMAC2 soap_instantiate___lkf1__addProductType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___lkf1__addProductType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __lkf1__addProductType *p;
	size_t k = sizeof(struct __lkf1__addProductType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___lkf1__addProductType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __lkf1__addProductType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __lkf1__addProductType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __lkf1__addProductType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___lkf1__addProductType(struct soap *soap, const struct __lkf1__addProductType *a, const char *tag, const char *type)
{
	if (soap_out___lkf1__addProductType(soap, tag ? tag : "-lkf1:addProductType", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __lkf1__addProductType * SOAP_FMAC4 soap_get___lkf1__addProductType(struct soap *soap, struct __lkf1__addProductType *p, const char *tag, const char *type)
{
	if ((p = soap_in___lkf1__addProductType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___lkf1__getOrderListByInfo(struct soap *soap, struct __lkf1__getOrderListByInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->lkf2__getOrderListByInfo_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___lkf1__getOrderListByInfo(struct soap *soap, const struct __lkf1__getOrderListByInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTolkf2__getOrderListByInfo(soap, &a->lkf2__getOrderListByInfo_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___lkf1__getOrderListByInfo(struct soap *soap, const char *tag, int id, const struct __lkf1__getOrderListByInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTolkf2__getOrderListByInfo(soap, "lkf2:getOrderListByInfo", -1, &a->lkf2__getOrderListByInfo_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __lkf1__getOrderListByInfo * SOAP_FMAC4 soap_in___lkf1__getOrderListByInfo(struct soap *soap, const char *tag, struct __lkf1__getOrderListByInfo *a, const char *type)
{
	size_t soap_flag_lkf2__getOrderListByInfo_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __lkf1__getOrderListByInfo*)soap_id_enter(soap, "", a, SOAP_TYPE___lkf1__getOrderListByInfo, sizeof(struct __lkf1__getOrderListByInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___lkf1__getOrderListByInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lkf2__getOrderListByInfo_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTolkf2__getOrderListByInfo(soap, "lkf2:getOrderListByInfo", &a->lkf2__getOrderListByInfo_, "lkf2:getOrderListByInfo"))
				{	soap_flag_lkf2__getOrderListByInfo_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __lkf1__getOrderListByInfo * SOAP_FMAC2 soap_instantiate___lkf1__getOrderListByInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___lkf1__getOrderListByInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __lkf1__getOrderListByInfo *p;
	size_t k = sizeof(struct __lkf1__getOrderListByInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___lkf1__getOrderListByInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __lkf1__getOrderListByInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __lkf1__getOrderListByInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __lkf1__getOrderListByInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___lkf1__getOrderListByInfo(struct soap *soap, const struct __lkf1__getOrderListByInfo *a, const char *tag, const char *type)
{
	if (soap_out___lkf1__getOrderListByInfo(soap, tag ? tag : "-lkf1:getOrderListByInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __lkf1__getOrderListByInfo * SOAP_FMAC4 soap_get___lkf1__getOrderListByInfo(struct soap *soap, struct __lkf1__getOrderListByInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___lkf1__getOrderListByInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___lkf1__getClientList(struct soap *soap, struct __lkf1__getClientList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->lkf2__getClientList_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___lkf1__getClientList(struct soap *soap, const struct __lkf1__getClientList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTolkf2__getClientList(soap, &a->lkf2__getClientList_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___lkf1__getClientList(struct soap *soap, const char *tag, int id, const struct __lkf1__getClientList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTolkf2__getClientList(soap, "lkf2:getClientList", -1, &a->lkf2__getClientList_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __lkf1__getClientList * SOAP_FMAC4 soap_in___lkf1__getClientList(struct soap *soap, const char *tag, struct __lkf1__getClientList *a, const char *type)
{
	size_t soap_flag_lkf2__getClientList_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __lkf1__getClientList*)soap_id_enter(soap, "", a, SOAP_TYPE___lkf1__getClientList, sizeof(struct __lkf1__getClientList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___lkf1__getClientList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lkf2__getClientList_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTolkf2__getClientList(soap, "lkf2:getClientList", &a->lkf2__getClientList_, "lkf2:getClientList"))
				{	soap_flag_lkf2__getClientList_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __lkf1__getClientList * SOAP_FMAC2 soap_instantiate___lkf1__getClientList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___lkf1__getClientList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __lkf1__getClientList *p;
	size_t k = sizeof(struct __lkf1__getClientList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___lkf1__getClientList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __lkf1__getClientList);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __lkf1__getClientList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __lkf1__getClientList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___lkf1__getClientList(struct soap *soap, const struct __lkf1__getClientList *a, const char *tag, const char *type)
{
	if (soap_out___lkf1__getClientList(soap, tag ? tag : "-lkf1:getClientList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __lkf1__getClientList * SOAP_FMAC4 soap_get___lkf1__getClientList(struct soap *soap, struct __lkf1__getClientList *p, const char *tag, const char *type)
{
	if ((p = soap_in___lkf1__getClientList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___lkf1__getProductTypeByProName(struct soap *soap, struct __lkf1__getProductTypeByProName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->lkf2__getProductTypeByProName_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___lkf1__getProductTypeByProName(struct soap *soap, const struct __lkf1__getProductTypeByProName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTolkf2__getProductTypeByProName(soap, &a->lkf2__getProductTypeByProName_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___lkf1__getProductTypeByProName(struct soap *soap, const char *tag, int id, const struct __lkf1__getProductTypeByProName *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTolkf2__getProductTypeByProName(soap, "lkf2:getProductTypeByProName", -1, &a->lkf2__getProductTypeByProName_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __lkf1__getProductTypeByProName * SOAP_FMAC4 soap_in___lkf1__getProductTypeByProName(struct soap *soap, const char *tag, struct __lkf1__getProductTypeByProName *a, const char *type)
{
	size_t soap_flag_lkf2__getProductTypeByProName_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __lkf1__getProductTypeByProName*)soap_id_enter(soap, "", a, SOAP_TYPE___lkf1__getProductTypeByProName, sizeof(struct __lkf1__getProductTypeByProName), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___lkf1__getProductTypeByProName(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lkf2__getProductTypeByProName_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTolkf2__getProductTypeByProName(soap, "lkf2:getProductTypeByProName", &a->lkf2__getProductTypeByProName_, "lkf2:getProductTypeByProName"))
				{	soap_flag_lkf2__getProductTypeByProName_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __lkf1__getProductTypeByProName * SOAP_FMAC2 soap_instantiate___lkf1__getProductTypeByProName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___lkf1__getProductTypeByProName(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __lkf1__getProductTypeByProName *p;
	size_t k = sizeof(struct __lkf1__getProductTypeByProName);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___lkf1__getProductTypeByProName, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __lkf1__getProductTypeByProName);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __lkf1__getProductTypeByProName, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __lkf1__getProductTypeByProName location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___lkf1__getProductTypeByProName(struct soap *soap, const struct __lkf1__getProductTypeByProName *a, const char *tag, const char *type)
{
	if (soap_out___lkf1__getProductTypeByProName(soap, tag ? tag : "-lkf1:getProductTypeByProName", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __lkf1__getProductTypeByProName * SOAP_FMAC4 soap_get___lkf1__getProductTypeByProName(struct soap *soap, struct __lkf1__getProductTypeByProName *p, const char *tag, const char *type)
{
	if ((p = soap_in___lkf1__getProductTypeByProName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___lkf1__getClientLikeList(struct soap *soap, struct __lkf1__getClientLikeList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->lkf2__getClientLikeList_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___lkf1__getClientLikeList(struct soap *soap, const struct __lkf1__getClientLikeList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTolkf2__getClientLikeList(soap, &a->lkf2__getClientLikeList_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___lkf1__getClientLikeList(struct soap *soap, const char *tag, int id, const struct __lkf1__getClientLikeList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTolkf2__getClientLikeList(soap, "lkf2:getClientLikeList", -1, &a->lkf2__getClientLikeList_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __lkf1__getClientLikeList * SOAP_FMAC4 soap_in___lkf1__getClientLikeList(struct soap *soap, const char *tag, struct __lkf1__getClientLikeList *a, const char *type)
{
	size_t soap_flag_lkf2__getClientLikeList_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __lkf1__getClientLikeList*)soap_id_enter(soap, "", a, SOAP_TYPE___lkf1__getClientLikeList, sizeof(struct __lkf1__getClientLikeList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___lkf1__getClientLikeList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lkf2__getClientLikeList_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTolkf2__getClientLikeList(soap, "lkf2:getClientLikeList", &a->lkf2__getClientLikeList_, "lkf2:getClientLikeList"))
				{	soap_flag_lkf2__getClientLikeList_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __lkf1__getClientLikeList * SOAP_FMAC2 soap_instantiate___lkf1__getClientLikeList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___lkf1__getClientLikeList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __lkf1__getClientLikeList *p;
	size_t k = sizeof(struct __lkf1__getClientLikeList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___lkf1__getClientLikeList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __lkf1__getClientLikeList);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __lkf1__getClientLikeList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __lkf1__getClientLikeList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___lkf1__getClientLikeList(struct soap *soap, const struct __lkf1__getClientLikeList *a, const char *tag, const char *type)
{
	if (soap_out___lkf1__getClientLikeList(soap, tag ? tag : "-lkf1:getClientLikeList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __lkf1__getClientLikeList * SOAP_FMAC4 soap_get___lkf1__getClientLikeList(struct soap *soap, struct __lkf1__getClientLikeList *p, const char *tag, const char *type)
{
	if ((p = soap_in___lkf1__getClientLikeList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___lkf1__getOrderLikeList(struct soap *soap, struct __lkf1__getOrderLikeList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->lkf2__getOrderLikeList_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___lkf1__getOrderLikeList(struct soap *soap, const struct __lkf1__getOrderLikeList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTolkf2__getOrderLikeList(soap, &a->lkf2__getOrderLikeList_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___lkf1__getOrderLikeList(struct soap *soap, const char *tag, int id, const struct __lkf1__getOrderLikeList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTolkf2__getOrderLikeList(soap, "lkf2:getOrderLikeList", -1, &a->lkf2__getOrderLikeList_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __lkf1__getOrderLikeList * SOAP_FMAC4 soap_in___lkf1__getOrderLikeList(struct soap *soap, const char *tag, struct __lkf1__getOrderLikeList *a, const char *type)
{
	size_t soap_flag_lkf2__getOrderLikeList_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __lkf1__getOrderLikeList*)soap_id_enter(soap, "", a, SOAP_TYPE___lkf1__getOrderLikeList, sizeof(struct __lkf1__getOrderLikeList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___lkf1__getOrderLikeList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lkf2__getOrderLikeList_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTolkf2__getOrderLikeList(soap, "lkf2:getOrderLikeList", &a->lkf2__getOrderLikeList_, "lkf2:getOrderLikeList"))
				{	soap_flag_lkf2__getOrderLikeList_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __lkf1__getOrderLikeList * SOAP_FMAC2 soap_instantiate___lkf1__getOrderLikeList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___lkf1__getOrderLikeList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __lkf1__getOrderLikeList *p;
	size_t k = sizeof(struct __lkf1__getOrderLikeList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___lkf1__getOrderLikeList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __lkf1__getOrderLikeList);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __lkf1__getOrderLikeList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __lkf1__getOrderLikeList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___lkf1__getOrderLikeList(struct soap *soap, const struct __lkf1__getOrderLikeList *a, const char *tag, const char *type)
{
	if (soap_out___lkf1__getOrderLikeList(soap, tag ? tag : "-lkf1:getOrderLikeList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __lkf1__getOrderLikeList * SOAP_FMAC4 soap_get___lkf1__getOrderLikeList(struct soap *soap, struct __lkf1__getOrderLikeList *p, const char *tag, const char *type)
{
	if ((p = soap_in___lkf1__getOrderLikeList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___lkf1__deleteProductByInfo(struct soap *soap, struct __lkf1__deleteProductByInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->lkf2__deleteProductByInfo_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___lkf1__deleteProductByInfo(struct soap *soap, const struct __lkf1__deleteProductByInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTolkf2__deleteProductByInfo(soap, &a->lkf2__deleteProductByInfo_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___lkf1__deleteProductByInfo(struct soap *soap, const char *tag, int id, const struct __lkf1__deleteProductByInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTolkf2__deleteProductByInfo(soap, "lkf2:deleteProductByInfo", -1, &a->lkf2__deleteProductByInfo_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __lkf1__deleteProductByInfo * SOAP_FMAC4 soap_in___lkf1__deleteProductByInfo(struct soap *soap, const char *tag, struct __lkf1__deleteProductByInfo *a, const char *type)
{
	size_t soap_flag_lkf2__deleteProductByInfo_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __lkf1__deleteProductByInfo*)soap_id_enter(soap, "", a, SOAP_TYPE___lkf1__deleteProductByInfo, sizeof(struct __lkf1__deleteProductByInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___lkf1__deleteProductByInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lkf2__deleteProductByInfo_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTolkf2__deleteProductByInfo(soap, "lkf2:deleteProductByInfo", &a->lkf2__deleteProductByInfo_, "lkf2:deleteProductByInfo"))
				{	soap_flag_lkf2__deleteProductByInfo_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __lkf1__deleteProductByInfo * SOAP_FMAC2 soap_instantiate___lkf1__deleteProductByInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___lkf1__deleteProductByInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __lkf1__deleteProductByInfo *p;
	size_t k = sizeof(struct __lkf1__deleteProductByInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___lkf1__deleteProductByInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __lkf1__deleteProductByInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __lkf1__deleteProductByInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __lkf1__deleteProductByInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___lkf1__deleteProductByInfo(struct soap *soap, const struct __lkf1__deleteProductByInfo *a, const char *tag, const char *type)
{
	if (soap_out___lkf1__deleteProductByInfo(soap, tag ? tag : "-lkf1:deleteProductByInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __lkf1__deleteProductByInfo * SOAP_FMAC4 soap_get___lkf1__deleteProductByInfo(struct soap *soap, struct __lkf1__deleteProductByInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___lkf1__deleteProductByInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___lkf1__deleteClientByNameAndPwd(struct soap *soap, struct __lkf1__deleteClientByNameAndPwd *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->lkf2__deleteClientByNameAndPwd_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___lkf1__deleteClientByNameAndPwd(struct soap *soap, const struct __lkf1__deleteClientByNameAndPwd *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTolkf2__deleteClientByNameAndPwd(soap, &a->lkf2__deleteClientByNameAndPwd_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___lkf1__deleteClientByNameAndPwd(struct soap *soap, const char *tag, int id, const struct __lkf1__deleteClientByNameAndPwd *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTolkf2__deleteClientByNameAndPwd(soap, "lkf2:deleteClientByNameAndPwd", -1, &a->lkf2__deleteClientByNameAndPwd_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __lkf1__deleteClientByNameAndPwd * SOAP_FMAC4 soap_in___lkf1__deleteClientByNameAndPwd(struct soap *soap, const char *tag, struct __lkf1__deleteClientByNameAndPwd *a, const char *type)
{
	size_t soap_flag_lkf2__deleteClientByNameAndPwd_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __lkf1__deleteClientByNameAndPwd*)soap_id_enter(soap, "", a, SOAP_TYPE___lkf1__deleteClientByNameAndPwd, sizeof(struct __lkf1__deleteClientByNameAndPwd), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___lkf1__deleteClientByNameAndPwd(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lkf2__deleteClientByNameAndPwd_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTolkf2__deleteClientByNameAndPwd(soap, "lkf2:deleteClientByNameAndPwd", &a->lkf2__deleteClientByNameAndPwd_, "lkf2:deleteClientByNameAndPwd"))
				{	soap_flag_lkf2__deleteClientByNameAndPwd_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __lkf1__deleteClientByNameAndPwd * SOAP_FMAC2 soap_instantiate___lkf1__deleteClientByNameAndPwd(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___lkf1__deleteClientByNameAndPwd(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __lkf1__deleteClientByNameAndPwd *p;
	size_t k = sizeof(struct __lkf1__deleteClientByNameAndPwd);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___lkf1__deleteClientByNameAndPwd, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __lkf1__deleteClientByNameAndPwd);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __lkf1__deleteClientByNameAndPwd, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __lkf1__deleteClientByNameAndPwd location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___lkf1__deleteClientByNameAndPwd(struct soap *soap, const struct __lkf1__deleteClientByNameAndPwd *a, const char *tag, const char *type)
{
	if (soap_out___lkf1__deleteClientByNameAndPwd(soap, tag ? tag : "-lkf1:deleteClientByNameAndPwd", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __lkf1__deleteClientByNameAndPwd * SOAP_FMAC4 soap_get___lkf1__deleteClientByNameAndPwd(struct soap *soap, struct __lkf1__deleteClientByNameAndPwd *p, const char *tag, const char *type)
{
	if ((p = soap_in___lkf1__deleteClientByNameAndPwd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___lkf1__updateClient(struct soap *soap, struct __lkf1__updateClient *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->lkf2__updateClient_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___lkf1__updateClient(struct soap *soap, const struct __lkf1__updateClient *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTolkf2__updateClient(soap, &a->lkf2__updateClient_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___lkf1__updateClient(struct soap *soap, const char *tag, int id, const struct __lkf1__updateClient *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTolkf2__updateClient(soap, "lkf2:updateClient", -1, &a->lkf2__updateClient_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __lkf1__updateClient * SOAP_FMAC4 soap_in___lkf1__updateClient(struct soap *soap, const char *tag, struct __lkf1__updateClient *a, const char *type)
{
	size_t soap_flag_lkf2__updateClient_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __lkf1__updateClient*)soap_id_enter(soap, "", a, SOAP_TYPE___lkf1__updateClient, sizeof(struct __lkf1__updateClient), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___lkf1__updateClient(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lkf2__updateClient_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTolkf2__updateClient(soap, "lkf2:updateClient", &a->lkf2__updateClient_, "lkf2:updateClient"))
				{	soap_flag_lkf2__updateClient_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __lkf1__updateClient * SOAP_FMAC2 soap_instantiate___lkf1__updateClient(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___lkf1__updateClient(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __lkf1__updateClient *p;
	size_t k = sizeof(struct __lkf1__updateClient);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___lkf1__updateClient, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __lkf1__updateClient);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __lkf1__updateClient, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __lkf1__updateClient location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___lkf1__updateClient(struct soap *soap, const struct __lkf1__updateClient *a, const char *tag, const char *type)
{
	if (soap_out___lkf1__updateClient(soap, tag ? tag : "-lkf1:updateClient", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __lkf1__updateClient * SOAP_FMAC4 soap_get___lkf1__updateClient(struct soap *soap, struct __lkf1__updateClient *p, const char *tag, const char *type)
{
	if ((p = soap_in___lkf1__updateClient(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___lkf1__getProductListByInfo(struct soap *soap, struct __lkf1__getProductListByInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->lkf2__getProductListByInfo_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___lkf1__getProductListByInfo(struct soap *soap, const struct __lkf1__getProductListByInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTolkf2__getProductListByInfo(soap, &a->lkf2__getProductListByInfo_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___lkf1__getProductListByInfo(struct soap *soap, const char *tag, int id, const struct __lkf1__getProductListByInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTolkf2__getProductListByInfo(soap, "lkf2:getProductListByInfo", -1, &a->lkf2__getProductListByInfo_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __lkf1__getProductListByInfo * SOAP_FMAC4 soap_in___lkf1__getProductListByInfo(struct soap *soap, const char *tag, struct __lkf1__getProductListByInfo *a, const char *type)
{
	size_t soap_flag_lkf2__getProductListByInfo_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __lkf1__getProductListByInfo*)soap_id_enter(soap, "", a, SOAP_TYPE___lkf1__getProductListByInfo, sizeof(struct __lkf1__getProductListByInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___lkf1__getProductListByInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lkf2__getProductListByInfo_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTolkf2__getProductListByInfo(soap, "lkf2:getProductListByInfo", &a->lkf2__getProductListByInfo_, "lkf2:getProductListByInfo"))
				{	soap_flag_lkf2__getProductListByInfo_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __lkf1__getProductListByInfo * SOAP_FMAC2 soap_instantiate___lkf1__getProductListByInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___lkf1__getProductListByInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __lkf1__getProductListByInfo *p;
	size_t k = sizeof(struct __lkf1__getProductListByInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___lkf1__getProductListByInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __lkf1__getProductListByInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __lkf1__getProductListByInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __lkf1__getProductListByInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___lkf1__getProductListByInfo(struct soap *soap, const struct __lkf1__getProductListByInfo *a, const char *tag, const char *type)
{
	if (soap_out___lkf1__getProductListByInfo(soap, tag ? tag : "-lkf1:getProductListByInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __lkf1__getProductListByInfo * SOAP_FMAC4 soap_get___lkf1__getProductListByInfo(struct soap *soap, struct __lkf1__getProductListByInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___lkf1__getProductListByInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___lkf1__getOrderList(struct soap *soap, struct __lkf1__getOrderList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->lkf2__getOrderList_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___lkf1__getOrderList(struct soap *soap, const struct __lkf1__getOrderList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTolkf2__getOrderList(soap, &a->lkf2__getOrderList_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___lkf1__getOrderList(struct soap *soap, const char *tag, int id, const struct __lkf1__getOrderList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTolkf2__getOrderList(soap, "lkf2:getOrderList", -1, &a->lkf2__getOrderList_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __lkf1__getOrderList * SOAP_FMAC4 soap_in___lkf1__getOrderList(struct soap *soap, const char *tag, struct __lkf1__getOrderList *a, const char *type)
{
	size_t soap_flag_lkf2__getOrderList_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __lkf1__getOrderList*)soap_id_enter(soap, "", a, SOAP_TYPE___lkf1__getOrderList, sizeof(struct __lkf1__getOrderList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___lkf1__getOrderList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lkf2__getOrderList_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTolkf2__getOrderList(soap, "lkf2:getOrderList", &a->lkf2__getOrderList_, "lkf2:getOrderList"))
				{	soap_flag_lkf2__getOrderList_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __lkf1__getOrderList * SOAP_FMAC2 soap_instantiate___lkf1__getOrderList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___lkf1__getOrderList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __lkf1__getOrderList *p;
	size_t k = sizeof(struct __lkf1__getOrderList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___lkf1__getOrderList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __lkf1__getOrderList);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __lkf1__getOrderList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __lkf1__getOrderList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___lkf1__getOrderList(struct soap *soap, const struct __lkf1__getOrderList *a, const char *tag, const char *type)
{
	if (soap_out___lkf1__getOrderList(soap, tag ? tag : "-lkf1:getOrderList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __lkf1__getOrderList * SOAP_FMAC4 soap_get___lkf1__getOrderList(struct soap *soap, struct __lkf1__getOrderList *p, const char *tag, const char *type)
{
	if ((p = soap_in___lkf1__getOrderList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___lkf1__deleteProductTypeByName(struct soap *soap, struct __lkf1__deleteProductTypeByName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->lkf2__deleteProductTypeByName_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___lkf1__deleteProductTypeByName(struct soap *soap, const struct __lkf1__deleteProductTypeByName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTolkf2__deleteProductTypeByName(soap, &a->lkf2__deleteProductTypeByName_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___lkf1__deleteProductTypeByName(struct soap *soap, const char *tag, int id, const struct __lkf1__deleteProductTypeByName *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTolkf2__deleteProductTypeByName(soap, "lkf2:deleteProductTypeByName", -1, &a->lkf2__deleteProductTypeByName_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __lkf1__deleteProductTypeByName * SOAP_FMAC4 soap_in___lkf1__deleteProductTypeByName(struct soap *soap, const char *tag, struct __lkf1__deleteProductTypeByName *a, const char *type)
{
	size_t soap_flag_lkf2__deleteProductTypeByName_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __lkf1__deleteProductTypeByName*)soap_id_enter(soap, "", a, SOAP_TYPE___lkf1__deleteProductTypeByName, sizeof(struct __lkf1__deleteProductTypeByName), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___lkf1__deleteProductTypeByName(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lkf2__deleteProductTypeByName_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTolkf2__deleteProductTypeByName(soap, "lkf2:deleteProductTypeByName", &a->lkf2__deleteProductTypeByName_, "lkf2:deleteProductTypeByName"))
				{	soap_flag_lkf2__deleteProductTypeByName_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __lkf1__deleteProductTypeByName * SOAP_FMAC2 soap_instantiate___lkf1__deleteProductTypeByName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___lkf1__deleteProductTypeByName(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __lkf1__deleteProductTypeByName *p;
	size_t k = sizeof(struct __lkf1__deleteProductTypeByName);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___lkf1__deleteProductTypeByName, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __lkf1__deleteProductTypeByName);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __lkf1__deleteProductTypeByName, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __lkf1__deleteProductTypeByName location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___lkf1__deleteProductTypeByName(struct soap *soap, const struct __lkf1__deleteProductTypeByName *a, const char *tag, const char *type)
{
	if (soap_out___lkf1__deleteProductTypeByName(soap, tag ? tag : "-lkf1:deleteProductTypeByName", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __lkf1__deleteProductTypeByName * SOAP_FMAC4 soap_get___lkf1__deleteProductTypeByName(struct soap *soap, struct __lkf1__deleteProductTypeByName *p, const char *tag, const char *type)
{
	if ((p = soap_in___lkf1__deleteProductTypeByName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___lkf1__addProduct(struct soap *soap, struct __lkf1__addProduct *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->lkf2__addProduct_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___lkf1__addProduct(struct soap *soap, const struct __lkf1__addProduct *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTolkf2__addProduct(soap, &a->lkf2__addProduct_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___lkf1__addProduct(struct soap *soap, const char *tag, int id, const struct __lkf1__addProduct *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTolkf2__addProduct(soap, "lkf2:addProduct", -1, &a->lkf2__addProduct_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __lkf1__addProduct * SOAP_FMAC4 soap_in___lkf1__addProduct(struct soap *soap, const char *tag, struct __lkf1__addProduct *a, const char *type)
{
	size_t soap_flag_lkf2__addProduct_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __lkf1__addProduct*)soap_id_enter(soap, "", a, SOAP_TYPE___lkf1__addProduct, sizeof(struct __lkf1__addProduct), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___lkf1__addProduct(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lkf2__addProduct_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTolkf2__addProduct(soap, "lkf2:addProduct", &a->lkf2__addProduct_, "lkf2:addProduct"))
				{	soap_flag_lkf2__addProduct_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __lkf1__addProduct * SOAP_FMAC2 soap_instantiate___lkf1__addProduct(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___lkf1__addProduct(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __lkf1__addProduct *p;
	size_t k = sizeof(struct __lkf1__addProduct);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___lkf1__addProduct, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __lkf1__addProduct);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __lkf1__addProduct, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __lkf1__addProduct location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___lkf1__addProduct(struct soap *soap, const struct __lkf1__addProduct *a, const char *tag, const char *type)
{
	if (soap_out___lkf1__addProduct(soap, tag ? tag : "-lkf1:addProduct", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __lkf1__addProduct * SOAP_FMAC4 soap_get___lkf1__addProduct(struct soap *soap, struct __lkf1__addProduct *p, const char *tag, const char *type)
{
	if ((p = soap_in___lkf1__addProduct(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code, &mark);
	if (id < 0)
		return soap->error;
	(void)soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTolkf2__updateHistory(struct soap *soap, lkf2__updateHistory *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_lkf2__updateHistory))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTolkf2__updateHistory(struct soap *soap, const char *tag, int id, lkf2__updateHistory *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_lkf2__updateHistory, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_lkf2__updateHistory ? type : NULL);
}

SOAP_FMAC3 lkf2__updateHistory ** SOAP_FMAC4 soap_in_PointerTolkf2__updateHistory(struct soap *soap, const char *tag, lkf2__updateHistory **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (lkf2__updateHistory **)soap_malloc(soap, sizeof(lkf2__updateHistory *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (lkf2__updateHistory *)soap_instantiate_lkf2__updateHistory(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (lkf2__updateHistory **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_lkf2__updateHistory, sizeof(lkf2__updateHistory), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTolkf2__updateHistory(struct soap *soap, lkf2__updateHistory *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTolkf2__updateHistory(soap, tag ? tag : "lkf2:updateHistory", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 lkf2__updateHistory ** SOAP_FMAC4 soap_get_PointerTolkf2__updateHistory(struct soap *soap, lkf2__updateHistory **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTolkf2__updateHistory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTolkf2__getOrderListHistory(struct soap *soap, lkf2__getOrderListHistory *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_lkf2__getOrderListHistory))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTolkf2__getOrderListHistory(struct soap *soap, const char *tag, int id, lkf2__getOrderListHistory *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_lkf2__getOrderListHistory, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_lkf2__getOrderListHistory ? type : NULL);
}

SOAP_FMAC3 lkf2__getOrderListHistory ** SOAP_FMAC4 soap_in_PointerTolkf2__getOrderListHistory(struct soap *soap, const char *tag, lkf2__getOrderListHistory **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (lkf2__getOrderListHistory **)soap_malloc(soap, sizeof(lkf2__getOrderListHistory *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (lkf2__getOrderListHistory *)soap_instantiate_lkf2__getOrderListHistory(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (lkf2__getOrderListHistory **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_lkf2__getOrderListHistory, sizeof(lkf2__getOrderListHistory), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTolkf2__getOrderListHistory(struct soap *soap, lkf2__getOrderListHistory *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTolkf2__getOrderListHistory(soap, tag ? tag : "lkf2:getOrderListHistory", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 lkf2__getOrderListHistory ** SOAP_FMAC4 soap_get_PointerTolkf2__getOrderListHistory(struct soap *soap, lkf2__getOrderListHistory **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTolkf2__getOrderListHistory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTolkf2__InsertClient(struct soap *soap, lkf2__InsertClient *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_lkf2__InsertClient))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTolkf2__InsertClient(struct soap *soap, const char *tag, int id, lkf2__InsertClient *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_lkf2__InsertClient, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_lkf2__InsertClient ? type : NULL);
}

SOAP_FMAC3 lkf2__InsertClient ** SOAP_FMAC4 soap_in_PointerTolkf2__InsertClient(struct soap *soap, const char *tag, lkf2__InsertClient **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (lkf2__InsertClient **)soap_malloc(soap, sizeof(lkf2__InsertClient *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (lkf2__InsertClient *)soap_instantiate_lkf2__InsertClient(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (lkf2__InsertClient **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_lkf2__InsertClient, sizeof(lkf2__InsertClient), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTolkf2__InsertClient(struct soap *soap, lkf2__InsertClient *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTolkf2__InsertClient(soap, tag ? tag : "lkf2:InsertClient", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 lkf2__InsertClient ** SOAP_FMAC4 soap_get_PointerTolkf2__InsertClient(struct soap *soap, lkf2__InsertClient **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTolkf2__InsertClient(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTolkf2__getProductList(struct soap *soap, lkf2__getProductList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_lkf2__getProductList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTolkf2__getProductList(struct soap *soap, const char *tag, int id, lkf2__getProductList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_lkf2__getProductList, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_lkf2__getProductList ? type : NULL);
}

SOAP_FMAC3 lkf2__getProductList ** SOAP_FMAC4 soap_in_PointerTolkf2__getProductList(struct soap *soap, const char *tag, lkf2__getProductList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (lkf2__getProductList **)soap_malloc(soap, sizeof(lkf2__getProductList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (lkf2__getProductList *)soap_instantiate_lkf2__getProductList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (lkf2__getProductList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_lkf2__getProductList, sizeof(lkf2__getProductList), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTolkf2__getProductList(struct soap *soap, lkf2__getProductList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTolkf2__getProductList(soap, tag ? tag : "lkf2:getProductList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 lkf2__getProductList ** SOAP_FMAC4 soap_get_PointerTolkf2__getProductList(struct soap *soap, lkf2__getProductList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTolkf2__getProductList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTolkf2__deleteShoppingCart(struct soap *soap, lkf2__deleteShoppingCart *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_lkf2__deleteShoppingCart))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTolkf2__deleteShoppingCart(struct soap *soap, const char *tag, int id, lkf2__deleteShoppingCart *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_lkf2__deleteShoppingCart, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_lkf2__deleteShoppingCart ? type : NULL);
}

SOAP_FMAC3 lkf2__deleteShoppingCart ** SOAP_FMAC4 soap_in_PointerTolkf2__deleteShoppingCart(struct soap *soap, const char *tag, lkf2__deleteShoppingCart **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (lkf2__deleteShoppingCart **)soap_malloc(soap, sizeof(lkf2__deleteShoppingCart *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (lkf2__deleteShoppingCart *)soap_instantiate_lkf2__deleteShoppingCart(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (lkf2__deleteShoppingCart **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_lkf2__deleteShoppingCart, sizeof(lkf2__deleteShoppingCart), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTolkf2__deleteShoppingCart(struct soap *soap, lkf2__deleteShoppingCart *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTolkf2__deleteShoppingCart(soap, tag ? tag : "lkf2:deleteShoppingCart", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 lkf2__deleteShoppingCart ** SOAP_FMAC4 soap_get_PointerTolkf2__deleteShoppingCart(struct soap *soap, lkf2__deleteShoppingCart **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTolkf2__deleteShoppingCart(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTolkf2__getClientByNameAndPwd(struct soap *soap, lkf2__getClientByNameAndPwd *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_lkf2__getClientByNameAndPwd))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTolkf2__getClientByNameAndPwd(struct soap *soap, const char *tag, int id, lkf2__getClientByNameAndPwd *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_lkf2__getClientByNameAndPwd, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_lkf2__getClientByNameAndPwd ? type : NULL);
}

SOAP_FMAC3 lkf2__getClientByNameAndPwd ** SOAP_FMAC4 soap_in_PointerTolkf2__getClientByNameAndPwd(struct soap *soap, const char *tag, lkf2__getClientByNameAndPwd **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (lkf2__getClientByNameAndPwd **)soap_malloc(soap, sizeof(lkf2__getClientByNameAndPwd *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (lkf2__getClientByNameAndPwd *)soap_instantiate_lkf2__getClientByNameAndPwd(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (lkf2__getClientByNameAndPwd **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_lkf2__getClientByNameAndPwd, sizeof(lkf2__getClientByNameAndPwd), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTolkf2__getClientByNameAndPwd(struct soap *soap, lkf2__getClientByNameAndPwd *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTolkf2__getClientByNameAndPwd(soap, tag ? tag : "lkf2:getClientByNameAndPwd", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 lkf2__getClientByNameAndPwd ** SOAP_FMAC4 soap_get_PointerTolkf2__getClientByNameAndPwd(struct soap *soap, lkf2__getClientByNameAndPwd **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTolkf2__getClientByNameAndPwd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTolkf2__addOrder(struct soap *soap, lkf2__addOrder *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_lkf2__addOrder))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTolkf2__addOrder(struct soap *soap, const char *tag, int id, lkf2__addOrder *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_lkf2__addOrder, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_lkf2__addOrder ? type : NULL);
}

SOAP_FMAC3 lkf2__addOrder ** SOAP_FMAC4 soap_in_PointerTolkf2__addOrder(struct soap *soap, const char *tag, lkf2__addOrder **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (lkf2__addOrder **)soap_malloc(soap, sizeof(lkf2__addOrder *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (lkf2__addOrder *)soap_instantiate_lkf2__addOrder(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (lkf2__addOrder **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_lkf2__addOrder, sizeof(lkf2__addOrder), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTolkf2__addOrder(struct soap *soap, lkf2__addOrder *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTolkf2__addOrder(soap, tag ? tag : "lkf2:addOrder", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 lkf2__addOrder ** SOAP_FMAC4 soap_get_PointerTolkf2__addOrder(struct soap *soap, lkf2__addOrder **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTolkf2__addOrder(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTolkf2__getProductLikeList(struct soap *soap, lkf2__getProductLikeList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_lkf2__getProductLikeList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTolkf2__getProductLikeList(struct soap *soap, const char *tag, int id, lkf2__getProductLikeList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_lkf2__getProductLikeList, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_lkf2__getProductLikeList ? type : NULL);
}

SOAP_FMAC3 lkf2__getProductLikeList ** SOAP_FMAC4 soap_in_PointerTolkf2__getProductLikeList(struct soap *soap, const char *tag, lkf2__getProductLikeList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (lkf2__getProductLikeList **)soap_malloc(soap, sizeof(lkf2__getProductLikeList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (lkf2__getProductLikeList *)soap_instantiate_lkf2__getProductLikeList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (lkf2__getProductLikeList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_lkf2__getProductLikeList, sizeof(lkf2__getProductLikeList), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTolkf2__getProductLikeList(struct soap *soap, lkf2__getProductLikeList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTolkf2__getProductLikeList(soap, tag ? tag : "lkf2:getProductLikeList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 lkf2__getProductLikeList ** SOAP_FMAC4 soap_get_PointerTolkf2__getProductLikeList(struct soap *soap, lkf2__getProductLikeList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTolkf2__getProductLikeList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTolkf2__updateProductByInfo(struct soap *soap, lkf2__updateProductByInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_lkf2__updateProductByInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTolkf2__updateProductByInfo(struct soap *soap, const char *tag, int id, lkf2__updateProductByInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_lkf2__updateProductByInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_lkf2__updateProductByInfo ? type : NULL);
}

SOAP_FMAC3 lkf2__updateProductByInfo ** SOAP_FMAC4 soap_in_PointerTolkf2__updateProductByInfo(struct soap *soap, const char *tag, lkf2__updateProductByInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (lkf2__updateProductByInfo **)soap_malloc(soap, sizeof(lkf2__updateProductByInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (lkf2__updateProductByInfo *)soap_instantiate_lkf2__updateProductByInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (lkf2__updateProductByInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_lkf2__updateProductByInfo, sizeof(lkf2__updateProductByInfo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTolkf2__updateProductByInfo(struct soap *soap, lkf2__updateProductByInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTolkf2__updateProductByInfo(soap, tag ? tag : "lkf2:updateProductByInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 lkf2__updateProductByInfo ** SOAP_FMAC4 soap_get_PointerTolkf2__updateProductByInfo(struct soap *soap, lkf2__updateProductByInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTolkf2__updateProductByInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTolkf2__addProductType(struct soap *soap, lkf2__addProductType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_lkf2__addProductType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTolkf2__addProductType(struct soap *soap, const char *tag, int id, lkf2__addProductType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_lkf2__addProductType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_lkf2__addProductType ? type : NULL);
}

SOAP_FMAC3 lkf2__addProductType ** SOAP_FMAC4 soap_in_PointerTolkf2__addProductType(struct soap *soap, const char *tag, lkf2__addProductType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (lkf2__addProductType **)soap_malloc(soap, sizeof(lkf2__addProductType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (lkf2__addProductType *)soap_instantiate_lkf2__addProductType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (lkf2__addProductType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_lkf2__addProductType, sizeof(lkf2__addProductType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTolkf2__addProductType(struct soap *soap, lkf2__addProductType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTolkf2__addProductType(soap, tag ? tag : "lkf2:addProductType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 lkf2__addProductType ** SOAP_FMAC4 soap_get_PointerTolkf2__addProductType(struct soap *soap, lkf2__addProductType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTolkf2__addProductType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTolkf2__getOrderListByInfo(struct soap *soap, lkf2__getOrderListByInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_lkf2__getOrderListByInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTolkf2__getOrderListByInfo(struct soap *soap, const char *tag, int id, lkf2__getOrderListByInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_lkf2__getOrderListByInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_lkf2__getOrderListByInfo ? type : NULL);
}

SOAP_FMAC3 lkf2__getOrderListByInfo ** SOAP_FMAC4 soap_in_PointerTolkf2__getOrderListByInfo(struct soap *soap, const char *tag, lkf2__getOrderListByInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (lkf2__getOrderListByInfo **)soap_malloc(soap, sizeof(lkf2__getOrderListByInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (lkf2__getOrderListByInfo *)soap_instantiate_lkf2__getOrderListByInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (lkf2__getOrderListByInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_lkf2__getOrderListByInfo, sizeof(lkf2__getOrderListByInfo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTolkf2__getOrderListByInfo(struct soap *soap, lkf2__getOrderListByInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTolkf2__getOrderListByInfo(soap, tag ? tag : "lkf2:getOrderListByInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 lkf2__getOrderListByInfo ** SOAP_FMAC4 soap_get_PointerTolkf2__getOrderListByInfo(struct soap *soap, lkf2__getOrderListByInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTolkf2__getOrderListByInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTolkf2__getClientList(struct soap *soap, lkf2__getClientList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_lkf2__getClientList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTolkf2__getClientList(struct soap *soap, const char *tag, int id, lkf2__getClientList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_lkf2__getClientList, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_lkf2__getClientList ? type : NULL);
}

SOAP_FMAC3 lkf2__getClientList ** SOAP_FMAC4 soap_in_PointerTolkf2__getClientList(struct soap *soap, const char *tag, lkf2__getClientList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (lkf2__getClientList **)soap_malloc(soap, sizeof(lkf2__getClientList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (lkf2__getClientList *)soap_instantiate_lkf2__getClientList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (lkf2__getClientList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_lkf2__getClientList, sizeof(lkf2__getClientList), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTolkf2__getClientList(struct soap *soap, lkf2__getClientList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTolkf2__getClientList(soap, tag ? tag : "lkf2:getClientList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 lkf2__getClientList ** SOAP_FMAC4 soap_get_PointerTolkf2__getClientList(struct soap *soap, lkf2__getClientList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTolkf2__getClientList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTolkf2__getProductTypeByProName(struct soap *soap, lkf2__getProductTypeByProName *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_lkf2__getProductTypeByProName))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTolkf2__getProductTypeByProName(struct soap *soap, const char *tag, int id, lkf2__getProductTypeByProName *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_lkf2__getProductTypeByProName, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_lkf2__getProductTypeByProName ? type : NULL);
}

SOAP_FMAC3 lkf2__getProductTypeByProName ** SOAP_FMAC4 soap_in_PointerTolkf2__getProductTypeByProName(struct soap *soap, const char *tag, lkf2__getProductTypeByProName **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (lkf2__getProductTypeByProName **)soap_malloc(soap, sizeof(lkf2__getProductTypeByProName *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (lkf2__getProductTypeByProName *)soap_instantiate_lkf2__getProductTypeByProName(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (lkf2__getProductTypeByProName **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_lkf2__getProductTypeByProName, sizeof(lkf2__getProductTypeByProName), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTolkf2__getProductTypeByProName(struct soap *soap, lkf2__getProductTypeByProName *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTolkf2__getProductTypeByProName(soap, tag ? tag : "lkf2:getProductTypeByProName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 lkf2__getProductTypeByProName ** SOAP_FMAC4 soap_get_PointerTolkf2__getProductTypeByProName(struct soap *soap, lkf2__getProductTypeByProName **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTolkf2__getProductTypeByProName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTolkf2__getClientLikeList(struct soap *soap, lkf2__getClientLikeList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_lkf2__getClientLikeList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTolkf2__getClientLikeList(struct soap *soap, const char *tag, int id, lkf2__getClientLikeList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_lkf2__getClientLikeList, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_lkf2__getClientLikeList ? type : NULL);
}

SOAP_FMAC3 lkf2__getClientLikeList ** SOAP_FMAC4 soap_in_PointerTolkf2__getClientLikeList(struct soap *soap, const char *tag, lkf2__getClientLikeList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (lkf2__getClientLikeList **)soap_malloc(soap, sizeof(lkf2__getClientLikeList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (lkf2__getClientLikeList *)soap_instantiate_lkf2__getClientLikeList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (lkf2__getClientLikeList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_lkf2__getClientLikeList, sizeof(lkf2__getClientLikeList), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTolkf2__getClientLikeList(struct soap *soap, lkf2__getClientLikeList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTolkf2__getClientLikeList(soap, tag ? tag : "lkf2:getClientLikeList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 lkf2__getClientLikeList ** SOAP_FMAC4 soap_get_PointerTolkf2__getClientLikeList(struct soap *soap, lkf2__getClientLikeList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTolkf2__getClientLikeList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTolkf2__getOrderLikeList(struct soap *soap, lkf2__getOrderLikeList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_lkf2__getOrderLikeList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTolkf2__getOrderLikeList(struct soap *soap, const char *tag, int id, lkf2__getOrderLikeList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_lkf2__getOrderLikeList, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_lkf2__getOrderLikeList ? type : NULL);
}

SOAP_FMAC3 lkf2__getOrderLikeList ** SOAP_FMAC4 soap_in_PointerTolkf2__getOrderLikeList(struct soap *soap, const char *tag, lkf2__getOrderLikeList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (lkf2__getOrderLikeList **)soap_malloc(soap, sizeof(lkf2__getOrderLikeList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (lkf2__getOrderLikeList *)soap_instantiate_lkf2__getOrderLikeList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (lkf2__getOrderLikeList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_lkf2__getOrderLikeList, sizeof(lkf2__getOrderLikeList), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTolkf2__getOrderLikeList(struct soap *soap, lkf2__getOrderLikeList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTolkf2__getOrderLikeList(soap, tag ? tag : "lkf2:getOrderLikeList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 lkf2__getOrderLikeList ** SOAP_FMAC4 soap_get_PointerTolkf2__getOrderLikeList(struct soap *soap, lkf2__getOrderLikeList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTolkf2__getOrderLikeList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTolkf2__deleteProductByInfo(struct soap *soap, lkf2__deleteProductByInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_lkf2__deleteProductByInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTolkf2__deleteProductByInfo(struct soap *soap, const char *tag, int id, lkf2__deleteProductByInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_lkf2__deleteProductByInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_lkf2__deleteProductByInfo ? type : NULL);
}

SOAP_FMAC3 lkf2__deleteProductByInfo ** SOAP_FMAC4 soap_in_PointerTolkf2__deleteProductByInfo(struct soap *soap, const char *tag, lkf2__deleteProductByInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (lkf2__deleteProductByInfo **)soap_malloc(soap, sizeof(lkf2__deleteProductByInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (lkf2__deleteProductByInfo *)soap_instantiate_lkf2__deleteProductByInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (lkf2__deleteProductByInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_lkf2__deleteProductByInfo, sizeof(lkf2__deleteProductByInfo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTolkf2__deleteProductByInfo(struct soap *soap, lkf2__deleteProductByInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTolkf2__deleteProductByInfo(soap, tag ? tag : "lkf2:deleteProductByInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 lkf2__deleteProductByInfo ** SOAP_FMAC4 soap_get_PointerTolkf2__deleteProductByInfo(struct soap *soap, lkf2__deleteProductByInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTolkf2__deleteProductByInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTolkf2__deleteClientByNameAndPwd(struct soap *soap, lkf2__deleteClientByNameAndPwd *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_lkf2__deleteClientByNameAndPwd))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTolkf2__deleteClientByNameAndPwd(struct soap *soap, const char *tag, int id, lkf2__deleteClientByNameAndPwd *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_lkf2__deleteClientByNameAndPwd, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_lkf2__deleteClientByNameAndPwd ? type : NULL);
}

SOAP_FMAC3 lkf2__deleteClientByNameAndPwd ** SOAP_FMAC4 soap_in_PointerTolkf2__deleteClientByNameAndPwd(struct soap *soap, const char *tag, lkf2__deleteClientByNameAndPwd **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (lkf2__deleteClientByNameAndPwd **)soap_malloc(soap, sizeof(lkf2__deleteClientByNameAndPwd *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (lkf2__deleteClientByNameAndPwd *)soap_instantiate_lkf2__deleteClientByNameAndPwd(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (lkf2__deleteClientByNameAndPwd **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_lkf2__deleteClientByNameAndPwd, sizeof(lkf2__deleteClientByNameAndPwd), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTolkf2__deleteClientByNameAndPwd(struct soap *soap, lkf2__deleteClientByNameAndPwd *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTolkf2__deleteClientByNameAndPwd(soap, tag ? tag : "lkf2:deleteClientByNameAndPwd", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 lkf2__deleteClientByNameAndPwd ** SOAP_FMAC4 soap_get_PointerTolkf2__deleteClientByNameAndPwd(struct soap *soap, lkf2__deleteClientByNameAndPwd **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTolkf2__deleteClientByNameAndPwd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTolkf2__updateClient(struct soap *soap, lkf2__updateClient *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_lkf2__updateClient))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTolkf2__updateClient(struct soap *soap, const char *tag, int id, lkf2__updateClient *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_lkf2__updateClient, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_lkf2__updateClient ? type : NULL);
}

SOAP_FMAC3 lkf2__updateClient ** SOAP_FMAC4 soap_in_PointerTolkf2__updateClient(struct soap *soap, const char *tag, lkf2__updateClient **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (lkf2__updateClient **)soap_malloc(soap, sizeof(lkf2__updateClient *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (lkf2__updateClient *)soap_instantiate_lkf2__updateClient(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (lkf2__updateClient **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_lkf2__updateClient, sizeof(lkf2__updateClient), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTolkf2__updateClient(struct soap *soap, lkf2__updateClient *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTolkf2__updateClient(soap, tag ? tag : "lkf2:updateClient", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 lkf2__updateClient ** SOAP_FMAC4 soap_get_PointerTolkf2__updateClient(struct soap *soap, lkf2__updateClient **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTolkf2__updateClient(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTolkf2__getProductListByInfo(struct soap *soap, lkf2__getProductListByInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_lkf2__getProductListByInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTolkf2__getProductListByInfo(struct soap *soap, const char *tag, int id, lkf2__getProductListByInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_lkf2__getProductListByInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_lkf2__getProductListByInfo ? type : NULL);
}

SOAP_FMAC3 lkf2__getProductListByInfo ** SOAP_FMAC4 soap_in_PointerTolkf2__getProductListByInfo(struct soap *soap, const char *tag, lkf2__getProductListByInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (lkf2__getProductListByInfo **)soap_malloc(soap, sizeof(lkf2__getProductListByInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (lkf2__getProductListByInfo *)soap_instantiate_lkf2__getProductListByInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (lkf2__getProductListByInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_lkf2__getProductListByInfo, sizeof(lkf2__getProductListByInfo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTolkf2__getProductListByInfo(struct soap *soap, lkf2__getProductListByInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTolkf2__getProductListByInfo(soap, tag ? tag : "lkf2:getProductListByInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 lkf2__getProductListByInfo ** SOAP_FMAC4 soap_get_PointerTolkf2__getProductListByInfo(struct soap *soap, lkf2__getProductListByInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTolkf2__getProductListByInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTolkf2__getOrderList(struct soap *soap, lkf2__getOrderList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_lkf2__getOrderList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTolkf2__getOrderList(struct soap *soap, const char *tag, int id, lkf2__getOrderList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_lkf2__getOrderList, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_lkf2__getOrderList ? type : NULL);
}

SOAP_FMAC3 lkf2__getOrderList ** SOAP_FMAC4 soap_in_PointerTolkf2__getOrderList(struct soap *soap, const char *tag, lkf2__getOrderList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (lkf2__getOrderList **)soap_malloc(soap, sizeof(lkf2__getOrderList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (lkf2__getOrderList *)soap_instantiate_lkf2__getOrderList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (lkf2__getOrderList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_lkf2__getOrderList, sizeof(lkf2__getOrderList), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTolkf2__getOrderList(struct soap *soap, lkf2__getOrderList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTolkf2__getOrderList(soap, tag ? tag : "lkf2:getOrderList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 lkf2__getOrderList ** SOAP_FMAC4 soap_get_PointerTolkf2__getOrderList(struct soap *soap, lkf2__getOrderList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTolkf2__getOrderList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTolkf2__deleteProductTypeByName(struct soap *soap, lkf2__deleteProductTypeByName *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_lkf2__deleteProductTypeByName))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTolkf2__deleteProductTypeByName(struct soap *soap, const char *tag, int id, lkf2__deleteProductTypeByName *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_lkf2__deleteProductTypeByName, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_lkf2__deleteProductTypeByName ? type : NULL);
}

SOAP_FMAC3 lkf2__deleteProductTypeByName ** SOAP_FMAC4 soap_in_PointerTolkf2__deleteProductTypeByName(struct soap *soap, const char *tag, lkf2__deleteProductTypeByName **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (lkf2__deleteProductTypeByName **)soap_malloc(soap, sizeof(lkf2__deleteProductTypeByName *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (lkf2__deleteProductTypeByName *)soap_instantiate_lkf2__deleteProductTypeByName(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (lkf2__deleteProductTypeByName **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_lkf2__deleteProductTypeByName, sizeof(lkf2__deleteProductTypeByName), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTolkf2__deleteProductTypeByName(struct soap *soap, lkf2__deleteProductTypeByName *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTolkf2__deleteProductTypeByName(soap, tag ? tag : "lkf2:deleteProductTypeByName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 lkf2__deleteProductTypeByName ** SOAP_FMAC4 soap_get_PointerTolkf2__deleteProductTypeByName(struct soap *soap, lkf2__deleteProductTypeByName **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTolkf2__deleteProductTypeByName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTolkf2__addProduct(struct soap *soap, lkf2__addProduct *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_lkf2__addProduct))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTolkf2__addProduct(struct soap *soap, const char *tag, int id, lkf2__addProduct *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_lkf2__addProduct, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_lkf2__addProduct ? type : NULL);
}

SOAP_FMAC3 lkf2__addProduct ** SOAP_FMAC4 soap_in_PointerTolkf2__addProduct(struct soap *soap, const char *tag, lkf2__addProduct **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (lkf2__addProduct **)soap_malloc(soap, sizeof(lkf2__addProduct *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (lkf2__addProduct *)soap_instantiate_lkf2__addProduct(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (lkf2__addProduct **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_lkf2__addProduct, sizeof(lkf2__addProduct), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTolkf2__addProduct(struct soap *soap, lkf2__addProduct *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTolkf2__addProduct(soap, tag ? tag : "lkf2:addProduct", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 lkf2__addProduct ** SOAP_FMAC4 soap_get_PointerTolkf2__addProduct(struct soap *soap, lkf2__addProduct **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTolkf2__addProduct(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTolkf2__productType(struct soap *soap, lkf2__productType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_lkf2__productType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTolkf2__productType(struct soap *soap, const char *tag, int id, lkf2__productType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_lkf2__productType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_lkf2__productType ? type : NULL);
}

SOAP_FMAC3 lkf2__productType ** SOAP_FMAC4 soap_in_PointerTolkf2__productType(struct soap *soap, const char *tag, lkf2__productType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (lkf2__productType **)soap_malloc(soap, sizeof(lkf2__productType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (lkf2__productType *)soap_instantiate_lkf2__productType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (lkf2__productType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_lkf2__productType, sizeof(lkf2__productType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTolkf2__productType(struct soap *soap, lkf2__productType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTolkf2__productType(soap, tag ? tag : "lkf2:productType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 lkf2__productType ** SOAP_FMAC4 soap_get_PointerTolkf2__productType(struct soap *soap, lkf2__productType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTolkf2__productType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTolkf2__client(struct soap *soap, lkf2__client *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_lkf2__client))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTolkf2__client(struct soap *soap, const char *tag, int id, lkf2__client *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_lkf2__client, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_lkf2__client ? type : NULL);
}

SOAP_FMAC3 lkf2__client ** SOAP_FMAC4 soap_in_PointerTolkf2__client(struct soap *soap, const char *tag, lkf2__client **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (lkf2__client **)soap_malloc(soap, sizeof(lkf2__client *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (lkf2__client *)soap_instantiate_lkf2__client(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (lkf2__client **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_lkf2__client, sizeof(lkf2__client), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTolkf2__client(struct soap *soap, lkf2__client *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTolkf2__client(soap, tag ? tag : "lkf2:client", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 lkf2__client ** SOAP_FMAC4 soap_get_PointerTolkf2__client(struct soap *soap, lkf2__client **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTolkf2__client(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodateTime(struct soap *soap, time_t *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_dateTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTodateTime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dateTime, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_dateTime(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_in_PointerTodateTime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_dateTime(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dateTime, sizeof(time_t), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodateTime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTodateTime(soap, tag ? tag : "dateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTodateTime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTodateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__decimal(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__decimal))
		soap_serialize_xsd__decimal(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__decimal(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__decimal, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__decimal(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__decimal(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__decimal(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__decimal, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__decimal(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__decimal(soap, tag ? tag : "xsd:decimal", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__decimal(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__decimal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTolkf2__order(struct soap *soap, lkf2__order *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_lkf2__order))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTolkf2__order(struct soap *soap, const char *tag, int id, lkf2__order *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_lkf2__order, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_lkf2__order ? type : NULL);
}

SOAP_FMAC3 lkf2__order ** SOAP_FMAC4 soap_in_PointerTolkf2__order(struct soap *soap, const char *tag, lkf2__order **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (lkf2__order **)soap_malloc(soap, sizeof(lkf2__order *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (lkf2__order *)soap_instantiate_lkf2__order(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (lkf2__order **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_lkf2__order, sizeof(lkf2__order), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTolkf2__order(struct soap *soap, lkf2__order *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTolkf2__order(soap, tag ? tag : "lkf2:order", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 lkf2__order ** SOAP_FMAC4 soap_get_PointerTolkf2__order(struct soap *soap, lkf2__order **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTolkf2__order(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTostd__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTolkf2__product(struct soap *soap, lkf2__product *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_lkf2__product))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTolkf2__product(struct soap *soap, const char *tag, int id, lkf2__product *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_lkf2__product, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_lkf2__product ? type : NULL);
}

SOAP_FMAC3 lkf2__product ** SOAP_FMAC4 soap_in_PointerTolkf2__product(struct soap *soap, const char *tag, lkf2__product **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (lkf2__product **)soap_malloc(soap, sizeof(lkf2__product *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (lkf2__product *)soap_instantiate_lkf2__product(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (lkf2__product **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_lkf2__product, sizeof(lkf2__product), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTolkf2__product(struct soap *soap, lkf2__product *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTolkf2__product(soap, tag ? tag : "lkf2:product", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 lkf2__product ** SOAP_FMAC4 soap_get_PointerTolkf2__product(struct soap *soap, lkf2__product **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTolkf2__product(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__QName(soap, tag ? tag : "QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_new_string(struct soap *soap, int n)
{
	char * *a = static_cast<char * *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char *)));
	for (char * *p = a; p && n--; ++p)
		soap_default_string(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTolkf2__productType(struct soap *soap, std::vector<lkf2__productType *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTolkf2__productType(struct soap *soap, const std::vector<lkf2__productType *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<lkf2__productType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTolkf2__productType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTolkf2__productType(struct soap *soap, const char *tag, int id, const std::vector<lkf2__productType *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<lkf2__productType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTolkf2__productType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<lkf2__productType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTolkf2__productType(struct soap *soap, const char *tag, std::vector<lkf2__productType *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTolkf2__productType(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		lkf2__productType *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_lkf2__productType, SOAP_TYPE_std__vectorTemplateOfPointerTolkf2__productType, sizeof(lkf2__productType), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTolkf2__productType(soap, tag, NULL, "lkf2:productType"))
				break;
		}
		else
		{	if (!soap_in_PointerTolkf2__productType(soap, tag, &n, "lkf2:productType"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<lkf2__productType *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTolkf2__productType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTolkf2__productType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<lkf2__productType *> *p;
	size_t k = sizeof(std::vector<lkf2__productType *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTolkf2__productType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<lkf2__productType *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<lkf2__productType *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<lkf2__productType *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTolkf2__client(struct soap *soap, std::vector<lkf2__client *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTolkf2__client(struct soap *soap, const std::vector<lkf2__client *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<lkf2__client *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTolkf2__client(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTolkf2__client(struct soap *soap, const char *tag, int id, const std::vector<lkf2__client *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<lkf2__client *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTolkf2__client(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<lkf2__client *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTolkf2__client(struct soap *soap, const char *tag, std::vector<lkf2__client *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTolkf2__client(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		lkf2__client *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_lkf2__client, SOAP_TYPE_std__vectorTemplateOfPointerTolkf2__client, sizeof(lkf2__client), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTolkf2__client(soap, tag, NULL, "lkf2:client"))
				break;
		}
		else
		{	if (!soap_in_PointerTolkf2__client(soap, tag, &n, "lkf2:client"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<lkf2__client *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTolkf2__client(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTolkf2__client(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<lkf2__client *> *p;
	size_t k = sizeof(std::vector<lkf2__client *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTolkf2__client, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<lkf2__client *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<lkf2__client *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<lkf2__client *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTolkf2__product(struct soap *soap, std::vector<lkf2__product *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTolkf2__product(struct soap *soap, const std::vector<lkf2__product *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<lkf2__product *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTolkf2__product(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTolkf2__product(struct soap *soap, const char *tag, int id, const std::vector<lkf2__product *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<lkf2__product *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTolkf2__product(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<lkf2__product *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTolkf2__product(struct soap *soap, const char *tag, std::vector<lkf2__product *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTolkf2__product(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		lkf2__product *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_lkf2__product, SOAP_TYPE_std__vectorTemplateOfPointerTolkf2__product, sizeof(lkf2__product), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTolkf2__product(soap, tag, NULL, "lkf2:product"))
				break;
		}
		else
		{	if (!soap_in_PointerTolkf2__product(soap, tag, &n, "lkf2:product"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<lkf2__product *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTolkf2__product(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTolkf2__product(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<lkf2__product *> *p;
	size_t k = sizeof(std::vector<lkf2__product *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTolkf2__product, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<lkf2__product *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<lkf2__product *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<lkf2__product *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTolkf2__order(struct soap *soap, std::vector<lkf2__order *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTolkf2__order(struct soap *soap, const std::vector<lkf2__order *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<lkf2__order *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTolkf2__order(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTolkf2__order(struct soap *soap, const char *tag, int id, const std::vector<lkf2__order *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<lkf2__order *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTolkf2__order(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<lkf2__order *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTolkf2__order(struct soap *soap, const char *tag, std::vector<lkf2__order *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTolkf2__order(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		lkf2__order *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_lkf2__order, SOAP_TYPE_std__vectorTemplateOfPointerTolkf2__order, sizeof(lkf2__order), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTolkf2__order(soap, tag, NULL, "lkf2:order"))
				break;
		}
		else
		{	if (!soap_in_PointerTolkf2__order(soap, tag, &n, "lkf2:order"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<lkf2__order *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTolkf2__order(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTolkf2__order(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<lkf2__order *> *p;
	size_t k = sizeof(std::vector<lkf2__order *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTolkf2__order, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<lkf2__order *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<lkf2__order *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<lkf2__order *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
